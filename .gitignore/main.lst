CCS PCH C Compiler, Version 5.112, 5967               14-Apr-25 18:14

               Filename:   C:\Users\ganga\OneDrive\Documents\------TEMUULEL------\TEST_REPORT\Enginering model\CODE\VSbased development\OBC\main.lst

               ROM used:   18326 bytes (14%)
                           Largest free fragment is 65520
               RAM used:   434 (12%) at main() level
                           764 (21%) worst case
               Stack used: 4 locations
               Stack size: 30

*
00000:  NOP   
00002:  GOTO   44B0
.................... 
.................... #include <main.h>
.................... /* 
....................  * File:   main.h
....................  * Author: Ganji
....................  *
....................  * Created on October 22, 2024, 3:31 PM
....................  */
.................... 
....................  #ifndef MAIN_H
....................  #define	MAIN_H
....................  
....................  #ifdef	__cplusplus
....................  extern "C" {
....................  #endif
....................  #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
00006:  DATA 57,52
00008:  DATA 49,54
0000A:  DATA 45,20
0000C:  DATA 41,44
0000E:  DATA 44,52
00010:  DATA 45,53
00012:  DATA 53,3A
00014:  DATA 20,30
00016:  DATA 78,25
00018:  DATA 30,38
0001A:  DATA 6C,78
0001C:  DATA 0A,00
0001E:  DATA 0A,25
00020:  DATA 64,20
00022:  DATA 42,59
00024:  DATA 54,45
00026:  DATA 53,20
00028:  DATA 57,52
0002A:  DATA 49,54
0002C:  DATA 54,45
0002E:  DATA 4E,20
00030:  DATA 49,4E
00032:  DATA 20,4D
00034:  DATA 41,49
00036:  DATA 4E,21
00038:  DATA 0A,00
0003A:  DATA 57,52
0003C:  DATA 49,54
0003E:  DATA 45,20
00040:  DATA 41,44
00042:  DATA 44,52
00044:  DATA 45,53
00046:  DATA 53,20
00048:  DATA 49,4E
0004A:  DATA 20,43
0004C:  DATA 4F,4D
0004E:  DATA 3A,20
00050:  DATA 30,78
00052:  DATA 25,30
00054:  DATA 38,6C
00056:  DATA 78,0A
00058:  DATA 00,00
0005A:  DATA 0A,25
0005C:  DATA 64,20
0005E:  DATA 42,59
00060:  DATA 54,45
00062:  DATA 53,20
00064:  DATA 57,52
00066:  DATA 49,54
00068:  DATA 54,45
0006A:  DATA 4E,20
0006C:  DATA 49,4E
0006E:  DATA 20,43
00070:  DATA 4F,4D
00072:  DATA 21,0A
00074:  DATA 00,00
00076:  DATA 57,52
00078:  DATA 49,54
0007A:  DATA 45,20
0007C:  DATA 41,44
0007E:  DATA 44,52
00080:  DATA 45,53
00082:  DATA 53,20
00084:  DATA 49,4E
00086:  DATA 20,41
00088:  DATA 44,43
0008A:  DATA 53,3A
0008C:  DATA 20,30
0008E:  DATA 78,25
00090:  DATA 30,38
00092:  DATA 6C,78
00094:  DATA 0A,00
00096:  DATA 0A,25
00098:  DATA 64,20
0009A:  DATA 42,59
0009C:  DATA 54,45
0009E:  DATA 53,20
000A0:  DATA 57,52
000A2:  DATA 49,54
000A4:  DATA 54,45
000A6:  DATA 4E,20
000A8:  DATA 49,4E
000AA:  DATA 20,41
000AC:  DATA 44,43
000AE:  DATA 53,21
000B0:  DATA 0A,00
000B2:  DATA 20,20
000B4:  DATA 30,78
000B6:  DATA 25,30
000B8:  DATA 32,78
000BA:  DATA 00,00
000BC:  DATA 50,4F
000BE:  DATA 57,45
000C0:  DATA 52,20
000C2:  DATA 4F,4E
000C4:  DATA 21,0A
000C6:  DATA 00,00
000C8:  DATA 44,69
000CA:  DATA 67,69
000CC:  DATA 74,61
000CE:  DATA 6C,20
000D0:  DATA 70,69
000D2:  DATA 6E,20
000D4:  DATA 6F,75
000D6:  DATA 74,20
000D8:  DATA 63,6F
000DA:  DATA 6E,66
000DC:  DATA 69,67
000DE:  DATA 75,72
000E0:  DATA 65,64
000E2:  DATA 20,0A
000E4:  DATA 00,00
000E6:  DATA 0D,25
000E8:  DATA 30,32
000EA:  DATA 75,2F
000EC:  DATA 25,30
000EE:  DATA 32,75
000F0:  DATA 2F,32
000F2:  DATA 30,25
000F4:  DATA 30,32
000F6:  DATA 75,20
000F8:  DATA 25,30
000FA:  DATA 32,75
000FC:  DATA 3A,25
000FE:  DATA 30,32
00100:  DATA 75,3A
00102:  DATA 25,30
00104:  DATA 32,75
00106:  DATA 00,00
00108:  DATA 52,54
0010A:  DATA 43,43
0010C:  DATA 20,73
0010E:  DATA 65,74
00110:  DATA 75,70
00112:  DATA 20,66
00114:  DATA 69,6E
00116:  DATA 69,73
00118:  DATA 68,65
0011A:  DATA 64,21
0011C:  DATA 0A,00
0011E:  DATA 64,65
00120:  DATA 6C,65
00122:  DATA 74,69
00124:  DATA 6E,67
00126:  DATA 20,63
00128:  DATA 6F,6D
0012A:  DATA 6D,61
0012C:  DATA 6E,64
0012E:  DATA 20,61
00130:  DATA 64,64
00132:  DATA 72,65
00134:  DATA 73,73
00136:  DATA 20,6F
00138:  DATA 66,20
0013A:  DATA 74,68
0013C:  DATA 65,20
0013E:  DATA 61,64
00140:  DATA 63,73
00142:  DATA 0A,00
00144:  DATA 43,6F
00146:  DATA 6D,6D
00148:  DATA 61,6E
0014A:  DATA 64,20
0014C:  DATA 61,64
0014E:  DATA 64,72
00150:  DATA 65,73
00152:  DATA 73,20
00154:  DATA 6F,66
00156:  DATA 20,74
00158:  DATA 68,65
0015A:  DATA 20,61
0015C:  DATA 64,63
0015E:  DATA 73,20
00160:  DATA 69,73
00162:  DATA 20,64
00164:  DATA 65,6C
00166:  DATA 65,74
00168:  DATA 65,64
0016A:  DATA 21,0A
0016C:  DATA 00,00
0016E:  DATA 53,65
00170:  DATA 6E,64
00172:  DATA 69,6E
00174:  DATA 67,20
00176:  DATA 63,6F
00178:  DATA 6D,6D
0017A:  DATA 61,6E
0017C:  DATA 64,20
0017E:  DATA 74,6F
00180:  DATA 20,74
00182:  DATA 68,65
00184:  DATA 20,61
00186:  DATA 64,63
00188:  DATA 73,0A
0018A:  DATA 00,00
0018C:  DATA 53,74
0018E:  DATA 61,72
00190:  DATA 74,69
00192:  DATA 6E,67
00194:  DATA 20,74
00196:  DATA 6F,20
00198:  DATA 77,72
0019A:  DATA 69,74
0019C:  DATA 65,20
0019E:  DATA 64,61
001A0:  DATA 74,61
001A2:  DATA 20,69
001A4:  DATA 6E,20
001A6:  DATA 41,44
001A8:  DATA 43,53
001AA:  DATA 20,66
001AC:  DATA 6C,61
001AE:  DATA 73,68
001B0:  DATA 20,6D
001B2:  DATA 65,6D
001B4:  DATA 6F,72
001B6:  DATA 79,0A
001B8:  DATA 00,00
001BA:  DATA 41,44
001BC:  DATA 43,53
001BE:  DATA 20,63
001C0:  DATA 6F,6D
001C2:  DATA 6D,61
001C4:  DATA 6E,64
001C6:  DATA 20,69
001C8:  DATA 73,20
001CA:  DATA 77,72
001CC:  DATA 69,74
001CE:  DATA 74,65
001D0:  DATA 6E,21
001D2:  DATA 0A,00
001D4:  DATA 77,61
001D6:  DATA 69,74
001D8:  DATA 69,6E
001DA:  DATA 67,20
001DC:  DATA 66,6F
001DE:  DATA 72,20
001E0:  DATA 61,64
001E2:  DATA 63,73
001E4:  DATA 20,74
001E6:  DATA 6F,20
001E8:  DATA 66,69
001EA:  DATA 6E,69
001EC:  DATA 73,68
001EE:  DATA 20,37
001F0:  DATA 30,73
001F2:  DATA 2F,25
001F4:  DATA 64,30
001F6:  DATA 73,0A
001F8:  DATA 00,00
001FA:  DATA 41,44
001FC:  DATA 43,53
001FE:  DATA 20,63
00200:  DATA 6F,6D
00202:  DATA 6D,61
00204:  DATA 6E,64
00206:  DATA 20,69
00208:  DATA 73,20
0020A:  DATA 66,69
0020C:  DATA 6E,69
0020E:  DATA 73,68
00210:  DATA 65,64
00212:  DATA 21,0A
00214:  DATA 00,00
00216:  DATA 72,65
00218:  DATA 61,64
0021A:  DATA 69,6E
0021C:  DATA 67,20
0021E:  DATA 74,68
00220:  DATA 65,20
00222:  DATA 73,74
00224:  DATA 61,74
00226:  DATA 75,73
00228:  DATA 20,61
0022A:  DATA 64,64
0022C:  DATA 72,65
0022E:  DATA 73,73
00230:  DATA 20,6F
00232:  DATA 66,20
00234:  DATA 74,68
00236:  DATA 65,20
00238:  DATA 61,64
0023A:  DATA 63,73
0023C:  DATA 21,0A
0023E:  DATA 00,00
00240:  DATA 41,44
00242:  DATA 43,53
00244:  DATA 20,73
00246:  DATA 74,61
00248:  DATA 74,75
0024A:  DATA 73,3A
0024C:  DATA 20,25
0024E:  DATA 64,2C
00250:  DATA 20,6C
00252:  DATA 61,73
00254:  DATA 74,20
00256:  DATA 61,64
00258:  DATA 64,72
0025A:  DATA 65,73
0025C:  DATA 73,3A
0025E:  DATA 20,30
00260:  DATA 78,25
00262:  DATA 30,38
00264:  DATA 78,0A
00266:  DATA 00,00
00268:  DATA 41,44
0026A:  DATA 43,53
0026C:  DATA 20,6D
0026E:  DATA 69,73
00270:  DATA 73,69
00272:  DATA 6F,6E
00274:  DATA 20,66
00276:  DATA 61,69
00278:  DATA 6C,65
0027A:  DATA 64,21
0027C:  DATA 0A,00
0027E:  DATA 41,44
00280:  DATA 43,53
00282:  DATA 20,6D
00284:  DATA 69,73
00286:  DATA 73,69
00288:  DATA 6F,6E
0028A:  DATA 20,66
0028C:  DATA 61,69
0028E:  DATA 6C,65
00290:  DATA 64,21
00292:  DATA 0A,00
00294:  DATA 41,44
00296:  DATA 43,53
00298:  DATA 20,6D
0029A:  DATA 69,73
0029C:  DATA 73,69
0029E:  DATA 6F,6E
002A0:  DATA 20,73
002A2:  DATA 75,63
002A4:  DATA 63,65
002A6:  DATA 73,73
002A8:  DATA 20,77
002AA:  DATA 69,74
002AC:  DATA 68,20
002AE:  DATA 25,64
002B0:  DATA 20,6D
002B2:  DATA 65,61
002B4:  DATA 73,75
002B6:  DATA 72,65
002B8:  DATA 6D,65
002BA:  DATA 6E,74
002BC:  DATA 73,21
002BE:  DATA 0A,00
002C0:  DATA 46,69
002C2:  DATA 72,73
002C4:  DATA 74,20
002C6:  DATA 64,61
002C8:  DATA 74,61
002CA:  DATA 20,61
002CC:  DATA 64,64
002CE:  DATA 72,65
002D0:  DATA 73,73
002D2:  DATA 3A,20
002D4:  DATA 30,78
002D6:  DATA 25,30
002D8:  DATA 38,78
002DA:  DATA 0A,00
002DC:  DATA 4D,65
002DE:  DATA 61,73
002E0:  DATA 75,72
002E2:  DATA 65,6D
002E4:  DATA 65,6E
002E6:  DATA 74,20
002E8:  DATA 25,64
002EA:  DATA 20,61
002EC:  DATA 74,20
002EE:  DATA 61,64
002F0:  DATA 64,72
002F2:  DATA 65,73
002F4:  DATA 73,20
002F6:  DATA 30,78
002F8:  DATA 25,30
002FA:  DATA 38,78
002FC:  DATA 3A,20
002FE:  DATA 00,00
00300:  DATA 53,68
00302:  DATA 75,74
00304:  DATA 64,6F
00306:  DATA 77,6E
00308:  DATA 20,63
0030A:  DATA 6F,75
0030C:  DATA 6E,74
0030E:  DATA 20,73
00310:  DATA 74,61
00312:  DATA 72,74
00314:  DATA 65,64
00316:  DATA 0A,00
00318:  DATA 52,65
0031A:  DATA 61,64
0031C:  DATA 20,73
0031E:  DATA 68,75
00320:  DATA 74,64
00322:  DATA 6F,77
00324:  DATA 6E,20
00326:  DATA 63,6F
00328:  DATA 75,6E
0032A:  DATA 74,3A
0032C:  DATA 20,25
0032E:  DATA 75,0A
00330:  DATA 00,00
00332:  DATA 49,6E
00334:  DATA 63,72
00336:  DATA 65,6D
00338:  DATA 65,6E
0033A:  DATA 74,65
0033C:  DATA 64,20
0033E:  DATA 73,68
00340:  DATA 75,74
00342:  DATA 64,6F
00344:  DATA 77,6E
00346:  DATA 20,63
00348:  DATA 6F,75
0034A:  DATA 6E,74
0034C:  DATA 3A,20
0034E:  DATA 25,75
00350:  DATA 0A,00
00352:  DATA 4E,6F
00354:  DATA 77,20
00356:  DATA 73,68
00358:  DATA 75,74
0035A:  DATA 64,6F
0035C:  DATA 77,6E
0035E:  DATA 20,63
00360:  DATA 6F,75
00362:  DATA 6E,74
00364:  DATA 20,69
00366:  DATA 73,20
00368:  DATA 3A,20
0036A:  DATA 25,75
0036C:  DATA 0A,0A
0036E:  DATA 00,00
00370:  DATA 0A,45
00372:  DATA 6E,74
00374:  DATA 65,72
00376:  DATA 20,41
00378:  DATA 64,64
0037A:  DATA 72,65
0037C:  DATA 73,73
0037E:  DATA 20,28
00380:  DATA 68,65
00382:  DATA 78,2C
00384:  DATA 20,30
00386:  DATA 78,31
00388:  DATA 32,33
0038A:  DATA 34,29
0038C:  DATA 3A,20
0038E:  DATA 30,78
00390:  DATA 00,00
00392:  DATA 0A,45
00394:  DATA 6E,74
00396:  DATA 65,72
00398:  DATA 20,6E
0039A:  DATA 75,6D
0039C:  DATA 62,65
0039E:  DATA 72,20
003A0:  DATA 6F,66
003A2:  DATA 20,62
003A4:  DATA 79,74
003A6:  DATA 65,73
003A8:  DATA 20,74
003AA:  DATA 6F,20
003AC:  DATA 77,72
003AE:  DATA 69,74
003B0:  DATA 65,20
003B2:  DATA 28,6D
003B4:  DATA 61,78
003B6:  DATA 20,32
003B8:  DATA 35,36
003BA:  DATA 29,3A
003BC:  DATA 20,00
003BE:  DATA 45,6E
003C0:  DATA 74,65
003C2:  DATA 72,20
003C4:  DATA 25,64
003C6:  DATA 20,62
003C8:  DATA 79,74
003CA:  DATA 65,73
003CC:  DATA 20,6F
003CE:  DATA 66,20
003D0:  DATA 64,61
003D2:  DATA 74,61
003D4:  DATA 20,28
003D6:  DATA 69,6E
003D8:  DATA 20,68
003DA:  DATA 65,78
003DC:  DATA 29,3A
003DE:  DATA 0A,00
003E0:  DATA 42,79
003E2:  DATA 74,65
003E4:  DATA 20,25
003E6:  DATA 64,3A
003E8:  DATA 20,30
003EA:  DATA 78,00
003EC:  DATA 0A,44
003EE:  DATA 61,74
003F0:  DATA 61,20
003F2:  DATA 73,75
003F4:  DATA 63,63
003F6:  DATA 65,73
003F8:  DATA 73,66
003FA:  DATA 75,6C
003FC:  DATA 6C,79
003FE:  DATA 20,77
00400:  DATA 72,69
00402:  DATA 74,74
00404:  DATA 65,6E
00406:  DATA 2E,0A
00408:  DATA 00,00
0040A:  DATA 4D,41
0040C:  DATA 49,4E
0040E:  DATA 20,66
00410:  DATA 6C,61
00412:  DATA 73,68
00414:  DATA 20,6D
00416:  DATA 65,6D
00418:  DATA 6F,72
0041A:  DATA 79,20
0041C:  DATA 63,68
0041E:  DATA 6F,73
00420:  DATA 65,6E
00422:  DATA 0A,00
00424:  DATA 70,72
00426:  DATA 65,73
00428:  DATA 73,20
0042A:  DATA 61,3A
0042C:  DATA 20,52
0042E:  DATA 65,61
00430:  DATA 64,20
00432:  DATA 49,44
00434:  DATA 20,6F
00436:  DATA 66,20
00438:  DATA 74,68
0043A:  DATA 65,20
0043C:  DATA 63,68
0043E:  DATA 69,70
00440:  DATA 0A,00
00442:  DATA 70,72
00444:  DATA 65,73
00446:  DATA 73,20
00448:  DATA 62,3A
0044A:  DATA 20,57
0044C:  DATA 72,69
0044E:  DATA 74,65
00450:  DATA 20,64
00452:  DATA 61,74
00454:  DATA 61,20
00456:  DATA 73,65
00458:  DATA 74,20
0045A:  DATA 69,6E
0045C:  DATA 20,73
0045E:  DATA 70,65
00460:  DATA 63,69
00462:  DATA 66,69
00464:  DATA 65,64
00466:  DATA 20,61
00468:  DATA 64,64
0046A:  DATA 72,65
0046C:  DATA 73,73
0046E:  DATA 0A,00
00470:  DATA 70,72
00472:  DATA 65,73
00474:  DATA 73,20
00476:  DATA 63,3A
00478:  DATA 20,52
0047A:  DATA 65,61
0047C:  DATA 64,20
0047E:  DATA 64,61
00480:  DATA 74,61
00482:  DATA 20,73
00484:  DATA 65,74
00486:  DATA 20,69
00488:  DATA 6E,20
0048A:  DATA 73,70
0048C:  DATA 65,63
0048E:  DATA 69,66
00490:  DATA 69,65
00492:  DATA 64,20
00494:  DATA 61,64
00496:  DATA 64,72
00498:  DATA 65,73
0049A:  DATA 73,0A
0049C:  DATA 00,00
0049E:  DATA 70,72
004A0:  DATA 65,73
004A2:  DATA 73,20
004A4:  DATA 78,3A
004A6:  DATA 20,52
004A8:  DATA 65,74
004AA:  DATA 75,72
004AC:  DATA 6E,20
004AE:  DATA 74,6F
004B0:  DATA 20,4D
004B2:  DATA 41,49
004B4:  DATA 4E,20
004B6:  DATA 4D,45
004B8:  DATA 4E,55
004BA:  DATA 0A,00
004BC:  DATA 53,74
004BE:  DATA 61,72
004C0:  DATA 74,65
004C2:  DATA 64,20
004C4:  DATA 72,65
004C6:  DATA 61,64
004C8:  DATA 69,6E
004CA:  DATA 67,20
004CC:  DATA 63,68
004CE:  DATA 69,70
004D0:  DATA 20,49
004D2:  DATA 44,20
004D4:  DATA 6F,66
004D6:  DATA 20,4D
004D8:  DATA 41,49
004DA:  DATA 4E,20
004DC:  DATA 66,6C
004DE:  DATA 61,73
004E0:  DATA 68,20
004E2:  DATA 6D,65
004E4:  DATA 6D,6F
004E6:  DATA 72,79
004E8:  DATA 0A,00
004EA:  DATA 52,65
004EC:  DATA 61,64
004EE:  DATA 20,64
004F0:  DATA 61,74
004F2:  DATA 61,20
004F4:  DATA 73,65
004F6:  DATA 74,20
004F8:  DATA 69,6E
004FA:  DATA 20,73
004FC:  DATA 70,65
004FE:  DATA 63,69
00500:  DATA 66,69
00502:  DATA 65,64
00504:  DATA 20,61
00506:  DATA 64,64
00508:  DATA 72,65
0050A:  DATA 73,73
0050C:  DATA 0A,00
0050E:  DATA 45,6E
00510:  DATA 74,65
00512:  DATA 72,20
00514:  DATA 79,6F
00516:  DATA 75,72
00518:  DATA 20,73
0051A:  DATA 70,65
0051C:  DATA 63,69
0051E:  DATA 66,69
00520:  DATA 65,64
00522:  DATA 20,61
00524:  DATA 64,64
00526:  DATA 72,65
00528:  DATA 73,73
0052A:  DATA 20,61
0052C:  DATA 6E,64
0052E:  DATA 20,6C
00530:  DATA 65,6E
00532:  DATA 67,74
00534:  DATA 68,20
00536:  DATA 28,65
00538:  DATA 2E,67
0053A:  DATA 2E,2C
0053C:  DATA 20,30
0053E:  DATA 78,31
00540:  DATA 32,33
00542:  DATA 34,20
00544:  DATA 31,30
00546:  DATA 29,3A
00548:  DATA 20,00
0054A:  DATA 41,64
0054C:  DATA 64,72
0054E:  DATA 65,73
00550:  DATA 73,3A
00552:  DATA 20,30
00554:  DATA 78,25
00556:  DATA 30,39
00558:  DATA 78,2C
0055A:  DATA 20,4C
0055C:  DATA 65,6E
0055E:  DATA 67,74
00560:  DATA 68,3A
00562:  DATA 20,25
00564:  DATA 64,0A
00566:  DATA 00,00
00568:  DATA 49,6E
0056A:  DATA 76,61
0056C:  DATA 6C,69
0056E:  DATA 64,20
00570:  DATA 69,6E
00572:  DATA 70,75
00574:  DATA 74,2E
00576:  DATA 20,50
00578:  DATA 6C,65
0057A:  DATA 61,73
0057C:  DATA 65,20
0057E:  DATA 65,6E
00580:  DATA 74,65
00582:  DATA 72,20
00584:  DATA 61,20
00586:  DATA 76,61
00588:  DATA 6C,69
0058A:  DATA 64,20
0058C:  DATA 61,64
0058E:  DATA 64,72
00590:  DATA 65,73
00592:  DATA 73,20
00594:  DATA 61,6E
00596:  DATA 64,20
00598:  DATA 6C,65
0059A:  DATA 6E,67
0059C:  DATA 74,68
0059E:  DATA 2E,0A
005A0:  DATA 00,00
005A2:  DATA 49,6E
005A4:  DATA 76,61
005A6:  DATA 6C,69
005A8:  DATA 64,20
005AA:  DATA 4D,41
005AC:  DATA 49,4E
005AE:  DATA 20,66
005B0:  DATA 6C,61
005B2:  DATA 73,68
005B4:  DATA 20,6D
005B6:  DATA 65,6D
005B8:  DATA 6F,72
005BA:  DATA 79,20
005BC:  DATA 6F,70
005BE:  DATA 74,69
005C0:  DATA 6F,6E
005C2:  DATA 2E,20
005C4:  DATA 50,6C
005C6:  DATA 65,61
005C8:  DATA 73,65
005CA:  DATA 20,74
005CC:  DATA 72,79
005CE:  DATA 20,61
005D0:  DATA 67,61
005D2:  DATA 69,6E
005D4:  DATA 2E,0A
005D6:  DATA 00,00
005D8:  DATA 70,72
005DA:  DATA 65,73
005DC:  DATA 73,65
005DE:  DATA 64,20
005E0:  DATA 6F,70
005E2:  DATA 74,69
005E4:  DATA 6F,6E
005E6:  DATA 20,64
005E8:  DATA 3A,20
005EA:  DATA 43,68
005EC:  DATA 65,63
005EE:  DATA 6B,20
005F0:  DATA 46,6C
005F2:  DATA 61,73
005F4:  DATA 68,20
005F6:  DATA 4D,65
005F8:  DATA 6D,6F
005FA:  DATA 72,69
005FC:  DATA 65,73
005FE:  DATA 0A,0A
00600:  DATA 00,00
00602:  DATA 50,6C
00604:  DATA 65,61
00606:  DATA 73,65
00608:  DATA 20,63
0060A:  DATA 68,6F
0060C:  DATA 6F,73
0060E:  DATA 65,20
00610:  DATA 77,68
00612:  DATA 69,63
00614:  DATA 68,20
00616:  DATA 66,6C
00618:  DATA 61,73
0061A:  DATA 68,20
0061C:  DATA 6D,65
0061E:  DATA 6D,6F
00620:  DATA 72,79
00622:  DATA 20,74
00624:  DATA 6F,20
00626:  DATA 77,6F
00628:  DATA 72,6B
0062A:  DATA 20,6F
0062C:  DATA 6E,20
0062E:  DATA 28,61
00630:  DATA 2C,20
00632:  DATA 62,2C
00634:  DATA 20,63
00636:  DATA 2C,20
00638:  DATA 64,2C
0063A:  DATA 20,65
0063C:  DATA 29,3A
0063E:  DATA 0A,00
00640:  DATA 70,72
00642:  DATA 65,73
00644:  DATA 73,20
00646:  DATA 61,3A
00648:  DATA 20,4D
0064A:  DATA 41,49
0064C:  DATA 4E,20
0064E:  DATA 66,6C
00650:  DATA 61,73
00652:  DATA 68,20
00654:  DATA 6D,65
00656:  DATA 6D,6F
00658:  DATA 72,79
0065A:  DATA 0A,00
0065C:  DATA 70,72
0065E:  DATA 65,73
00660:  DATA 73,20
00662:  DATA 62,3A
00664:  DATA 20,43
00666:  DATA 4F,4D
00668:  DATA 20,73
0066A:  DATA 68,61
0066C:  DATA 72,65
0066E:  DATA 64,20
00670:  DATA 66,6C
00672:  DATA 61,73
00674:  DATA 68,20
00676:  DATA 6D,65
00678:  DATA 6D,6F
0067A:  DATA 72,79
0067C:  DATA 0A,00
0067E:  DATA 70,72
00680:  DATA 65,73
00682:  DATA 73,20
00684:  DATA 63,3A
00686:  DATA 20,41
00688:  DATA 44,43
0068A:  DATA 53,20
0068C:  DATA 73,68
0068E:  DATA 61,72
00690:  DATA 65,64
00692:  DATA 20,66
00694:  DATA 6C,61
00696:  DATA 73,68
00698:  DATA 20,6D
0069A:  DATA 65,6D
0069C:  DATA 6F,72
0069E:  DATA 79,0A
006A0:  DATA 00,00
006A2:  DATA 70,72
006A4:  DATA 65,73
006A6:  DATA 73,20
006A8:  DATA 64,3A
006AA:  DATA 20,4F
006AC:  DATA 56,43
006AE:  DATA 41,4D
006B0:  DATA 20,73
006B2:  DATA 68,61
006B4:  DATA 72,65
006B6:  DATA 64,20
006B8:  DATA 66,6C
006BA:  DATA 61,73
006BC:  DATA 68,20
006BE:  DATA 6D,65
006C0:  DATA 6D,6F
006C2:  DATA 72,79
006C4:  DATA 0A,00
006C6:  DATA 70,72
006C8:  DATA 65,73
006CA:  DATA 73,20
006CC:  DATA 65,3A
006CE:  DATA 20,4D
006D0:  DATA 56,43
006D2:  DATA 41,4D
006D4:  DATA 20,73
006D6:  DATA 68,61
006D8:  DATA 72,65
006DA:  DATA 64,20
006DC:  DATA 66,6C
006DE:  DATA 61,73
006E0:  DATA 68,20
006E2:  DATA 6D,65
006E4:  DATA 6D,6F
006E6:  DATA 72,79
006E8:  DATA 0A,00
006EA:  DATA 70,72
006EC:  DATA 65,73
006EE:  DATA 73,20
006F0:  DATA 78,3A
006F2:  DATA 20,52
006F4:  DATA 65,74
006F6:  DATA 75,72
006F8:  DATA 6E,20
006FA:  DATA 74,6F
006FC:  DATA 20,4D
006FE:  DATA 41,49
00700:  DATA 4E,20
00702:  DATA 4D,45
00704:  DATA 4E,55
00706:  DATA 0A,00
00708:  DATA 4D,41
0070A:  DATA 49,4E
0070C:  DATA 20,73
0070E:  DATA 68,61
00710:  DATA 72,65
00712:  DATA 64,20
00714:  DATA 66,6C
00716:  DATA 61,73
00718:  DATA 68,20
0071A:  DATA 6D,65
0071C:  DATA 6D,6F
0071E:  DATA 72,79
00720:  DATA 20,63
00722:  DATA 68,6F
00724:  DATA 73,65
00726:  DATA 6E,0A
00728:  DATA 00,00
0072A:  DATA 43,4F
0072C:  DATA 4D,20
0072E:  DATA 73,68
00730:  DATA 61,72
00732:  DATA 65,64
00734:  DATA 20,66
00736:  DATA 6C,61
00738:  DATA 73,68
0073A:  DATA 20,6D
0073C:  DATA 65,6D
0073E:  DATA 6F,72
00740:  DATA 79,20
00742:  DATA 63,68
00744:  DATA 6F,73
00746:  DATA 65,6E
00748:  DATA 0A,00
0074A:  DATA 41,44
0074C:  DATA 43,53
0074E:  DATA 20,73
00750:  DATA 68,61
00752:  DATA 72,65
00754:  DATA 64,20
00756:  DATA 66,6C
00758:  DATA 61,73
0075A:  DATA 68,20
0075C:  DATA 6D,65
0075E:  DATA 6D,6F
00760:  DATA 72,79
00762:  DATA 20,63
00764:  DATA 68,6F
00766:  DATA 73,65
00768:  DATA 6E,0A
0076A:  DATA 00,00
0076C:  DATA 4F,56
0076E:  DATA 43,41
00770:  DATA 4D,20
00772:  DATA 73,68
00774:  DATA 61,72
00776:  DATA 65,64
00778:  DATA 20,66
0077A:  DATA 6C,61
0077C:  DATA 73,68
0077E:  DATA 20,6D
00780:  DATA 65,6D
00782:  DATA 6F,72
00784:  DATA 79,20
00786:  DATA 63,68
00788:  DATA 6F,73
0078A:  DATA 65,6E
0078C:  DATA 0A,00
0078E:  DATA 4D,56
00790:  DATA 43,41
00792:  DATA 4D,20
00794:  DATA 73,68
00796:  DATA 61,72
00798:  DATA 65,64
0079A:  DATA 20,66
0079C:  DATA 6C,61
0079E:  DATA 73,68
007A0:  DATA 20,6D
007A2:  DATA 65,6D
007A4:  DATA 6F,72
007A6:  DATA 79,20
007A8:  DATA 63,68
007AA:  DATA 6F,73
007AC:  DATA 65,6E
007AE:  DATA 0A,00
007B0:  DATA 49,6E
007B2:  DATA 76,61
007B4:  DATA 6C,69
007B6:  DATA 64,20
007B8:  DATA 66,6C
007BA:  DATA 61,73
007BC:  DATA 68,20
007BE:  DATA 6D,65
007C0:  DATA 6D,6F
007C2:  DATA 72,79
007C4:  DATA 20,6F
007C6:  DATA 70,74
007C8:  DATA 69,6F
007CA:  DATA 6E,2E
007CC:  DATA 20,50
007CE:  DATA 6C,65
007D0:  DATA 61,73
007D2:  DATA 65,20
007D4:  DATA 74,72
007D6:  DATA 79,20
007D8:  DATA 61,67
007DA:  DATA 61,69
007DC:  DATA 6E,2E
007DE:  DATA 0A,00
007E0:  DATA 53,65
007E2:  DATA 74,74
007E4:  DATA 69,6E
007E6:  DATA 67,73
007E8:  DATA 20,6F
007EA:  DATA 66,20
007EC:  DATA 52,54
007EE:  DATA 43,20
007F0:  DATA 63,68
007F2:  DATA 6F,73
007F4:  DATA 65,6E
007F6:  DATA 0A,00
007F8:  DATA 20,20
007FA:  DATA 20,20
007FC:  DATA 70,72
007FE:  DATA 65,73
00800:  DATA 73,20
00802:  DATA 61,3A
00804:  DATA 20,74
00806:  DATA 6F,20
00808:  DATA 72,65
0080A:  DATA 73,65
0080C:  DATA 74,20
0080E:  DATA 74,68
00810:  DATA 65,20
00812:  DATA 52,54
00814:  DATA 43,20
00816:  DATA 2F,61
00818:  DATA 6C,6C
0081A:  DATA 20,63
0081C:  DATA 75,72
0081E:  DATA 72,65
00820:  DATA 6E,74
00822:  DATA 20,74
00824:  DATA 69,6D
00826:  DATA 65,20
00828:  DATA 77,69
0082A:  DATA 6C,6C
0082C:  DATA 20,62
0082E:  DATA 65,20
00830:  DATA 73,65
00832:  DATA 74,20
00834:  DATA 7A,65
00836:  DATA 72,6F
00838:  DATA 2F,0A
0083A:  DATA 00,00
0083C:  DATA 20,20
0083E:  DATA 20,20
00840:  DATA 70,72
00842:  DATA 65,73
00844:  DATA 73,20
00846:  DATA 62,3A
00848:  DATA 20,64
0084A:  DATA 69,73
0084C:  DATA 70,6C
0084E:  DATA 61,79
00850:  DATA 20,63
00852:  DATA 75,72
00854:  DATA 72,65
00856:  DATA 6E,74
00858:  DATA 20,74
0085A:  DATA 69,6D
0085C:  DATA 65,0A
0085E:  DATA 00,00
00860:  DATA 20,20
00862:  DATA 20,20
00864:  DATA 70,72
00866:  DATA 65,73
00868:  DATA 73,20
0086A:  DATA 63,3A
0086C:  DATA 20,64
0086E:  DATA 69,73
00870:  DATA 70,6C
00872:  DATA 61,79
00874:  DATA 20,63
00876:  DATA 75,72
00878:  DATA 72,65
0087A:  DATA 6E,74
0087C:  DATA 20,74
0087E:  DATA 69,6D
00880:  DATA 65,20
00882:  DATA 6E,6F
00884:  DATA 6E,73
00886:  DATA 74,6F
00888:  DATA 70,0A
0088A:  DATA 00,00
0088C:  DATA 4E,6F
0088E:  DATA 77,20
00890:  DATA 74,69
00892:  DATA 6D,65
00894:  DATA 20,69
00896:  DATA 73,0A
00898:  DATA 00,00
0089A:  DATA 0D,25
0089C:  DATA 30,32
0089E:  DATA 75,2F
008A0:  DATA 25,30
008A2:  DATA 32,75
008A4:  DATA 2F,32
008A6:  DATA 30,25
008A8:  DATA 30,32
008AA:  DATA 75,20
008AC:  DATA 25,30
008AE:  DATA 32,75
008B0:  DATA 3A,25
008B2:  DATA 30,32
008B4:  DATA 75,3A
008B6:  DATA 25,30
008B8:  DATA 32,75
008BA:  DATA 00,00
008BC:  DATA 54,69
008BE:  DATA 6D,65
008C0:  DATA 20,63
008C2:  DATA 68,61
008C4:  DATA 6E,67
008C6:  DATA 69,6E
008C8:  DATA 67,20
008CA:  DATA 66,75
008CC:  DATA 6E,63
008CE:  DATA 74,69
008D0:  DATA 6F,6E
008D2:  DATA 20,61
008D4:  DATA 63,74
008D6:  DATA 69,76
008D8:  DATA 61,74
008DA:  DATA 65,64
008DC:  DATA 0A,00
008DE:  DATA 54,69
008E0:  DATA 6D,65
008E2:  DATA 20,73
008E4:  DATA 75,63
008E6:  DATA 63,65
008E8:  DATA 73,73
008EA:  DATA 66,75
008EC:  DATA 6C,6C
008EE:  DATA 79,20
008F0:  DATA 63,68
008F2:  DATA 61,6E
008F4:  DATA 67,65
008F6:  DATA 64,2E
008F8:  DATA 20,43
008FA:  DATA 75,72
008FC:  DATA 72,65
008FE:  DATA 6E,74
00900:  DATA 20,74
00902:  DATA 69,6D
00904:  DATA 65,20
00906:  DATA 69,73
00908:  DATA 3A,0A
0090A:  DATA 00,00
0090C:  DATA 0D,25
0090E:  DATA 30,32
00910:  DATA 75,2F
00912:  DATA 25,30
00914:  DATA 32,75
00916:  DATA 2F,32
00918:  DATA 30,25
0091A:  DATA 30,32
0091C:  DATA 75,20
0091E:  DATA 25,30
00920:  DATA 32,75
00922:  DATA 3A,25
00924:  DATA 30,32
00926:  DATA 75,3A
00928:  DATA 25,30
0092A:  DATA 32,75
0092C:  DATA 00,00
0092E:  DATA 0D,25
00930:  DATA 30,32
00932:  DATA 75,2F
00934:  DATA 25,30
00936:  DATA 32,75
00938:  DATA 2F,32
0093A:  DATA 30,25
0093C:  DATA 30,32
0093E:  DATA 75,20
00940:  DATA 25,30
00942:  DATA 32,75
00944:  DATA 3A,25
00946:  DATA 30,32
00948:  DATA 75,3A
0094A:  DATA 25,30
0094C:  DATA 32,75
0094E:  DATA 00,00
00950:  DATA 4E,6F
00952:  DATA 77,20
00954:  DATA 74,69
00956:  DATA 6D,65
00958:  DATA 20,69
0095A:  DATA 73,0A
0095C:  DATA 00,00
0095E:  DATA 0D,25
00960:  DATA 30,32
00962:  DATA 75,2F
00964:  DATA 25,30
00966:  DATA 32,75
00968:  DATA 2F,32
0096A:  DATA 30,25
0096C:  DATA 30,32
0096E:  DATA 75,20
00970:  DATA 25,30
00972:  DATA 32,75
00974:  DATA 3A,25
00976:  DATA 30,32
00978:  DATA 75,3A
0097A:  DATA 25,30
0097C:  DATA 32,75
0097E:  DATA 0A,00
00980:  DATA 49,6E
00982:  DATA 76,61
00984:  DATA 6C,69
00986:  DATA 64,20
00988:  DATA 49,4F
0098A:  DATA 20,6F
0098C:  DATA 70,74
0098E:  DATA 69,6F
00990:  DATA 6E,2E
00992:  DATA 20,50
00994:  DATA 6C,65
00996:  DATA 61,73
00998:  DATA 65,20
0099A:  DATA 74,72
0099C:  DATA 79,20
0099E:  DATA 61,67
009A0:  DATA 61,69
009A2:  DATA 6E,2E
009A4:  DATA 0A,00
009A6:  DATA 49,4F
009A8:  DATA 20,63
009AA:  DATA 6F,6E
009AC:  DATA 74,72
009AE:  DATA 6F,6C
009B0:  DATA 20,63
009B2:  DATA 68,6F
009B4:  DATA 73,65
009B6:  DATA 6E,0A
009B8:  DATA 00,00
009BA:  DATA 20,20
009BC:  DATA 20,20
009BE:  DATA 70,72
009C0:  DATA 65,73
009C2:  DATA 73,20
009C4:  DATA 61,3A
009C6:  DATA 20,54
009C8:  DATA 6F,67
009CA:  DATA 67,6C
009CC:  DATA 65,20
009CE:  DATA 45,4E
009D0:  DATA 5F,53
009D2:  DATA 55,50
009D4:  DATA 5F,33
009D6:  DATA 56,33
009D8:  DATA 5F,31
009DA:  DATA 20,2F
009DC:  DATA 69,73
009DE:  DATA 20,63
009E0:  DATA 75,72
009E2:  DATA 72,65
009E4:  DATA 6E,74
009E6:  DATA 6C,79
009E8:  DATA 2F,00
009EA:  DATA 48,49
009EC:  DATA 47,48
009EE:  DATA 0A,00
009F0:  DATA 4C,4F
009F2:  DATA 57,0A
009F4:  DATA 00,00
009F6:  DATA 49,6E
009F8:  DATA 76,61
009FA:  DATA 6C,69
009FC:  DATA 64,0A
009FE:  DATA 00,00
00A00:  DATA 20,20
00A02:  DATA 20,20
00A04:  DATA 70,72
00A06:  DATA 65,73
00A08:  DATA 73,20
00A0A:  DATA 62,3A
00A0C:  DATA 20,54
00A0E:  DATA 6F,67
00A10:  DATA 67,6C
00A12:  DATA 65,20
00A14:  DATA 45,4E
00A16:  DATA 5F,53
00A18:  DATA 55,50
00A1A:  DATA 5F,33
00A1C:  DATA 56,33
00A1E:  DATA 5F,32
00A20:  DATA 20,2F
00A22:  DATA 69,73
00A24:  DATA 20,63
00A26:  DATA 75,72
00A28:  DATA 72,65
00A2A:  DATA 6E,74
00A2C:  DATA 6C,79
00A2E:  DATA 2F,00
00A30:  DATA 48,49
00A32:  DATA 47,48
00A34:  DATA 0A,00
00A36:  DATA 4C,4F
00A38:  DATA 57,0A
00A3A:  DATA 00,00
00A3C:  DATA 49,6E
00A3E:  DATA 76,61
00A40:  DATA 6C,69
00A42:  DATA 64,0A
00A44:  DATA 00,00
00A46:  DATA 20,20
00A48:  DATA 20,20
00A4A:  DATA 70,72
00A4C:  DATA 65,73
00A4E:  DATA 73,20
00A50:  DATA 63,3A
00A52:  DATA 20,54
00A54:  DATA 6F,67
00A56:  DATA 67,6C
00A58:  DATA 65,20
00A5A:  DATA 45,4E
00A5C:  DATA 5F,53
00A5E:  DATA 55,50
00A60:  DATA 5F,33
00A62:  DATA 56,33
00A64:  DATA 5F,44
00A66:  DATA 41,51
00A68:  DATA 20,2F
00A6A:  DATA 69,73
00A6C:  DATA 20,63
00A6E:  DATA 75,72
00A70:  DATA 72,65
00A72:  DATA 6E,74
00A74:  DATA 6C,79
00A76:  DATA 2F,00
00A78:  DATA 48,49
00A7A:  DATA 47,48
00A7C:  DATA 0A,00
00A7E:  DATA 4C,4F
00A80:  DATA 57,0A
00A82:  DATA 00,00
00A84:  DATA 49,6E
00A86:  DATA 76,61
00A88:  DATA 6C,69
00A8A:  DATA 64,0A
00A8C:  DATA 00,00
00A8E:  DATA 20,20
00A90:  DATA 20,20
00A92:  DATA 70,72
00A94:  DATA 65,73
00A96:  DATA 73,20
00A98:  DATA 64,3A
00A9A:  DATA 20,54
00A9C:  DATA 6F,67
00A9E:  DATA 67,6C
00AA0:  DATA 65,20
00AA2:  DATA 45,4E
00AA4:  DATA 5F,53
00AA6:  DATA 55,50
00AA8:  DATA 5F,55
00AAA:  DATA 4E,52
00AAC:  DATA 45,47
00AAE:  DATA 20,2F
00AB0:  DATA 69,73
00AB2:  DATA 20,63
00AB4:  DATA 75,72
00AB6:  DATA 72,65
00AB8:  DATA 6E,74
00ABA:  DATA 6C,79
00ABC:  DATA 2F,00
00ABE:  DATA 48,49
00AC0:  DATA 47,48
00AC2:  DATA 0A,00
00AC4:  DATA 4C,4F
00AC6:  DATA 57,0A
00AC8:  DATA 00,00
00ACA:  DATA 49,6E
00ACC:  DATA 76,61
00ACE:  DATA 6C,69
00AD0:  DATA 64,0A
00AD2:  DATA 00,00
00AD4:  DATA 20,20
00AD6:  DATA 20,20
00AD8:  DATA 70,72
00ADA:  DATA 65,73
00ADC:  DATA 73,20
00ADE:  DATA 65,3A
00AE0:  DATA 20,54
00AE2:  DATA 6F,67
00AE4:  DATA 67,6C
00AE6:  DATA 65,20
00AE8:  DATA 45,4E
00AEA:  DATA 5F,53
00AEC:  DATA 55,50
00AEE:  DATA 5F,35
00AF0:  DATA 56,30
00AF2:  DATA 20,2F
00AF4:  DATA 69,73
00AF6:  DATA 20,63
00AF8:  DATA 75,72
00AFA:  DATA 72,65
00AFC:  DATA 6E,74
00AFE:  DATA 6C,79
00B00:  DATA 2F,00
00B02:  DATA 48,49
00B04:  DATA 47,48
00B06:  DATA 0A,00
00B08:  DATA 4C,4F
00B0A:  DATA 57,0A
00B0C:  DATA 00,00
00B0E:  DATA 49,6E
00B10:  DATA 76,61
00B12:  DATA 6C,69
00B14:  DATA 64,0A
00B16:  DATA 00,00
00B18:  DATA 20,20
00B1A:  DATA 20,20
00B1C:  DATA 70,72
00B1E:  DATA 65,73
00B20:  DATA 73,20
00B22:  DATA 66,3A
00B24:  DATA 20,54
00B26:  DATA 6F,67
00B28:  DATA 67,6C
00B2A:  DATA 65,20
00B2C:  DATA 4B,49
00B2E:  DATA 4C,4C
00B30:  DATA 5F,53
00B32:  DATA 57,49
00B34:  DATA 54,43
00B36:  DATA 48,20
00B38:  DATA 2F,69
00B3A:  DATA 73,20
00B3C:  DATA 63,75
00B3E:  DATA 72,72
00B40:  DATA 65,6E
00B42:  DATA 74,6C
00B44:  DATA 79,2F
00B46:  DATA 00,00
00B48:  DATA 48,49
00B4A:  DATA 47,48
00B4C:  DATA 0A,00
00B4E:  DATA 4C,4F
00B50:  DATA 57,0A
00B52:  DATA 00,00
00B54:  DATA 49,6E
00B56:  DATA 76,61
00B58:  DATA 6C,69
00B5A:  DATA 64,0A
00B5C:  DATA 00,00
00B5E:  DATA 20,20
00B60:  DATA 20,20
00B62:  DATA 70,72
00B64:  DATA 65,73
00B66:  DATA 73,20
00B68:  DATA 67,3A
00B6A:  DATA 20,54
00B6C:  DATA 6F,67
00B6E:  DATA 67,6C
00B70:  DATA 65,20
00B72:  DATA 4D,56
00B74:  DATA 43,41
00B76:  DATA 4D,5F
00B78:  DATA 50,57
00B7A:  DATA 52,20
00B7C:  DATA 2F,69
00B7E:  DATA 73,20
00B80:  DATA 63,75
00B82:  DATA 72,72
00B84:  DATA 65,6E
00B86:  DATA 74,6C
00B88:  DATA 79,2F
00B8A:  DATA 00,00
00B8C:  DATA 48,49
00B8E:  DATA 47,48
00B90:  DATA 0A,00
00B92:  DATA 4C,4F
00B94:  DATA 57,0A
00B96:  DATA 00,00
00B98:  DATA 49,6E
00B9A:  DATA 76,61
00B9C:  DATA 6C,69
00B9E:  DATA 64,0A
00BA0:  DATA 00,00
00BA2:  DATA 20,20
00BA4:  DATA 20,20
00BA6:  DATA 70,72
00BA8:  DATA 65,73
00BAA:  DATA 73,20
00BAC:  DATA 68,3A
00BAE:  DATA 20,54
00BB0:  DATA 6F,67
00BB2:  DATA 67,6C
00BB4:  DATA 65,20
00BB6:  DATA 4F,56
00BB8:  DATA 43,41
00BBA:  DATA 4D,5F
00BBC:  DATA 50,57
00BBE:  DATA 52,20
00BC0:  DATA 2F,69
00BC2:  DATA 73,20
00BC4:  DATA 63,75
00BC6:  DATA 72,72
00BC8:  DATA 65,6E
00BCA:  DATA 74,6C
00BCC:  DATA 79,2F
00BCE:  DATA 00,00
00BD0:  DATA 48,49
00BD2:  DATA 47,48
00BD4:  DATA 0A,00
00BD6:  DATA 4C,4F
00BD8:  DATA 57,0A
00BDA:  DATA 00,00
00BDC:  DATA 49,6E
00BDE:  DATA 76,61
00BE0:  DATA 6C,69
00BE2:  DATA 64,0A
00BE4:  DATA 00,00
00BE6:  DATA 20,20
00BE8:  DATA 20,20
00BEA:  DATA 70,72
00BEC:  DATA 65,73
00BEE:  DATA 73,20
00BF0:  DATA 69,3A
00BF2:  DATA 20,54
00BF4:  DATA 6F,67
00BF6:  DATA 67,6C
00BF8:  DATA 65,20
00BFA:  DATA 41,44
00BFC:  DATA 43,53
00BFE:  DATA 5F,50
00C00:  DATA 57,52
00C02:  DATA 20,2F
00C04:  DATA 69,73
00C06:  DATA 20,63
00C08:  DATA 75,72
00C0A:  DATA 72,65
00C0C:  DATA 6E,74
00C0E:  DATA 6C,79
00C10:  DATA 2F,00
00C12:  DATA 48,49
00C14:  DATA 47,48
00C16:  DATA 0A,00
00C18:  DATA 4C,4F
00C1A:  DATA 57,0A
00C1C:  DATA 00,00
00C1E:  DATA 49,6E
00C20:  DATA 76,61
00C22:  DATA 6C,69
00C24:  DATA 64,0A
00C26:  DATA 00,00
00C28:  DATA 20,20
00C2A:  DATA 20,20
00C2C:  DATA 70,72
00C2E:  DATA 65,73
00C30:  DATA 73,20
00C32:  DATA 6A,3A
00C34:  DATA 20,54
00C36:  DATA 6F,67
00C38:  DATA 67,6C
00C3A:  DATA 65,20
00C3C:  DATA 61,6C
00C3E:  DATA 6C,20
00C40:  DATA 50,69
00C42:  DATA 6E,73
00C44:  DATA 00,00
00C46:  DATA 49,6E
00C48:  DATA 76,61
00C4A:  DATA 6C,69
00C4C:  DATA 64,20
00C4E:  DATA 49,4F
00C50:  DATA 20,6F
00C52:  DATA 70,74
00C54:  DATA 69,6F
00C56:  DATA 6E,2E
00C58:  DATA 20,50
00C5A:  DATA 6C,65
00C5C:  DATA 61,73
00C5E:  DATA 65,20
00C60:  DATA 74,72
00C62:  DATA 79,20
00C64:  DATA 61,67
00C66:  DATA 61,69
00C68:  DATA 6E,2E
00C6A:  DATA 0A,00
00C6C:  DATA 20,20
00C6E:  DATA 20,20
00C70:  DATA 70,72
00C72:  DATA 65,73
00C74:  DATA 73,20
00C76:  DATA 61,3A
00C78:  DATA 20,41
00C7A:  DATA 44,43
00C7C:  DATA 53,20
00C7E:  DATA 6D,69
00C80:  DATA 73,73
00C82:  DATA 69,6F
00C84:  DATA 6E,20
00C86:  DATA 6D,6F
00C88:  DATA 64,65
00C8A:  DATA 0A,00
00C8C:  DATA 20,20
00C8E:  DATA 20,20
00C90:  DATA 70,72
00C92:  DATA 65,73
00C94:  DATA 73,20
00C96:  DATA 62,3A
00C98:  DATA 20,45
00C9A:  DATA 50,53
00C9C:  DATA 20,6D
00C9E:  DATA 69,73
00CA0:  DATA 73,69
00CA2:  DATA 6F,6E
00CA4:  DATA 20,6D
00CA6:  DATA 6F,64
00CA8:  DATA 65,0A
00CAA:  DATA 00,00
00CAC:  DATA 20,20
00CAE:  DATA 20,20
00CB0:  DATA 70,72
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 63,3A
00CB8:  DATA 20,43
00CBA:  DATA 68,65
00CBC:  DATA 63,6B
00CBE:  DATA 20,46
00CC0:  DATA 6C,61
00CC2:  DATA 73,68
00CC4:  DATA 20,4D
00CC6:  DATA 65,6D
00CC8:  DATA 6F,72
00CCA:  DATA 69,65
00CCC:  DATA 73,0A
00CCE:  DATA 00,00
00CD0:  DATA 41,44
00CD2:  DATA 43,53
00CD4:  DATA 20,6D
00CD6:  DATA 69,73
00CD8:  DATA 73,69
00CDA:  DATA 6F,6E
00CDC:  DATA 20,6D
00CDE:  DATA 6F,64
00CE0:  DATA 65,0A
00CE2:  DATA 00,00
00CE4:  DATA 45,50
00CE6:  DATA 53,20
00CE8:  DATA 6D,69
00CEA:  DATA 73,73
00CEC:  DATA 69,6F
00CEE:  DATA 6E,20
00CF0:  DATA 6D,6F
00CF2:  DATA 64,65
00CF4:  DATA 0A,00
00CF6:  DATA 49,6E
00CF8:  DATA 76,61
00CFA:  DATA 6C,69
00CFC:  DATA 64,20
00CFE:  DATA 49,4F
00D00:  DATA 20,6F
00D02:  DATA 70,74
00D04:  DATA 69,6F
00D06:  DATA 6E,2E
00D08:  DATA 20,50
00D0A:  DATA 6C,65
00D0C:  DATA 61,73
00D0E:  DATA 65,20
00D10:  DATA 74,72
00D12:  DATA 79,20
00D14:  DATA 61,67
00D16:  DATA 61,69
00D18:  DATA 6E,2E
00D1A:  DATA 0A,00
00D1C:  DATA 20,5F
00D1E:  DATA 5F,20
00D20:  DATA 20,5F
00D22:  DATA 5F,20
00D24:  DATA 5F,5F
00D26:  DATA 5F,5F
00D28:  DATA 5F,20
00D2A:  DATA 5F,20
00D2C:  DATA 20,20
00D2E:  DATA 5F,20
00D30:  DATA 5F,20
00D32:  DATA 20,20
00D34:  DATA 5F,20
00D36:  DATA 20,20
00D38:  DATA 5F,5F
00D3A:  DATA 5F,5F
00D3C:  DATA 5F,20
00D3E:  DATA 20,20
00D40:  DATA 20,20
00D42:  DATA 20,20
00D44:  DATA 20,20
00D46:  DATA 20,20
00D48:  DATA 20,20
00D4A:  DATA 20,20
00D4C:  DATA 20,20
00D4E:  DATA 5F,20
00D50:  DATA 20,20
00D52:  DATA 5F,20
00D54:  DATA 20,20
00D56:  DATA 20,20
00D58:  DATA 20,20
00D5A:  DATA 20,20
00D5C:  DATA 20,20
00D5E:  DATA 20,20
00D60:  DATA 0A,00
00D62:  DATA 7C,20
00D64:  DATA 20,5C
00D66:  DATA 2F,20
00D68:  DATA 20,7C
00D6A:  DATA 20,5F
00D6C:  DATA 5F,5F
00D6E:  DATA 5F,7C
00D70:  DATA 20,5C
00D72:  DATA 20,7C
00D74:  DATA 20,7C
00D76:  DATA 20,7C
00D78:  DATA 20,7C
00D7A:  DATA 20,7C
00D7C:  DATA 20,7C
00D7E:  DATA 20,20
00D80:  DATA 5F,5F
00D82:  DATA 5F,7C
00D84:  DATA 20,20
00D86:  DATA 20,5F
00D88:  DATA 20,5F
00D8A:  DATA 20,5F
00D8C:  DATA 5F,20
00D8E:  DATA 20,20
00D90:  DATA 5F,5F
00D92:  DATA 5F,7C
00D94:  DATA 20,7C
00D96:  DATA 5F,28
00D98:  DATA 5F,29
00D9A:  DATA 20,5F
00D9C:  DATA 5F,5F
00D9E:  DATA 20,20
00DA0:  DATA 5F,20
00DA2:  DATA 5F,5F
00DA4:  DATA 20,20
00DA6:  DATA 0A,00
00DA8:  DATA 7C,20
00DAA:  DATA 7C,5C
00DAC:  DATA 2F,7C
00DAE:  DATA 20,7C
00DB0:  DATA 20,20
00DB2:  DATA 5F,7C
00DB4:  DATA 20,7C
00DB6:  DATA 20,20
00DB8:  DATA 5C,7C
00DBA:  DATA 20,7C
00DBC:  DATA 20,7C
00DBE:  DATA 20,7C
00DC0:  DATA 20,7C
00DC2:  DATA 20,7C
00DC4:  DATA 20,7C
00DC6:  DATA 5F,20
00DC8:  DATA 7C,20
00DCA:  DATA 7C,20
00DCC:  DATA 7C,20
00DCE:  DATA 7C,20
00DD0:  DATA 27,5F
00DD2:  DATA 20,5C
00DD4:  DATA 20,2F
00DD6:  DATA 20,5F
00DD8:  DATA 5F,7C
00DDA:  DATA 20,5F
00DDC:  DATA 5F,7C
00DDE:  DATA 20,7C
00DE0:  DATA 2F,20
00DE2:  DATA 5F,20
00DE4:  DATA 5C,7C
00DE6:  DATA 20,27
00DE8:  DATA 5F,20
00DEA:  DATA 5C,20
00DEC:  DATA 0A,00
00DEE:  DATA 7C,20
00DF0:  DATA 7C,20
00DF2:  DATA 20,7C
00DF4:  DATA 20,7C
00DF6:  DATA 20,7C
00DF8:  DATA 5F,5F
00DFA:  DATA 5F,7C
00DFC:  DATA 20,7C
00DFE:  DATA 5C,20
00E00:  DATA 20,7C
00E02:  DATA 20,7C
00E04:  DATA 5F,7C
00E06:  DATA 20,7C
00E08:  DATA 20,7C
00E0A:  DATA 20,20
00E0C:  DATA 5F,7C
00E0E:  DATA 7C,20
00E10:  DATA 7C,5F
00E12:  DATA 7C,20
00E14:  DATA 7C,20
00E16:  DATA 7C,20
00E18:  DATA 7C,20
00E1A:  DATA 7C,20
00E1C:  DATA 28,5F
00E1E:  DATA 5F,7C
00E20:  DATA 20,7C
00E22:  DATA 5F,7C
00E24:  DATA 20,7C
00E26:  DATA 20,28
00E28:  DATA 5F,29
00E2A:  DATA 20,7C
00E2C:  DATA 20,7C
00E2E:  DATA 20,7C
00E30:  DATA 20,7C
00E32:  DATA 0A,00
00E34:  DATA 7C,5F
00E36:  DATA 7C,20
00E38:  DATA 5F,7C
00E3A:  DATA 5F,7C
00E3C:  DATA 5F,5F
00E3E:  DATA 5F,5F
00E40:  DATA 5F,7C
00E42:  DATA 5F,7C
00E44:  DATA 20,5C
00E46:  DATA 5F,7C
00E48:  DATA 5C,5F
00E4A:  DATA 5F,5F
00E4C:  DATA 2F,20
00E4E:  DATA 20,7C
00E50:  DATA 5F,7C
00E52:  DATA 5F,20
00E54:  DATA 20,5C
00E56:  DATA 5F,5F
00E58:  DATA 2C,5F
00E5A:  DATA 7C,5F
00E5C:  DATA 7C,20
00E5E:  DATA 7C,5F
00E60:  DATA 7C,5C
00E62:  DATA 5F,5F
00E64:  DATA 5F,7C
00E66:  DATA 5C,5F
00E68:  DATA 5F,7C
00E6A:  DATA 5F,7C
00E6C:  DATA 5C,5F
00E6E:  DATA 5F,5F
00E70:  DATA 2F,7C
00E72:  DATA 5F,7C
00E74:  DATA 20,7C
00E76:  DATA 5F,7C
00E78:  DATA 0A,00
00E7A:  DATA 20,20
00E7C:  DATA 20,2F
00E7E:  DATA 20,5C
00E80:  DATA 20,20
00E82:  DATA 20,5F
00E84:  DATA 5F,5F
00E86:  DATA 7C,20
00E88:  DATA 7C,5F
00E8A:  DATA 28,5F
00E8C:  DATA 29,5F
00E8E:  DATA 20,20
00E90:  DATA 20,5F
00E92:  DATA 5F,5F
00E94:  DATA 5F,20
00E96:  DATA 5F,7C
00E98:  DATA 20,7C
00E9A:  DATA 5F,20
00E9C:  DATA 5F,5F
00E9E:  DATA 5F,20
00EA0:  DATA 20,5F
00EA2:  DATA 5F,7C
00EA4:  DATA 20,7C
00EA6:  DATA 20,7C
00EA8:  DATA 20,20
00EAA:  DATA 20,20
00EAC:  DATA 20,20
00EAE:  DATA 20,20
00EB0:  DATA 20,20
00EB2:  DATA 20,20
00EB4:  DATA 20,20
00EB6:  DATA 20,20
00EB8:  DATA 20,20
00EBA:  DATA 20,20
00EBC:  DATA 20,20
00EBE:  DATA 0A,00
00EC0:  DATA 20,20
00EC2:  DATA 2F,20
00EC4:  DATA 5F,20
00EC6:  DATA 5C,20
00EC8:  DATA 2F,20
00ECA:  DATA 5F,5F
00ECC:  DATA 7C,20
00ECE:  DATA 5F,5F
00ED0:  DATA 7C,20
00ED2:  DATA 5C,20
00ED4:  DATA 5C,20
00ED6:  DATA 2F,20
00ED8:  DATA 2F,20
00EDA:  DATA 5F,60
00EDC:  DATA 20,7C
00EDE:  DATA 20,5F
00EE0:  DATA 5F,2F
00EE2:  DATA 20,5F
00EE4:  DATA 20,5C
00EE6:  DATA 2F,20
00EE8:  DATA 5F,60
00EEA:  DATA 20,7C
00EEC:  DATA 20,7C
00EEE:  DATA 20,20
00EF0:  DATA 20,20
00EF2:  DATA 20,20
00EF4:  DATA 20,20
00EF6:  DATA 20,20
00EF8:  DATA 20,20
00EFA:  DATA 20,20
00EFC:  DATA 20,20
00EFE:  DATA 20,20
00F00:  DATA 20,20
00F02:  DATA 20,20
00F04:  DATA 0A,00
00F06:  DATA 20,2F
00F08:  DATA 20,5F
00F0A:  DATA 5F,5F
00F0C:  DATA 20,5C
00F0E:  DATA 20,28
00F10:  DATA 5F,5F
00F12:  DATA 7C,20
00F14:  DATA 7C,5F
00F16:  DATA 7C,20
00F18:  DATA 7C,5C
00F1A:  DATA 20,56
00F1C:  DATA 20,2F
00F1E:  DATA 20,28
00F20:  DATA 5F,7C
00F22:  DATA 20,7C
00F24:  DATA 20,7C
00F26:  DATA 7C,20
00F28:  DATA 20,5F
00F2A:  DATA 5F,2F
00F2C:  DATA 20,28
00F2E:  DATA 5F,7C
00F30:  DATA 20,7C
00F32:  DATA 5F,7C
00F34:  DATA 20,20
00F36:  DATA 20,20
00F38:  DATA 20,20
00F3A:  DATA 20,20
00F3C:  DATA 20,20
00F3E:  DATA 20,20
00F40:  DATA 20,20
00F42:  DATA 20,20
00F44:  DATA 20,20
00F46:  DATA 20,20
00F48:  DATA 20,20
00F4A:  DATA 0A,00
00F4C:  DATA 2F,5F
00F4E:  DATA 2F,20
00F50:  DATA 20,20
00F52:  DATA 5C,5F
00F54:  DATA 5C,5F
00F56:  DATA 5F,5F
00F58:  DATA 7C,5C
00F5A:  DATA 5F,5F
00F5C:  DATA 7C,5F
00F5E:  DATA 7C,20
00F60:  DATA 5C,5F
00F62:  DATA 2F,20
00F64:  DATA 5C,5F
00F66:  DATA 5F,2C
00F68:  DATA 5F,7C
00F6A:  DATA 5C,5F
00F6C:  DATA 5F,5C
00F6E:  DATA 5F,5F
00F70:  DATA 5F,7C
00F72:  DATA 5C,5F
00F74:  DATA 5F,2C
00F76:  DATA 5F,28
00F78:  DATA 5F,29
00F7A:  DATA 20,20
00F7C:  DATA 20,20
00F7E:  DATA 20,20
00F80:  DATA 20,20
00F82:  DATA 20,20
00F84:  DATA 20,20
00F86:  DATA 20,20
00F88:  DATA 20,20
00F8A:  DATA 20,20
00F8C:  DATA 20,20
00F8E:  DATA 20,20
00F90:  DATA 0A,00
00F92:  DATA 0A,2D
00F94:  DATA 2D,2D
00F96:  DATA 2D,2D
00F98:  DATA 2D,2D
00F9A:  DATA 2D,2D
00F9C:  DATA 2D,2D
00F9E:  DATA 2D,2D
00FA0:  DATA 2D,2D
00FA2:  DATA 2D,2D
00FA4:  DATA 4D,61
00FA6:  DATA 69,6E
00FA8:  DATA 20,4D
00FAA:  DATA 65,6E
00FAC:  DATA 75,2D
00FAE:  DATA 2D,2D
00FB0:  DATA 2D,2D
00FB2:  DATA 2D,2D
00FB4:  DATA 2D,2D
00FB6:  DATA 2D,2D
00FB8:  DATA 2D,2D
00FBA:  DATA 2D,2D
00FBC:  DATA 2D,2D
00FBE:  DATA 0A,00
00FC0:  DATA 20,20
00FC2:  DATA 20,20
00FC4:  DATA 70,72
00FC6:  DATA 65,73
00FC8:  DATA 73,20
00FCA:  DATA 62,3A
00FCC:  DATA 20,45
00FCE:  DATA 50,53
00FD0:  DATA 20,50
00FD2:  DATA 6F,77
00FD4:  DATA 65,72
00FD6:  DATA 20,6F
00FD8:  DATA 75,74
00FDA:  DATA 70,75
00FDC:  DATA 74,20
00FDE:  DATA 63,6F
00FE0:  DATA 6E,74
00FE2:  DATA 72,6F
00FE4:  DATA 6C,0A
00FE6:  DATA 00,00
00FE8:  DATA 20,20
00FEA:  DATA 20,20
00FEC:  DATA 70,72
00FEE:  DATA 65,73
00FF0:  DATA 73,20
00FF2:  DATA 63,3A
00FF4:  DATA 20,48
00FF6:  DATA 6F,75
00FF8:  DATA 73,65
00FFA:  DATA 20,6B
00FFC:  DATA 65,65
00FFE:  DATA 70,69
01000:  DATA 6E,67
01002:  DATA 20,64
01004:  DATA 61,74
01006:  DATA 61,20
01008:  DATA 63,6F
0100A:  DATA 6C,6C
0100C:  DATA 65,63
0100E:  DATA 74,69
01010:  DATA 6F,6E
01012:  DATA 0A,00
01014:  DATA 20,20
01016:  DATA 20,20
01018:  DATA 70,72
0101A:  DATA 65,73
0101C:  DATA 73,20
0101E:  DATA 64,3A
01020:  DATA 20,43
01022:  DATA 68,65
01024:  DATA 63,6B
01026:  DATA 20,46
01028:  DATA 6C,61
0102A:  DATA 73,68
0102C:  DATA 20,4D
0102E:  DATA 65,6D
01030:  DATA 6F,72
01032:  DATA 69,65
01034:  DATA 73,0A
01036:  DATA 00,00
01038:  DATA 20,20
0103A:  DATA 20,20
0103C:  DATA 70,72
0103E:  DATA 65,73
01040:  DATA 73,20
01042:  DATA 66,3A
01044:  DATA 20,53
01046:  DATA 65,74
01048:  DATA 74,69
0104A:  DATA 6E,67
0104C:  DATA 73,20
0104E:  DATA 6F,66
01050:  DATA 20,52
01052:  DATA 54,43
01054:  DATA 0A,00
01056:  DATA 20,20
01058:  DATA 20,20
0105A:  DATA 70,72
0105C:  DATA 65,73
0105E:  DATA 73,20
01060:  DATA 6B,3A
01062:  DATA 20,55
01064:  DATA 41,52
01066:  DATA 54,20
01068:  DATA 72,65
0106A:  DATA 70,65
0106C:  DATA 61,74
0106E:  DATA 65,72
01070:  DATA 20,6F
01072:  DATA 66,20
01074:  DATA 45,50
01076:  DATA 53,0A
01078:  DATA 00,00
0107A:  DATA 20,20
0107C:  DATA 20,20
0107E:  DATA 70,72
01080:  DATA 65,73
01082:  DATA 73,20
01084:  DATA 6C,3A
01086:  DATA 20,74
01088:  DATA 65,73
0108A:  DATA 74,6D
0108C:  DATA 6F,64
0108E:  DATA 65,20
01090:  DATA 0A,00
01092:  DATA 20,20
01094:  DATA 20,20
01096:  DATA 70,72
01098:  DATA 65,73
0109A:  DATA 73,20
0109C:  DATA 78,3A
0109E:  DATA 20,45
010A0:  DATA 78,69
010A2:  DATA 74,20
010A4:  DATA 4D,61
010A6:  DATA 69,6E
010A8:  DATA 20,4D
010AA:  DATA 65,6E
010AC:  DATA 75,0A
010AE:  DATA 00,00
010B0:  DATA 20,20
010B2:  DATA 20,20
010B4:  DATA 44,4F
010B6:  DATA 20,4E
010B8:  DATA 4F,54
010BA:  DATA 20,55
010BC:  DATA 53,45
010BE:  DATA 20,43
010C0:  DATA 41,50
010C2:  DATA 49,54
010C4:  DATA 41,4C
010C6:  DATA 20,43
010C8:  DATA 48,41
010CA:  DATA 52,41
010CC:  DATA 43,54
010CE:  DATA 45,52
010D0:  DATA 53,20
010D2:  DATA 54,4F
010D4:  DATA 20,57
010D6:  DATA 52,49
010D8:  DATA 54,45
010DA:  DATA 21,0A
010DC:  DATA 0A,00
010DE:  DATA 55,41
010E0:  DATA 52,54
010E2:  DATA 20,52
010E4:  DATA 65,70
010E6:  DATA 65,61
010E8:  DATA 74,65
010EA:  DATA 72,20
010EC:  DATA 49,6E
010EE:  DATA 69,74
010F0:  DATA 69,61
010F2:  DATA 6C,69
010F4:  DATA 7A,65
010F6:  DATA 64,2E
010F8:  DATA 0A,00
010FA:  DATA 54,65
010FC:  DATA 73,74
010FE:  DATA 6D,6F
01100:  DATA 64,65
01102:  DATA 20,69
01104:  DATA 6E,69
01106:  DATA 74,69
01108:  DATA 61,6C
0110A:  DATA 69,7A
0110C:  DATA 65,64
0110E:  DATA 0A,00
01110:  DATA 49,6E
01112:  DATA 76,61
01114:  DATA 6C,69
01116:  DATA 64,20
01118:  DATA 6F,70
0111A:  DATA 74,69
0111C:  DATA 6F,6E
0111E:  DATA 2E,20
01120:  DATA 50,6C
01122:  DATA 65,61
01124:  DATA 73,65
01126:  DATA 20,74
01128:  DATA 72,79
0112A:  DATA 20,61
0112C:  DATA 67,61
0112E:  DATA 69,6E
01130:  DATA 2E,0A
01132:  DATA 00,00
01134:  DATA 52,65
01136:  DATA 61,64
01138:  DATA 69,6E
0113A:  DATA 67,20
0113C:  DATA 63,68
0113E:  DATA 69,70
01140:  DATA 20,49
01142:  DATA 44,20
01144:  DATA 6F,66
01146:  DATA 20,6D
01148:  DATA 61,69
0114A:  DATA 6E,0A
0114C:  DATA 00,00
0114E:  DATA 52,65
01150:  DATA 61,64
01152:  DATA 69,6E
01154:  DATA 67,20
01156:  DATA 63,68
01158:  DATA 69,70
0115A:  DATA 20,49
0115C:  DATA 44,20
0115E:  DATA 6F,66
01160:  DATA 20,43
01162:  DATA 4F,4D
01164:  DATA 0A,00
01166:  DATA 52,65
01168:  DATA 61,64
0116A:  DATA 69,6E
0116C:  DATA 67,20
0116E:  DATA 63,68
01170:  DATA 69,70
01172:  DATA 20,49
01174:  DATA 44,20
01176:  DATA 6F,66
01178:  DATA 20,41
0117A:  DATA 44,43
0117C:  DATA 53,0A
0117E:  DATA 00,00
01180:  DATA 44,6F
01182:  DATA 6E,65
01184:  DATA 20,72
01186:  DATA 65,61
01188:  DATA 64,69
0118A:  DATA 6E,67
0118C:  DATA 20,63
0118E:  DATA 68,69
01190:  DATA 70,20
01192:  DATA 49,44
01194:  DATA 0A,00
01196:  DATA 53,74
01198:  DATA 61,72
0119A:  DATA 74,69
0119C:  DATA 6E,67
0119E:  DATA 20,74
011A0:  DATA 6F,20
011A2:  DATA 77,72
011A4:  DATA 69,74
011A6:  DATA 65,20
011A8:  DATA 64,61
011AA:  DATA 74,61
011AC:  DATA 20,69
011AE:  DATA 6E,20
011B0:  DATA 4D,41
011B2:  DATA 49,4E
011B4:  DATA 20,66
011B6:  DATA 6C,61
011B8:  DATA 73,68
011BA:  DATA 20,6D
011BC:  DATA 65,6D
011BE:  DATA 6F,72
011C0:  DATA 79,0A
011C2:  DATA 00,00
011C4:  DATA 53,74
011C6:  DATA 61,72
011C8:  DATA 74,69
011CA:  DATA 6E,67
011CC:  DATA 20,74
011CE:  DATA 6F,20
011D0:  DATA 77,72
011D2:  DATA 69,74
011D4:  DATA 65,20
011D6:  DATA 64,61
011D8:  DATA 74,61
011DA:  DATA 20,69
011DC:  DATA 6E,20
011DE:  DATA 43,4F
011E0:  DATA 4D,20
011E2:  DATA 66,6C
011E4:  DATA 61,73
011E6:  DATA 68,20
011E8:  DATA 6D,65
011EA:  DATA 6D,6F
011EC:  DATA 72,79
011EE:  DATA 0A,00
011F0:  DATA 4D,41
011F2:  DATA 49,4E
011F4:  DATA 20,54
011F6:  DATA 45,53
011F8:  DATA 54,20
011FA:  DATA 49,53
011FC:  DATA 20,46
011FE:  DATA 49,4E
01200:  DATA 49,53
01202:  DATA 48,45
01204:  DATA 44,21
01206:  DATA 0A,00
*
01278:  TBLRD*+
0127A:  MOVF   FF5,F
0127C:  BZ    129E
0127E:  MOVFF  FF6,2E1
01282:  MOVFF  FF7,2E2
01286:  MOVFF  FF8,2E3
0128A:  MOVFF  FF5,2F3
0128E:  RCALL  1232
01290:  MOVFF  2E1,FF6
01294:  MOVFF  2E2,FF7
01298:  MOVFF  2E3,FF8
0129C:  BRA    1278
0129E:  RETURN 0
*
01312:  MOVWF  00
01314:  SWAPF  00,W
01316:  ADDWF  00,W
01318:  ANDLW  0F
0131A:  BTFSC  FD8.1
0131C:  ADDLW  16
0131E:  DAW   
01320:  BTFSC  00.4
01322:  ADDLW  15
01324:  BTFSC  00.5
01326:  ADDLW  30
01328:  BTFSC  00.6
0132A:  ADDLW  60
0132C:  BTFSC  00.7
0132E:  ADDLW  20
01330:  DAW   
01332:  RETURN 0
01334:  RETURN 0
01336:  MOVWF  00
01338:  SWAPF  00,W
0133A:  ANDLW  0F
0133C:  MULLW  0A
0133E:  MOVF   00,W
01340:  ANDLW  0F
01342:  ADDWF  FF3,W
01344:  RETURN 0
01346:  RETURN 0
01348:  MOVLB  2
0134A:  MOVF   xF4,W
0134C:  CLRF   01
0134E:  SUBWF  xF3,W
01350:  BC    1358
01352:  MOVFF  2F3,00
01356:  BRA    1370
01358:  CLRF   00
0135A:  MOVLW  08
0135C:  MOVWF  xF5
0135E:  RLCF   xF3,F
01360:  RLCF   00,F
01362:  MOVF   xF4,W
01364:  SUBWF  00,W
01366:  BTFSC  FD8.0
01368:  MOVWF  00
0136A:  RLCF   01,F
0136C:  DECFSZ xF5,F
0136E:  BRA    135E
01370:  MOVLB  0
01372:  RETURN 0
01374:  MOVF   01,W
01376:  MOVFF  1C5,2F3
0137A:  MOVLW  64
0137C:  MOVLB  2
0137E:  MOVWF  xF4
01380:  MOVLB  0
01382:  RCALL  1348
01384:  MOVFF  00,1C5
01388:  MOVF   01,W
0138A:  MOVLW  30
0138C:  BNZ   139E
0138E:  MOVLB  1
01390:  BTFSS  xC6.1
01392:  BRA    13B0
01394:  BTFSC  xC6.3
01396:  BRA    13B0
01398:  BTFSC  xC6.4
0139A:  MOVLW  20
0139C:  BRA    13A6
0139E:  MOVLB  1
013A0:  BCF    xC6.3
013A2:  BCF    xC6.4
013A4:  BSF    xC6.0
013A6:  ADDWF  01,F
013A8:  MOVFF  01,2F3
013AC:  MOVLB  0
013AE:  RCALL  1232
013B0:  MOVFF  1C5,2F3
013B4:  MOVLW  0A
013B6:  MOVLB  2
013B8:  MOVWF  xF4
013BA:  MOVLB  0
013BC:  RCALL  1348
013BE:  MOVFF  00,1C5
013C2:  MOVF   01,W
013C4:  MOVLW  30
013C6:  BNZ   13D8
013C8:  MOVLB  1
013CA:  BTFSC  xC6.3
013CC:  BRA    13E2
013CE:  BTFSS  xC6.0
013D0:  BRA    13E2
013D2:  BTFSC  xC6.4
013D4:  MOVLW  20
013D6:  MOVLB  0
013D8:  ADDWF  01,F
013DA:  MOVFF  01,2F3
013DE:  RCALL  1232
013E0:  MOVLB  1
013E2:  MOVLW  30
013E4:  ADDWF  xC5,F
013E6:  MOVFF  1C5,2F3
013EA:  MOVLB  0
013EC:  RCALL  1232
013EE:  RETURN 0
013F0:  TBLRD*+
013F2:  MOVFF  FF6,2EE
013F6:  MOVFF  FF7,2EF
013FA:  MOVFF  FF8,2F0
013FE:  MOVFF  FF5,2F3
01402:  RCALL  1232
01404:  MOVFF  2EE,FF6
01408:  MOVFF  2EF,FF7
0140C:  MOVFF  2F0,FF8
01410:  MOVLB  2
01412:  DECFSZ xED,F
01414:  BRA    1418
01416:  BRA    141C
01418:  MOVLB  0
0141A:  BRA    13F0
0141C:  MOVLB  0
0141E:  RETURN 0
*
016A2:  MOVLB  2
016A4:  BTFSC  xEE.7
016A6:  BRA    16CA
016A8:  MOVLW  0F
016AA:  MOVWF  00
016AC:  SWAPF  xED,W
016AE:  ANDWF  00,F
016B0:  MOVLW  0A
016B2:  SUBWF  00,W
016B4:  BC    16BC
016B6:  MOVLW  30
016B8:  ADDWF  00,F
016BA:  BRA    16C0
016BC:  MOVF   xEE,W
016BE:  ADDWF  00,F
016C0:  MOVFF  00,2F3
016C4:  MOVLB  0
016C6:  RCALL  1232
016C8:  MOVLB  2
016CA:  MOVLW  0F
016CC:  ANDWF  xED,F
016CE:  MOVLW  0A
016D0:  SUBWF  xED,W
016D2:  BC    16D8
016D4:  MOVLW  30
016D6:  BRA    16DC
016D8:  BCF    xEE.7
016DA:  MOVF   xEE,W
016DC:  ADDWF  xED,F
016DE:  MOVFF  2ED,2F3
016E2:  MOVLB  0
016E4:  RCALL  1232
016E6:  RETURN 0
*
01706:  MOVLW  20
01708:  MOVLB  2
0170A:  BTFSS  xEE.4
0170C:  MOVLW  30
0170E:  MOVWF  xEF
01710:  MOVFF  2ED,00
01714:  BTFSS  00.7
01716:  BRA    1728
01718:  COMF   00,F
0171A:  INCF   00,F
0171C:  MOVFF  00,2ED
01720:  MOVLW  2D
01722:  MOVWF  xEF
01724:  BSF    xEE.7
01726:  BSF    xEE.0
01728:  MOVF   01,W
0172A:  MOVFF  2ED,2F3
0172E:  MOVLW  64
01730:  MOVWF  xF4
01732:  MOVLB  0
01734:  RCALL  1348
01736:  MOVFF  00,2ED
0173A:  MOVLW  30
0173C:  ADDWF  01,W
0173E:  MOVLB  2
01740:  MOVWF  xF0
01742:  MOVFF  2ED,2F3
01746:  MOVLW  0A
01748:  MOVWF  xF4
0174A:  MOVLB  0
0174C:  RCALL  1348
0174E:  MOVLW  30
01750:  ADDWF  00,W
01752:  MOVLB  2
01754:  MOVWF  xF2
01756:  MOVLW  30
01758:  ADDWF  01,W
0175A:  MOVWF  xF1
0175C:  MOVFF  2EF,00
01760:  MOVLW  30
01762:  SUBWF  xF0,W
01764:  BZ    176E
01766:  BSF    xEE.1
01768:  BTFSC  xEE.7
0176A:  BSF    xEE.2
0176C:  BRA    1792
0176E:  MOVFF  2EF,2F0
01772:  MOVLW  20
01774:  MOVWF  xEF
01776:  MOVLW  30
01778:  SUBWF  xF1,W
0177A:  BZ    1784
0177C:  BSF    xEE.0
0177E:  BTFSC  xEE.7
01780:  BSF    xEE.1
01782:  BRA    1792
01784:  BTFSS  FD8.2
01786:  BSF    xEE.0
01788:  BNZ   1792
0178A:  MOVFF  2F0,2F1
0178E:  MOVLW  20
01790:  MOVWF  xF0
01792:  BTFSC  xEE.2
01794:  BRA    17A0
01796:  BTFSC  xEE.1
01798:  BRA    17A8
0179A:  BTFSC  xEE.0
0179C:  BRA    17B0
0179E:  BRA    17B8
017A0:  MOVFF  2EF,2F3
017A4:  MOVLB  0
017A6:  RCALL  1232
017A8:  MOVFF  2F0,2F3
017AC:  MOVLB  0
017AE:  RCALL  1232
017B0:  MOVFF  2F1,2F3
017B4:  MOVLB  0
017B6:  RCALL  1232
017B8:  MOVFF  2F2,2F3
017BC:  MOVLB  0
017BE:  RCALL  1232
017C0:  RETURN 0
*
0239A:  MOVLB  2
0239C:  CLRF   xF6
0239E:  CLRF   xF7
023A0:  MOVLW  01
023A2:  MOVWF  xF8
023A4:  CLRF   FDA
023A6:  CLRF   FD9
023A8:  MOVLW  02
023AA:  MOVWF  xFB
023AC:  MOVLW  EE
023AE:  MOVWF  xFA
023B0:  MOVLW  02
023B2:  MOVWF  FEA
023B4:  MOVLW  F2
023B6:  MOVWF  FE9
023B8:  MOVFF  2FB,FE2
023BC:  MOVFF  2FA,FE1
023C0:  MOVFF  2F8,2F9
023C4:  BCF    FD8.0
023C6:  MOVF   FE5,W
023C8:  MULWF  FEE
023CA:  MOVF   FF3,W
023CC:  ADDWFC xF6,F
023CE:  MOVF   FF4,W
023D0:  ADDWFC xF7,F
023D2:  DECFSZ xF9,F
023D4:  BRA    23C4
023D6:  MOVFF  2F6,FDE
023DA:  MOVFF  2F7,2F6
023DE:  CLRF   xF7
023E0:  BTFSC  FD8.0
023E2:  INCF   xF7,F
023E4:  INCF   xFA,F
023E6:  BTFSC  FD8.2
023E8:  INCF   xFB,F
023EA:  INCF   xF8,F
023EC:  MOVF   xF8,W
023EE:  SUBLW  05
023F0:  BNZ   23B0
023F2:  MOVLB  0
023F4:  GOTO   249C (RETURN)
023F8:  MOVF   03,W
023FA:  SUBLW  20
023FC:  BZ    240E
023FE:  MOVF   03,W
02400:  SUBLW  08
02402:  BC    240A
02404:  MOVF   03,W
02406:  SUBLW  0D
02408:  BC    240E
0240A:  CLRF   01
0240C:  BRA    2412
0240E:  MOVLW  01
02410:  MOVWF  01
02412:  RETURN 0
02414:  MOVLB  2
02416:  CLRF   xE8
02418:  CLRF   xEC
0241A:  CLRF   xEB
0241C:  CLRF   xEA
0241E:  CLRF   xE9
02420:  BTFSS  xE6.7
02422:  BRA    242A
02424:  MOVF   xE5,F
02426:  BTFSC  FD8.2
02428:  BRA    2500
0242A:  MOVLB  0
0242C:  RCALL  1E7E
0242E:  MOVFF  01,2E7
02432:  MOVLB  2
02434:  MOVF   xE7,F
02436:  BTFSC  FD8.2
02438:  BRA    2500
0243A:  INCF   xE8,F
0243C:  MOVF   xE7,W
0243E:  SUBLW  20
02440:  BC    24CC
02442:  MOVF   xE7,W
02444:  SUBLW  58
02446:  BZ    24EA
02448:  MOVF   xE7,W
0244A:  SUBLW  78
0244C:  BZ    24EA
0244E:  MOVF   xE7,W
02450:  SUBLW  2F
02452:  BC    24FC
02454:  MOVLW  30
02456:  SUBWF  xE7,F
02458:  MOVF   xE7,W
0245A:  SUBLW  09
0245C:  BC    247E
0245E:  MOVLW  07
02460:  SUBWF  xE7,F
02462:  MOVF   xE7,W
02464:  SUBLW  09
02466:  BC    24FC
02468:  MOVF   xE7,W
0246A:  SUBLW  0F
0246C:  BC    247E
0246E:  MOVLW  20
02470:  SUBWF  xE7,F
02472:  MOVF   xE7,W
02474:  SUBLW  09
02476:  BC    24FC
02478:  MOVF   xE7,W
0247A:  SUBLW  0F
0247C:  BNC   24FC
0247E:  MOVFF  2EC,2F1
02482:  MOVFF  2EB,2F0
02486:  MOVFF  2EA,2EF
0248A:  MOVFF  2E9,2EE
0248E:  CLRF   xF5
02490:  CLRF   xF4
02492:  CLRF   xF3
02494:  MOVLW  10
02496:  MOVWF  xF2
02498:  MOVLB  0
0249A:  BRA    239A
0249C:  MOVLB  2
0249E:  MOVF   xE7,W
024A0:  ADDWF  00,W
024A2:  MOVWF  xE9
024A4:  MOVLW  00
024A6:  ADDWFC 01,W
024A8:  MOVWF  xEA
024AA:  MOVLW  00
024AC:  ADDWFC 02,W
024AE:  MOVWF  xEB
024B0:  MOVLW  00
024B2:  ADDWFC 03,W
024B4:  MOVWF  xEC
024B6:  BTFSC  xE6.7
024B8:  DECF   xE5,F
024BA:  BTFSC  xE6.0
024BC:  BRA    24C6
024BE:  MOVF   xE7,F
024C0:  BNZ   24C6
024C2:  BSF    xE6.1
024C4:  BRA    2420
024C6:  BCF    xE6.1
024C8:  BSF    xE6.0
024CA:  BRA    2420
024CC:  MOVFF  2E7,03
024D0:  MOVLB  0
024D2:  RCALL  23F8
024D4:  MOVF   01,F
024D6:  BTFSS  FD8.2
024D8:  BRA    24DE
024DA:  MOVLB  2
024DC:  BRA    24FC
024DE:  MOVLB  2
024E0:  BTFSC  xE6.0
024E2:  BRA    2500
024E4:  BTFSC  xE6.1
024E6:  BRA    2500
024E8:  BRA    2420
024EA:  BTFSC  xE6.0
024EC:  BRA    24FC
024EE:  BTFSS  xE6.1
024F0:  BRA    24FC
024F2:  BTFSC  xE6.7
024F4:  INCF   xE5,F
024F6:  BCF    xE6.1
024F8:  BSF    xE6.0
024FA:  BRA    2420
024FC:  CLRF   xE8
024FE:  BRA    251C
02500:  BTFSC  xE6.6
02502:  BRA    251C
02504:  MOVFF  2E4,FEA
02508:  MOVFF  2E3,FE9
0250C:  MOVFF  2E9,FEF
02510:  MOVFF  2EA,FEC
02514:  MOVFF  2EB,FEC
02518:  MOVFF  2EC,FEC
0251C:  MOVFF  2E8,01
02520:  MOVLB  0
02522:  RETURN 0
02524:  MOVLB  2
02526:  CLRF   xEA
02528:  CLRF   xEB
0252A:  BTFSS  xE8.7
0252C:  BRA    2532
0252E:  MOVF   xE7,F
02530:  BZ    25DC
02532:  MOVLB  0
02534:  RCALL  1E7E
02536:  MOVFF  01,2E9
0253A:  MOVLB  2
0253C:  MOVF   xE9,F
0253E:  BZ    25DC
02540:  INCF   xEA,F
02542:  MOVF   xE9,W
02544:  SUBLW  20
02546:  BC    25A8
02548:  MOVF   xE9,W
0254A:  SUBLW  58
0254C:  BZ    25C6
0254E:  MOVF   xE9,W
02550:  SUBLW  78
02552:  BZ    25C6
02554:  MOVF   xE9,W
02556:  SUBLW  2F
02558:  BC    25D8
0255A:  MOVLW  30
0255C:  SUBWF  xE9,F
0255E:  MOVF   xE9,W
02560:  SUBLW  09
02562:  BC    2584
02564:  MOVLW  07
02566:  SUBWF  xE9,F
02568:  MOVF   xE9,W
0256A:  SUBLW  09
0256C:  BC    25D8
0256E:  MOVF   xE9,W
02570:  SUBLW  0F
02572:  BC    2584
02574:  MOVLW  20
02576:  SUBWF  xE9,F
02578:  MOVF   xE9,W
0257A:  SUBLW  09
0257C:  BC    25D8
0257E:  MOVF   xE9,W
02580:  SUBLW  0F
02582:  BNC   25D8
02584:  MOVF   xEB,W
02586:  MULLW  10
02588:  MOVFF  FF3,01
0258C:  MOVF   xE9,W
0258E:  ADDWF  01,W
02590:  MOVWF  xEB
02592:  BTFSC  xE8.7
02594:  DECF   xE7,F
02596:  BTFSC  xE8.0
02598:  BRA    25A2
0259A:  MOVF   xE9,F
0259C:  BNZ   25A2
0259E:  BSF    xE8.1
025A0:  BRA    252A
025A2:  BCF    xE8.1
025A4:  BSF    xE8.0
025A6:  BRA    252A
025A8:  MOVFF  2E9,03
025AC:  MOVLB  0
025AE:  RCALL  23F8
025B0:  MOVF   01,F
025B2:  BTFSS  FD8.2
025B4:  BRA    25BA
025B6:  MOVLB  2
025B8:  BRA    25D8
025BA:  MOVLB  2
025BC:  BTFSC  xE8.0
025BE:  BRA    25DC
025C0:  BTFSC  xE8.1
025C2:  BRA    25DC
025C4:  BRA    252A
025C6:  BTFSC  xE8.0
025C8:  BRA    25D8
025CA:  BTFSS  xE8.1
025CC:  BRA    25D8
025CE:  BTFSC  xE8.7
025D0:  INCF   xE7,F
025D2:  BCF    xE8.1
025D4:  BSF    xE8.0
025D6:  BRA    252A
025D8:  CLRF   xEA
025DA:  BRA    25EC
025DC:  BTFSC  xE8.6
025DE:  BRA    25EC
025E0:  MOVFF  2E6,FEA
025E4:  MOVFF  2E5,FE9
025E8:  MOVFF  2EB,FEF
025EC:  MOVFF  2EA,01
025F0:  MOVLB  0
025F2:  RETURN 0
*
0276E:  CLRF   00
02770:  CLRF   01
02772:  MOVLB  1
02774:  MOVF   xE5,W
02776:  BCF    FD8.0
02778:  BTFSC  xE6.0
0277A:  ADDWF  00,F
0277C:  RRCF   00,F
0277E:  RRCF   01,F
02780:  BTFSC  xE6.1
02782:  ADDWF  00,F
02784:  RRCF   00,F
02786:  RRCF   01,F
02788:  BTFSC  xE6.2
0278A:  ADDWF  00,F
0278C:  RRCF   00,F
0278E:  RRCF   01,F
02790:  BTFSC  xE6.3
02792:  ADDWF  00,F
02794:  RRCF   00,F
02796:  RRCF   01,F
02798:  BTFSC  xE6.4
0279A:  ADDWF  00,F
0279C:  RRCF   00,F
0279E:  RRCF   01,F
027A0:  BTFSC  xE6.5
027A2:  ADDWF  00,F
027A4:  RRCF   00,F
027A6:  RRCF   01,F
027A8:  BTFSC  xE6.6
027AA:  ADDWF  00,F
027AC:  RRCF   00,F
027AE:  RRCF   01,F
027B0:  BTFSC  xE6.7
027B2:  ADDWF  00,F
027B4:  RRCF   00,F
027B6:  RRCF   01,F
027B8:  MOVLB  0
027BA:  GOTO   2812 (RETURN)
027BE:  MOVLB  1
027C0:  CLRF   xE2
027C2:  CLRF   xE3
027C4:  BTFSS  xDD.7
027C6:  BRA    27CC
027C8:  MOVF   xDC,F
027CA:  BZ    2880
027CC:  MOVLB  0
027CE:  CALL   1E7E
027D2:  MOVFF  01,1E1
027D6:  MOVLB  1
027D8:  MOVF   xE1,F
027DA:  BZ    2880
027DC:  INCF   xE2,F
027DE:  MOVF   xE1,W
027E0:  SUBLW  20
027E2:  BC    2844
027E4:  MOVF   xE1,W
027E6:  SUBLW  2D
027E8:  BZ    2866
027EA:  MOVF   xE1,W
027EC:  SUBLW  2B
027EE:  BZ    286A
027F0:  MOVF   xE1,W
027F2:  SUBLW  2F
027F4:  BC    287C
027F6:  MOVLW  30
027F8:  SUBWF  xE1,F
027FA:  MOVF   xE0,W
027FC:  SUBWF  xE1,W
027FE:  BC    287C
02800:  BTFSS  xDD.4
02802:  BRA    2806
02804:  NEGF   xE1
02806:  MOVFF  1E3,1E5
0280A:  MOVFF  1E0,1E6
0280E:  MOVLB  0
02810:  BRA    276E
02812:  MOVF   01,W
02814:  MOVFF  01,1E3
02818:  MOVLB  1
0281A:  MOVF   xE1,W
0281C:  ADDWF  xE3,F
0281E:  BTFSC  xDD.7
02820:  DECF   xDC,F
02822:  MOVF   xE0,W
02824:  SUBLW  08
02826:  BNZ   283E
02828:  BTFSC  xDD.0
0282A:  BRA    2836
0282C:  MOVF   xE1,F
0282E:  BNZ   283E
02830:  BSF    xDD.1
02832:  BSF    xDD.0
02834:  BRA    27C4
02836:  BTFSS  xDD.1
02838:  BRA    283E
0283A:  BTFSC  xDD.7
0283C:  INCF   xDC,F
0283E:  BSF    xDD.0
02840:  BCF    xDD.1
02842:  BRA    27C4
02844:  MOVFF  1E1,03
02848:  MOVLB  0
0284A:  RCALL  23F8
0284C:  MOVF   01,F
0284E:  BTFSS  FD8.2
02850:  BRA    2856
02852:  MOVLB  1
02854:  BRA    287C
02856:  MOVLB  1
02858:  BTFSC  xDD.0
0285A:  BRA    2880
0285C:  BTFSC  xDD.1
0285E:  BRA    2880
02860:  BTFSC  xDD.2
02862:  BRA    287C
02864:  BRA    27C4
02866:  BSF    xDD.4
02868:  BRA    286C
0286A:  BCF    xDD.4
0286C:  BTFSC  xDD.0
0286E:  BRA    287C
02870:  BTFSC  xDD.1
02872:  BRA    287C
02874:  BTFSC  xDD.2
02876:  BRA    287C
02878:  BSF    xDD.2
0287A:  BRA    27C4
0287C:  CLRF   xE2
0287E:  BRA    2890
02880:  BTFSC  xDD.6
02882:  BRA    2890
02884:  MOVFF  1DF,FEA
02888:  MOVFF  1DE,FE9
0288C:  MOVFF  1E3,FEF
02890:  MOVFF  1E2,01
02894:  MOVLB  0
02896:  GOTO   2984 (RETURN)
*
038D8:  MOVF   FEF,F
038DA:  BZ    38FC
038DC:  MOVFF  FEA,1D9
038E0:  MOVFF  FE9,1D8
038E4:  MOVFF  FEF,2F3
038E8:  CALL   1232
038EC:  MOVFF  1D9,FEA
038F0:  MOVFF  1D8,FE9
038F4:  INCF   FE9,F
038F6:  BTFSC  FD8.2
038F8:  INCF   FEA,F
038FA:  BRA    38D8
038FC:  RETURN 0
*
03B04:  MOVLW  8E
03B06:  MOVWF  00
03B08:  MOVFF  1D5,01
03B0C:  MOVFF  1D4,02
03B10:  CLRF   03
03B12:  MOVF   01,F
03B14:  BNZ   3B28
03B16:  MOVFF  02,01
03B1A:  CLRF   02
03B1C:  MOVLW  08
03B1E:  SUBWF  00,F
03B20:  MOVF   01,F
03B22:  BNZ   3B28
03B24:  CLRF   00
03B26:  BRA    3B38
03B28:  BCF    FD8.0
03B2A:  BTFSC  01.7
03B2C:  BRA    3B36
03B2E:  RLCF   02,F
03B30:  RLCF   01,F
03B32:  DECF   00,F
03B34:  BRA    3B28
03B36:  BCF    01.7
03B38:  RETURN 0
03B3A:  MOVLB  1
03B3C:  MOVF   xD4,W
03B3E:  BTFSC  FD8.2
03B40:  BRA    3C24
03B42:  MOVWF  00
03B44:  MOVF   xD8,W
03B46:  BTFSC  FD8.2
03B48:  BRA    3C24
03B4A:  ADDWF  00,F
03B4C:  BNC   3B56
03B4E:  MOVLW  81
03B50:  ADDWF  00,F
03B52:  BC    3C24
03B54:  BRA    3B5E
03B56:  MOVLW  7F
03B58:  SUBWF  00,F
03B5A:  BNC   3C24
03B5C:  BZ    3C24
03B5E:  MOVFF  1D5,1DC
03B62:  MOVF   xD9,W
03B64:  XORWF  xDC,F
03B66:  BSF    xD5.7
03B68:  BSF    xD9.7
03B6A:  MOVF   xD7,W
03B6C:  MULWF  xDB
03B6E:  MOVFF  FF4,1DE
03B72:  MOVF   xD6,W
03B74:  MULWF  xDA
03B76:  MOVFF  FF4,03
03B7A:  MOVFF  FF3,1DD
03B7E:  MULWF  xDB
03B80:  MOVF   FF3,W
03B82:  ADDWF  xDE,F
03B84:  MOVF   FF4,W
03B86:  ADDWFC xDD,F
03B88:  MOVLW  00
03B8A:  ADDWFC 03,F
03B8C:  MOVF   xD7,W
03B8E:  MULWF  xDA
03B90:  MOVF   FF3,W
03B92:  ADDWF  xDE,F
03B94:  MOVF   FF4,W
03B96:  ADDWFC xDD,F
03B98:  MOVLW  00
03B9A:  CLRF   02
03B9C:  ADDWFC 03,F
03B9E:  ADDWFC 02,F
03BA0:  MOVF   xD5,W
03BA2:  MULWF  xDB
03BA4:  MOVF   FF3,W
03BA6:  ADDWF  xDD,F
03BA8:  MOVF   FF4,W
03BAA:  ADDWFC 03,F
03BAC:  MOVLW  00
03BAE:  ADDWFC 02,F
03BB0:  MOVF   xD5,W
03BB2:  MULWF  xDA
03BB4:  MOVF   FF3,W
03BB6:  ADDWF  03,F
03BB8:  MOVF   FF4,W
03BBA:  ADDWFC 02,F
03BBC:  MOVLW  00
03BBE:  CLRF   01
03BC0:  ADDWFC 01,F
03BC2:  MOVF   xD7,W
03BC4:  MULWF  xD9
03BC6:  MOVF   FF3,W
03BC8:  ADDWF  xDD,F
03BCA:  MOVF   FF4,W
03BCC:  ADDWFC 03,F
03BCE:  MOVLW  00
03BD0:  ADDWFC 02,F
03BD2:  ADDWFC 01,F
03BD4:  MOVF   xD6,W
03BD6:  MULWF  xD9
03BD8:  MOVF   FF3,W
03BDA:  ADDWF  03,F
03BDC:  MOVF   FF4,W
03BDE:  ADDWFC 02,F
03BE0:  MOVLW  00
03BE2:  ADDWFC 01,F
03BE4:  MOVF   xD5,W
03BE6:  MULWF  xD9
03BE8:  MOVF   FF3,W
03BEA:  ADDWF  02,F
03BEC:  MOVF   FF4,W
03BEE:  ADDWFC 01,F
03BF0:  INCF   00,F
03BF2:  BTFSC  01.7
03BF4:  BRA    3C00
03BF6:  RLCF   xDD,F
03BF8:  RLCF   03,F
03BFA:  RLCF   02,F
03BFC:  RLCF   01,F
03BFE:  DECF   00,F
03C00:  MOVLW  00
03C02:  BTFSS  xDD.7
03C04:  BRA    3C1A
03C06:  INCF   03,F
03C08:  ADDWFC 02,F
03C0A:  ADDWFC 01,F
03C0C:  MOVF   01,W
03C0E:  BNZ   3C1A
03C10:  MOVF   02,W
03C12:  BNZ   3C1A
03C14:  MOVF   03,W
03C16:  BNZ   3C1A
03C18:  INCF   00,F
03C1A:  BTFSC  xDC.7
03C1C:  BSF    01.7
03C1E:  BTFSS  xDC.7
03C20:  BCF    01.7
03C22:  BRA    3C2C
03C24:  CLRF   00
03C26:  CLRF   01
03C28:  CLRF   02
03C2A:  CLRF   03
03C2C:  MOVLB  0
03C2E:  RETURN 0
03C30:  MOVLB  1
03C32:  MOVF   xD8,W
03C34:  BTFSC  FD8.2
03C36:  BRA    3D82
03C38:  MOVWF  xE4
03C3A:  MOVF   xDC,W
03C3C:  BTFSC  FD8.2
03C3E:  BRA    3D82
03C40:  SUBWF  xE4,F
03C42:  BNC   3C4E
03C44:  MOVLW  7F
03C46:  ADDWF  xE4,F
03C48:  BTFSC  FD8.0
03C4A:  BRA    3D82
03C4C:  BRA    3C5A
03C4E:  MOVLW  81
03C50:  SUBWF  xE4,F
03C52:  BTFSS  FD8.0
03C54:  BRA    3D82
03C56:  BTFSC  FD8.2
03C58:  BRA    3D82
03C5A:  MOVFF  1E4,00
03C5E:  CLRF   01
03C60:  CLRF   02
03C62:  CLRF   03
03C64:  CLRF   xE3
03C66:  MOVFF  1D9,1E2
03C6A:  BSF    xE2.7
03C6C:  MOVFF  1DA,1E1
03C70:  MOVFF  1DB,1E0
03C74:  MOVLW  19
03C76:  MOVWF  xE4
03C78:  MOVF   xDF,W
03C7A:  SUBWF  xE0,F
03C7C:  BC    3C98
03C7E:  MOVLW  01
03C80:  SUBWF  xE1,F
03C82:  BC    3C98
03C84:  SUBWF  xE2,F
03C86:  BC    3C98
03C88:  SUBWF  xE3,F
03C8A:  BC    3C98
03C8C:  INCF   xE3,F
03C8E:  INCF   xE2,F
03C90:  INCF   xE1,F
03C92:  MOVF   xDF,W
03C94:  ADDWF  xE0,F
03C96:  BRA    3CE8
03C98:  MOVF   xDE,W
03C9A:  SUBWF  xE1,F
03C9C:  BC    3CC2
03C9E:  MOVLW  01
03CA0:  SUBWF  xE2,F
03CA2:  BC    3CC2
03CA4:  SUBWF  xE3,F
03CA6:  BC    3CC2
03CA8:  INCF   xE3,F
03CAA:  INCF   xE2,F
03CAC:  MOVF   xDE,W
03CAE:  ADDWF  xE1,F
03CB0:  MOVF   xDF,W
03CB2:  ADDWF  xE0,F
03CB4:  BNC   3CE8
03CB6:  INCF   xE1,F
03CB8:  BNZ   3CE8
03CBA:  INCF   xE2,F
03CBC:  BNZ   3CE8
03CBE:  INCF   xE3,F
03CC0:  BRA    3CE8
03CC2:  MOVF   xDD,W
03CC4:  IORLW  80
03CC6:  SUBWF  xE2,F
03CC8:  BC    3CE6
03CCA:  MOVLW  01
03CCC:  SUBWF  xE3,F
03CCE:  BC    3CE6
03CD0:  INCF   xE3,F
03CD2:  MOVF   xDD,W
03CD4:  IORLW  80
03CD6:  ADDWF  xE2,F
03CD8:  MOVF   xDE,W
03CDA:  ADDWF  xE1,F
03CDC:  BNC   3CB0
03CDE:  INCF   xE2,F
03CE0:  BNZ   3CB0
03CE2:  INCF   xE3,F
03CE4:  BRA    3CB0
03CE6:  BSF    03.0
03CE8:  DECFSZ xE4,F
03CEA:  BRA    3CEE
03CEC:  BRA    3D04
03CEE:  BCF    FD8.0
03CF0:  RLCF   xE0,F
03CF2:  RLCF   xE1,F
03CF4:  RLCF   xE2,F
03CF6:  RLCF   xE3,F
03CF8:  BCF    FD8.0
03CFA:  RLCF   03,F
03CFC:  RLCF   02,F
03CFE:  RLCF   01,F
03D00:  RLCF   xE5,F
03D02:  BRA    3C78
03D04:  BTFSS  xE5.0
03D06:  BRA    3D14
03D08:  BCF    FD8.0
03D0A:  RRCF   01,F
03D0C:  RRCF   02,F
03D0E:  RRCF   03,F
03D10:  RRCF   xE5,F
03D12:  BRA    3D18
03D14:  DECF   00,F
03D16:  BZ    3D82
03D18:  BTFSC  xE5.7
03D1A:  BRA    3D58
03D1C:  BCF    FD8.0
03D1E:  RLCF   xE0,F
03D20:  RLCF   xE1,F
03D22:  RLCF   xE2,F
03D24:  RLCF   xE3,F
03D26:  MOVF   xDF,W
03D28:  SUBWF  xE0,F
03D2A:  BC    3D3A
03D2C:  MOVLW  01
03D2E:  SUBWF  xE1,F
03D30:  BC    3D3A
03D32:  SUBWF  xE2,F
03D34:  BC    3D3A
03D36:  SUBWF  xE3,F
03D38:  BNC   3D6E
03D3A:  MOVF   xDE,W
03D3C:  SUBWF  xE1,F
03D3E:  BC    3D4A
03D40:  MOVLW  01
03D42:  SUBWF  xE2,F
03D44:  BC    3D4A
03D46:  SUBWF  xE3,F
03D48:  BNC   3D6E
03D4A:  MOVF   xDD,W
03D4C:  IORLW  80
03D4E:  SUBWF  xE2,F
03D50:  BC    3D58
03D52:  MOVLW  01
03D54:  SUBWF  xE3,F
03D56:  BNC   3D6E
03D58:  INCF   03,F
03D5A:  BNZ   3D6E
03D5C:  INCF   02,F
03D5E:  BNZ   3D6E
03D60:  INCF   01,F
03D62:  BNZ   3D6E
03D64:  INCF   00,F
03D66:  BZ    3D82
03D68:  RRCF   01,F
03D6A:  RRCF   02,F
03D6C:  RRCF   03,F
03D6E:  MOVFF  1D9,1E4
03D72:  MOVF   xDD,W
03D74:  XORWF  xE4,F
03D76:  BTFSS  xE4.7
03D78:  BRA    3D7E
03D7A:  BSF    01.7
03D7C:  BRA    3D8A
03D7E:  BCF    01.7
03D80:  BRA    3D8A
03D82:  CLRF   00
03D84:  CLRF   01
03D86:  CLRF   02
03D88:  CLRF   03
03D8A:  MOVLB  0
03D8C:  RETURN 0
.................... 
.................... #list
.................... 
....................  #device ADC=16
....................  #device ICD=TRUE
....................  #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................   unsigned char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    unsigned char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    unsigned char uc;
....................    unsigned char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(unsigned char *s)
.................... {
....................    unsigned char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... unsigned char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strlwr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strupr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... //remove TRUE and FALSE added by CCS's device .h file
.................... #if defined(TRUE)
.................... #undef TRUE
.................... #endif
.................... #if defined(FALSE)
.................... #undef FALSE
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... //#include <mt25q.h>
.................... // #include <main_functions.h>
....................  #FUSES NOWDT NOBROWNOUT    
....................  #use delay(clock=16M, crystal)
*
01208:  MOVLW  01
0120A:  MOVWF  FEA
0120C:  MOVLW  CD
0120E:  MOVWF  FE9
01210:  MOVF   FEF,W
01212:  BZ    1230
01214:  MOVLW  05
01216:  MOVWF  01
01218:  CLRF   00
0121A:  DECFSZ 00,F
0121C:  BRA    121A
0121E:  DECFSZ 01,F
01220:  BRA    1218
01222:  MOVLW  2E
01224:  MOVWF  00
01226:  DECFSZ 00,F
01228:  BRA    1226
0122A:  BRA    122C
0122C:  DECFSZ FEF,F
0122E:  BRA    1214
01230:  RETURN 0
....................   
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  #use rs232(baud=9600, parity=N, xmit=PIN_E5, rcv=PIN_E4, bits=8, stream=EPS) //EPS DATA ACQUISITION
*
0303E:  BSF    F96.4
03040:  BTFSC  F84.4
03042:  BRA    3040
03044:  MOVLW  08
03046:  MOVWF  00
03048:  MOVLB  1
0304A:  CLRF   xDB
0304C:  BSF    00.7
0304E:  BRA    306C
03050:  BCF    00.7
03052:  BRA    306C
03054:  BCF    FD8.0
03056:  BTFSC  F84.4
03058:  BSF    FD8.0
0305A:  RRCF   xDB,F
0305C:  BSF    00.6
0305E:  BRA    306C
03060:  BCF    00.6
03062:  DECFSZ 00,F
03064:  BRA    3054
03066:  MOVFF  1DB,01
0306A:  BRA    3084
0306C:  MOVLW  84
0306E:  BTFSC  00.7
03070:  MOVLW  24
03072:  MOVWF  01
03074:  DECFSZ 01,F
03076:  BRA    3074
03078:  BRA    307A
0307A:  BTFSC  00.7
0307C:  BRA    3050
0307E:  BTFSC  00.6
03080:  BRA    3060
03082:  BRA    3054
03084:  MOVLB  0
03086:  RETURN 0
*
038FE:  BCF    F96.5
03900:  BCF    F8D.5
03902:  MOVLW  08
03904:  MOVWF  01
03906:  BRA    3908
03908:  NOP   
0390A:  BSF    01.7
0390C:  BRA    392E
0390E:  BCF    01.7
03910:  MOVLB  1
03912:  RRCF   xD7,F
03914:  MOVLB  0
03916:  BTFSC  FD8.0
03918:  BSF    F8D.5
0391A:  BTFSS  FD8.0
0391C:  BCF    F8D.5
0391E:  BSF    01.6
03920:  BRA    392E
03922:  BCF    01.6
03924:  DECFSZ 01,F
03926:  BRA    3910
03928:  BRA    392A
0392A:  NOP   
0392C:  BSF    F8D.5
0392E:  MOVLW  84
03930:  MOVWF  FE9
03932:  DECFSZ FE9,F
03934:  BRA    3932
03936:  BRA    3938
03938:  NOP   
0393A:  BTFSC  01.7
0393C:  BRA    390E
0393E:  BTFSC  01.6
03940:  BRA    3922
03942:  GOTO   394C (RETURN)
....................  #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, stream=EXT) //MAIN RAB Rear access board 
*
01232:  BCF    F94.6
01234:  BCF    F8B.6
01236:  MOVLW  08
01238:  MOVWF  01
0123A:  BRA    123C
0123C:  NOP   
0123E:  BSF    01.7
01240:  BRA    1262
01242:  BCF    01.7
01244:  MOVLB  2
01246:  RRCF   xF3,F
01248:  MOVLB  0
0124A:  BTFSC  FD8.0
0124C:  BSF    F8B.6
0124E:  BTFSS  FD8.0
01250:  BCF    F8B.6
01252:  BSF    01.6
01254:  BRA    1262
01256:  BCF    01.6
01258:  DECFSZ 01,F
0125A:  BRA    1244
0125C:  BRA    125E
0125E:  NOP   
01260:  BSF    F8B.6
01262:  MOVLW  84
01264:  MOVWF  FE9
01266:  DECFSZ FE9,F
01268:  BRA    1266
0126A:  BRA    126C
0126C:  NOP   
0126E:  BTFSC  01.7
01270:  BRA    1242
01272:  BTFSC  01.6
01274:  BRA    1256
01276:  RETURN 0
*
01E7E:  BSF    F94.7
01E80:  BTFSC  F82.7
01E82:  BRA    1E80
01E84:  MOVLW  08
01E86:  MOVWF  00
01E88:  MOVLB  2
01E8A:  CLRF   xEE
01E8C:  BSF    00.7
01E8E:  BRA    1EAC
01E90:  BCF    00.7
01E92:  BRA    1EAC
01E94:  BCF    FD8.0
01E96:  BTFSC  F82.7
01E98:  BSF    FD8.0
01E9A:  RRCF   xEE,F
01E9C:  BSF    00.6
01E9E:  BRA    1EAC
01EA0:  BCF    00.6
01EA2:  DECFSZ 00,F
01EA4:  BRA    1E94
01EA6:  MOVFF  2EE,01
01EAA:  BRA    1EC4
01EAC:  MOVLW  84
01EAE:  BTFSC  00.7
01EB0:  MOVLW  24
01EB2:  MOVWF  01
01EB4:  DECFSZ 01,F
01EB6:  BRA    1EB4
01EB8:  BRA    1EBA
01EBA:  BTFSC  00.7
01EBC:  BRA    1E90
01EBE:  BTFSC  00.6
01EC0:  BRA    1EA0
01EC2:  BRA    1E94
01EC4:  MOVLB  0
01EC6:  RETURN 0
....................  #use rs232(baud=57600, parity=N, xmit=PIN_D2, rcv=PIN_D3, bits=8, stream=COM, FORCE_SW) //MAIN COM Communication, send CW data 
....................  #use rs232(baud=57600, parity=N, xmit=PIN_F7, rcv=PIN_F6, bits=8, stream=CAM, FORCE_SW) //MAIN CAM Communicationx
....................  #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=10000, BITS=8, STREAM=MAIN_FM, MODE=0) //MAIN flash memory port
*
01568:  MOVLB  2
0156A:  MOVF   xEF,W
0156C:  SUBLW  08
0156E:  BZ    1578
01570:  MOVWF  xF1
01572:  RLCF   xEE,F
01574:  DECFSZ xF1,F
01576:  BRA    1572
01578:  BSF    F96.0
0157A:  BCF    F96.6
0157C:  BCF    F96.1
0157E:  BCF    F8D.1
01580:  MOVFF  2EF,2F1
01584:  BTFSS  xEE.7
01586:  BCF    F8D.6
01588:  BTFSC  xEE.7
0158A:  BSF    F8D.6
0158C:  RLCF   xEE,F
0158E:  BSF    F8D.1
01590:  MOVLW  41
01592:  MOVWF  xF2
01594:  DECFSZ xF2,F
01596:  BRA    1594
01598:  RLCF   01,F
0159A:  BTFSS  F84.0
0159C:  BCF    01.0
0159E:  BTFSC  F84.0
015A0:  BSF    01.0
015A2:  BCF    F8D.1
015A4:  MOVLW  40
015A6:  MOVWF  xF2
015A8:  DECFSZ xF2,F
015AA:  BRA    15A8
015AC:  DECFSZ xF1,F
015AE:  BRA    1584
015B0:  MOVLB  0
015B2:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=10000, BITS=8, STREAM=COM_FM, MODE=0) //COM shared flash memory port
*
01A28:  MOVLB  2
01A2A:  MOVF   xBE,W
01A2C:  SUBLW  08
01A2E:  BZ    1A38
01A30:  MOVWF  xC0
01A32:  RLCF   xBD,F
01A34:  DECFSZ xC0,F
01A36:  BRA    1A32
01A38:  BSF    F93.5
01A3A:  BCF    F93.4
01A3C:  BCF    F93.2
01A3E:  BCF    F8A.2
01A40:  MOVFF  2BE,2C0
01A44:  BTFSS  xBD.7
01A46:  BCF    F8A.4
01A48:  BTFSC  xBD.7
01A4A:  BSF    F8A.4
01A4C:  RLCF   xBD,F
01A4E:  BSF    F8A.2
01A50:  MOVLW  41
01A52:  MOVWF  xC1
01A54:  DECFSZ xC1,F
01A56:  BRA    1A54
01A58:  RLCF   01,F
01A5A:  BTFSS  F81.5
01A5C:  BCF    01.0
01A5E:  BTFSC  F81.5
01A60:  BSF    01.0
01A62:  BCF    F8A.2
01A64:  MOVLW  40
01A66:  MOVWF  xC1
01A68:  DECFSZ xC1,F
01A6A:  BRA    1A68
01A6C:  DECFSZ xC0,F
01A6E:  BRA    1A44
01A70:  MOVLB  0
01A72:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=10000, BITS=8, STREAM=MISSION_FM, MODE=0) //ADCS shared flash memory port, Camera module (ovcam,mvcam) only can access via mux selcent
*
01B02:  MOVLB  1
01B04:  MOVF   xD3,W
01B06:  SUBLW  08
01B08:  BZ    1B12
01B0A:  MOVWF  xD5
01B0C:  RLCF   xD2,F
01B0E:  DECFSZ xD5,F
01B10:  BRA    1B0C
01B12:  BSF    F92.0
01B14:  BCF    F92.1
01B16:  BCF    F92.3
01B18:  BCF    F89.3
01B1A:  MOVFF  1D3,1D5
01B1E:  BTFSS  xD2.7
01B20:  BCF    F89.1
01B22:  BTFSC  xD2.7
01B24:  BSF    F89.1
01B26:  RLCF   xD2,F
01B28:  BSF    F89.3
01B2A:  MOVLW  41
01B2C:  MOVWF  xD6
01B2E:  DECFSZ xD6,F
01B30:  BRA    1B2E
01B32:  RLCF   01,F
01B34:  BTFSS  F80.0
01B36:  BCF    01.0
01B38:  BTFSC  F80.0
01B3A:  BSF    01.0
01B3C:  BCF    F89.3
01B3E:  MOVLW  40
01B40:  MOVWF  xD6
01B42:  DECFSZ xD6,F
01B44:  BRA    1B42
01B46:  DECFSZ xD5,F
01B48:  BRA    1B1E
01B4A:  MOVLB  0
01B4C:  RETURN 0
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //SPI Stream alter name 
....................  #define SPIPORT MAIN_FM
....................  #define SPIPORT2 COM_FM
....................  #define SPIPORT3 MISSION_FM  //cam system futher added 
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................      
....................  //Flash memory chip select pins and mux control 
....................  #define CS_PIN_1 PIN_E2 //OBC_FLASH_SELECT
....................  #define CS_PIN_COM PIN_B3 //COM_CHIP_SELECT
....................  #define CS_PIN_MISSION PIN_A2 //ADCS_CHIP_SELECT
....................  #define MX_PIN_OVCAM PIN_G2 //OVCAM_MUX_SELECT
....................  #define MX_PIN_MVCAM PIN_G3 //MVCAM_MUX_SELECT
....................  #define MX_PIN_ADCS PIN_A5 //ADCS_MUX_SELECT
....................  #define MX_PIN_COM PIN_C4 //COM_MUX_SELECT
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //mt25q flash memory command assigment
....................  #define READ_ID              0x9F
....................  #define READ_STATUS_REG      0x05 
....................  #define READ_DATA_BYTES      0x13  //0x03 for byte
....................  #define ENABLE_WRITE         0x06
....................  #define WRITE_PAGE           0x12  //0x02 for 3byte 
....................  #define ERASE_SECTOR         0xDC  //0xD8 for 3byte
....................  #define ERASE_4KB_SUBSECTOR  0x21
....................  #define ERASE_32KB_SUBSECTOR 0x5C
....................  #define DIE_ERASE            0xC4
....................  #define FAST_READ            0x0B
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //memory maping     
....................  #define SHUTDOWN_COUNT_ADDRESS 0x00100011
....................  
....................  //digtal control pins 
....................  #define EN_SUP_3V3_1 PIN_B0
....................  #define EN_SUP_3V3_2 PIN_G1
....................  #define EN_SUP_3V3_DAQ PIN_D0
....................  #define EN_SUP_UNREG PIN_B1
....................  #define EN_SUP_5V0 PIN_D1
....................  #define KILL_SWITCH PIN_A4
....................  #define MVCAM_PWR PIN_G0
....................  #define OVCAM_PWR PIN_D7
....................  #define ADCS_PWR PIN_D6
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //FLAG variable
....................     //  int8 EPS_UART = 0;
....................     //  int8 COM_UART = 0;
....................     //  int8 EXT_UART = 0; 
....................     //  unsigned int8 in_bffr_main[16] = {};
....................     //  int8 COM_DATA= 0;
....................  
....................  //    int8 ADCS_HK_ADDRESS = 0x00010000;
....................  //    int8 ADCS_HK_ADDRESS_COUNTER = 0x00000000;
....................  //    int8 SHUT_DOWN_COUNT_ADD = 0x00010000;
....................  //    int8 ADCS_COMMAND = 0x02;
....................  //    unsigned char *READ_HK_ADCS[16];
....................      
....................  
....................  //SerialDataReceive(){
....................  //   int num = 0;
....................  //   for(num = 0 ;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = fgetc(EXT);
....................  //   }     
....................  //   return;
....................  //}
....................  //void Delete_Buffer() //delete com command buffer
....................  //{
....................  //   int num = 0;
....................  //   for(num = 0;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = 0x00;
....................  //   }
....................  //   COM_DATA = 0;
....................  //   return;
....................  //}
....................  //
....................  //void Transfer_Buffer(int PORT_NUM) //get buffer data one by one
....................  //                                   //1:EPS 2:EXT 3:COM 4:CAM
....................  //{
....................  //   int num = 0;
....................  //   switch(PORT_NUM)
....................  //   {
....................  //      case 1:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EPS);
....................  //         }
....................  //         break;
....................  //      case 2:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EXT);
....................  //         }
....................  //         break;
....................  //      case 3:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],COM);
....................  //         }
....................  //         break;
....................  //      case 4:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],CAM);
....................  //         }
....................  //         break;
....................  //   }
....................  //   return;
....................  //}
....................  //
....................  //void process_uart() {
....................  //    if (kbhit(EXT)) {  // Check if data is available
....................  //        SerialDataReceive();  // Load 16 bytes into the buffer
....................  //        fprintf(EXT, "Received Data: ");
....................  //        Transfer_Buffer(1);  // Transfer to PC for verification
....................  //        Delete_Buffer();  // Clear the buffer for the next message
....................  //    }
....................  //}
....................  
....................  void WRITE_ENABLE_OF(){
....................   output_low(CS_PIN_1);
*
016E8:  BCF    F96.2
016EA:  BCF    F8D.2
....................   spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06
016EC:  MOVLW  06
016EE:  MOVLB  2
016F0:  MOVWF  xEE
016F2:  MOVLW  08
016F4:  MOVWF  xEF
016F6:  MOVLW  01
016F8:  MOVWF  xF0
016FA:  MOVLB  0
016FC:  RCALL  1568
....................   output_high(CS_PIN_1);  
016FE:  BCF    F96.2
01700:  BSF    F8D.2
....................   return;
01702:  GOTO   1838 (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_COM(){
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
*
01BD8:  BCF    F93.3
01BDA:  BCF    F8A.3
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01BDC:  BCF    F94.4
01BDE:  BCF    F8B.4
....................      spi_xfer(SPIPORT2,ENABLE_WRITE);                //Send 0x06
01BE0:  MOVLW  06
01BE2:  MOVLB  2
01BE4:  MOVWF  xBD
01BE6:  MOVLW  08
01BE8:  MOVWF  xBE
01BEA:  MOVLW  01
01BEC:  MOVWF  xBF
01BEE:  MOVLB  0
01BF0:  RCALL  1A28
....................      output_high(CS_PIN_COM);
01BF2:  BCF    F93.3
01BF4:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01BF6:  BCF    F94.4
01BF8:  BSF    F8B.4
....................   return;
01BFA:  GOTO   1C78 (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_ADCS(){
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
*
030A0:  BCF    F92.5
030A2:  BCF    F89.5
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
030A4:  BCF    F92.2
030A6:  BCF    F89.2
....................      spi_xfer(SPIPORT3,ENABLE_WRITE);                //Send 0x06
030A8:  MOVLW  06
030AA:  MOVLB  1
030AC:  MOVWF  xD2
030AE:  MOVLW  08
030B0:  MOVWF  xD3
030B2:  MOVLW  01
030B4:  MOVWF  xD4
030B6:  MOVLB  0
030B8:  CALL   1B02
....................      output_high(CS_PIN_MISSION);  
030BC:  BCF    F92.2
030BE:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
030C0:  BCF    F92.5
030C2:  BSF    F89.5
....................   return;
030C4:  RETURN 0
....................  }
....................  void WRITE_ENABLE_IHS(){
....................     // lower MX to connect to flash device
....................     output_low(MX_PIN_MVCAM);
....................     // LowerCS pin to activate the flash device
....................     output_low(CS_PIN_MISSION);
....................     spi_xfer(SPIPORT3,ENABLE_WRITE);                //Send 0x06
....................     output_high(CS_PIN_MISSION);
....................     output_high(MX_PIN_MVCAM);
....................   return;
....................  }
.................... 
....................  void WRITE_ENABLE_GENERIC(int STREAM, int CS_PIN, int MX_PIN) {
....................     // Lower MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_low(MX_PIN);
....................     }
.................... 
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN);
.................... 
....................     if(STREAM == 1) {
....................         spi_xfer(SPIPORT, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 2) {
....................         spi_xfer(SPIPORT2, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 3) {
....................         spi_xfer(SPIPORT3, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } 
....................     // Raise CS to deselect the SPI device
....................     output_high(CS_PIN);
.................... 
....................     // Raise MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_high(MX_PIN);
....................     }
.................... }
....................  
....................  void SECTOR_ERASE_OF_ADCS(unsigned int32 sector_address) {
....................     unsigned int8 address[4];
....................     // Byte extraction for a 32-bit address
....................     address[0] = (unsigned int8)((sector_address >> 24) & 0xFF);
030C6:  MOVLB  1
030C8:  MOVFF  1C8,1C9
030CC:  CLRF   03
....................     address[1] = (unsigned int8)((sector_address >> 16) & 0xFF);
030CE:  MOVFF  1C7,1CA
030D2:  CLRF   03
....................     address[2] = (unsigned int8)((sector_address >> 8) & 0xFF);
030D4:  MOVFF  1C6,1CB
030D8:  CLRF   03
....................     address[3] = (unsigned int8)(sector_address & 0xFF);
030DA:  MOVFF  1C5,1CC
030DE:  CLRF   03
.................... 
....................     // Enable write operation
....................     WRITE_ENABLE_OF_ADCS();
030E0:  MOVLB  0
030E2:  RCALL  30A0
.................... 
....................     // Lower MX to connect to flash device
....................     output_low(MX_PIN_ADCS);
030E4:  BCF    F92.5
030E6:  BCF    F89.5
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN_MISSION);
030E8:  BCF    F92.2
030EA:  BCF    F89.2
....................     delay_us(2);  // Small delay for stabilization
030EC:  MOVLW  02
030EE:  MOVWF  00
030F0:  DECFSZ 00,F
030F2:  BRA    30F0
030F4:  NOP   
.................... 
....................     // Send ERASE command and address
....................     spi_xfer(SPIPORT3, ERASE_SECTOR);
030F6:  MOVLW  DC
030F8:  MOVLB  1
030FA:  MOVWF  xD2
030FC:  MOVLW  08
030FE:  MOVWF  xD3
03100:  MOVLW  01
03102:  MOVWF  xD4
03104:  MOVLB  0
03106:  CALL   1B02
....................     spi_xfer(SPIPORT3, address[0]);
0310A:  MOVFF  1C9,1D2
0310E:  MOVLW  08
03110:  MOVLB  1
03112:  MOVWF  xD3
03114:  MOVLW  01
03116:  MOVWF  xD4
03118:  MOVLB  0
0311A:  CALL   1B02
....................     spi_xfer(SPIPORT3, address[1]);
0311E:  MOVFF  1CA,1D2
03122:  MOVLW  08
03124:  MOVLB  1
03126:  MOVWF  xD3
03128:  MOVLW  01
0312A:  MOVWF  xD4
0312C:  MOVLB  0
0312E:  CALL   1B02
....................     spi_xfer(SPIPORT3, address[2]);
03132:  MOVFF  1CB,1D2
03136:  MOVLW  08
03138:  MOVLB  1
0313A:  MOVWF  xD3
0313C:  MOVLW  01
0313E:  MOVWF  xD4
03140:  MOVLB  0
03142:  CALL   1B02
....................     spi_xfer(SPIPORT3, address[3]);
03146:  MOVFF  1CC,1D2
0314A:  MOVLW  08
0314C:  MOVLB  1
0314E:  MOVWF  xD3
03150:  MOVLW  01
03152:  MOVWF  xD4
03154:  MOVLB  0
03156:  CALL   1B02
.................... 
....................     // Deselect SPI device and MUX
....................     output_high(CS_PIN_MISSION);
0315A:  BCF    F92.2
0315C:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);
0315E:  BCF    F92.5
03160:  BSF    F89.5
.................... 
....................     // Wait for the erase operation to complete
....................     delay_ms(10);
03162:  MOVLW  0A
03164:  MOVLB  1
03166:  MOVWF  xCD
03168:  MOVLB  0
0316A:  CALL   1208
0316E:  GOTO   3464 (RETURN)
.................... }
....................  
....................  void WRITE_DATA_NBYTES(unsigned int32 ADDRESS, unsigned int8* data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
017C2:  MOVLW  06
017C4:  MOVWF  FF6
017C6:  MOVLW  00
017C8:  MOVWF  FF7
017CA:  MOVLW  00
017CC:  MOVWF  FF8
017CE:  MOVLW  11
017D0:  MOVLB  2
017D2:  MOVWF  xED
017D4:  MOVLB  0
017D6:  RCALL  13F0
017D8:  MOVFF  2E4,2ED
017DC:  MOVLW  57
017DE:  MOVLB  2
017E0:  MOVWF  xEE
017E2:  MOVLB  0
017E4:  RCALL  16A2
017E6:  MOVFF  2E3,2ED
017EA:  MOVLW  57
017EC:  MOVLB  2
017EE:  MOVWF  xEE
017F0:  MOVLB  0
017F2:  RCALL  16A2
017F4:  MOVFF  2E2,2ED
017F8:  MOVLW  57
017FA:  MOVLB  2
017FC:  MOVWF  xEE
017FE:  MOVLB  0
01800:  RCALL  16A2
01802:  MOVFF  2E1,2ED
01806:  MOVLW  57
01808:  MOVLB  2
0180A:  MOVWF  xEE
0180C:  MOVLB  0
0180E:  RCALL  16A2
01810:  MOVLW  0A
01812:  MOVLB  2
01814:  MOVWF  xF3
01816:  MOVLB  0
01818:  RCALL  1232
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
0181A:  MOVLB  2
0181C:  MOVFF  2E4,2E8
01820:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01822:  MOVFF  2E3,2E9
01826:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01828:  MOVFF  2E2,2EA
0182C:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
0182E:  MOVFF  2E1,2EB
01832:  CLRF   03
....................      WRITE_ENABLE_OF();  // Enable write operation
01834:  MOVLB  0
01836:  BRA    16E8
....................  
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_1);
01838:  BCF    F96.2
0183A:  BCF    F8D.2
....................      delay_us(2);  // Small delay for stabilization
0183C:  MOVLW  02
0183E:  MOVWF  00
01840:  DECFSZ 00,F
01842:  BRA    1840
01844:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT, WRITE_PAGE);
01846:  MOVLW  12
01848:  MOVLB  2
0184A:  MOVWF  xEE
0184C:  MOVLW  08
0184E:  MOVWF  xEF
01850:  MOVLW  01
01852:  MOVWF  xF0
01854:  MOVLB  0
01856:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[0]);
01858:  MOVFF  2E8,2EE
0185C:  MOVLW  08
0185E:  MOVLB  2
01860:  MOVWF  xEF
01862:  MOVLW  01
01864:  MOVWF  xF0
01866:  MOVLB  0
01868:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[1]);
0186A:  MOVFF  2E9,2EE
0186E:  MOVLW  08
01870:  MOVLB  2
01872:  MOVWF  xEF
01874:  MOVLW  01
01876:  MOVWF  xF0
01878:  MOVLB  0
0187A:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[2]);
0187C:  MOVFF  2EA,2EE
01880:  MOVLW  08
01882:  MOVLB  2
01884:  MOVWF  xEF
01886:  MOVLW  01
01888:  MOVWF  xF0
0188A:  MOVLB  0
0188C:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[3]);
0188E:  MOVFF  2EB,2EE
01892:  MOVLW  08
01894:  MOVLB  2
01896:  MOVWF  xEF
01898:  MOVLW  01
0189A:  MOVWF  xF0
0189C:  MOVLB  0
0189E:  RCALL  1568
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
018A0:  MOVLB  2
018A2:  CLRF   xEC
018A4:  MOVF   xE7,W
018A6:  SUBWF  xEC,W
018A8:  BC    18F8
....................          spi_xfer(SPIPORT, data[i]);  // Send data byte
018AA:  MOVF   xEC,W
018AC:  ADDWF  xE5,W
018AE:  MOVWF  FE9
018B0:  MOVLW  00
018B2:  ADDWFC xE6,W
018B4:  MOVWF  FEA
018B6:  MOVFF  FEF,2EE
018BA:  MOVLW  08
018BC:  MOVWF  xEF
018BE:  MOVLW  01
018C0:  MOVWF  xF0
018C2:  MOVLB  0
018C4:  RCALL  1568
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (optional)
018C6:  MOVLB  2
018C8:  MOVF   xEC,W
018CA:  ADDWF  xE5,W
018CC:  MOVWF  FE9
018CE:  MOVLW  00
018D0:  ADDWFC xE6,W
018D2:  MOVWF  FEA
018D4:  MOVFF  FEF,2ED
018D8:  MOVLW  01
018DA:  MOVWF  xEE
018DC:  MOVLW  20
018DE:  MOVWF  xF3
018E0:  MOVLB  0
018E2:  RCALL  1232
018E4:  MOVLB  2
018E6:  DECFSZ xEE,F
018E8:  BRA    18DC
018EA:  MOVFF  2ED,2F3
018EE:  MOVLB  0
018F0:  RCALL  1232
018F2:  MOVLB  2
018F4:  INCF   xEC,F
018F6:  BRA    18A4
....................      }
....................  //    for (int i = 0; i < data_number; i++) {
....................  //        spi_xfer(SPIPORT, data[i]);  // Send data byte
....................  //        fprintf(EXT,"%02d", data[i]);    // Print each byte as hex (optional)
....................  //    } for futhre use this is for displaying in hex format 
....................      
....................      output_high(CS_PIN_1);  // Deselect SPI device
018F8:  BCF    F96.2
018FA:  BSF    F8D.2
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN MAIN!\n", data_number);
018FC:  MOVLW  0A
018FE:  MOVWF  xF3
01900:  MOVLB  0
01902:  RCALL  1232
01904:  MOVFF  2E7,2ED
01908:  MOVLW  18
0190A:  MOVLB  2
0190C:  MOVWF  xEE
0190E:  MOVLB  0
01910:  RCALL  1706
01912:  MOVLW  21
01914:  MOVWF  FF6
01916:  MOVLW  00
01918:  MOVWF  FF7
0191A:  MOVLW  00
0191C:  MOVWF  FF8
0191E:  MOVLW  18
01920:  MOVLB  2
01922:  MOVWF  xED
01924:  MOVLB  0
01926:  RCALL  13F0
....................      return;
01928:  RETURN 0
....................  }
....................  
....................  
....................  void WRITE_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN COM: 0x%08lx\n", ADDRESS);  // Print address as hex
*
01BFE:  MOVLW  3A
01C00:  MOVWF  FF6
01C02:  MOVLW  00
01C04:  MOVWF  FF7
01C06:  MOVLW  00
01C08:  MOVWF  FF8
01C0A:  MOVLW  18
01C0C:  MOVLB  2
01C0E:  MOVWF  xED
01C10:  MOVLB  0
01C12:  CALL   13F0
01C16:  MOVFF  1B4,2ED
01C1A:  MOVLW  57
01C1C:  MOVLB  2
01C1E:  MOVWF  xEE
01C20:  MOVLB  0
01C22:  RCALL  16A2
01C24:  MOVFF  1B3,2ED
01C28:  MOVLW  57
01C2A:  MOVLB  2
01C2C:  MOVWF  xEE
01C2E:  MOVLB  0
01C30:  RCALL  16A2
01C32:  MOVFF  1B2,2ED
01C36:  MOVLW  57
01C38:  MOVLB  2
01C3A:  MOVWF  xEE
01C3C:  MOVLB  0
01C3E:  RCALL  16A2
01C40:  MOVFF  1B1,2ED
01C44:  MOVLW  57
01C46:  MOVLB  2
01C48:  MOVWF  xEE
01C4A:  MOVLB  0
01C4C:  RCALL  16A2
01C4E:  MOVLW  0A
01C50:  MOVLB  2
01C52:  MOVWF  xF3
01C54:  MOVLB  0
01C56:  CALL   1232
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
01C5A:  MOVLB  1
01C5C:  MOVFF  1B4,1B8
01C60:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01C62:  MOVFF  1B3,1B9
01C66:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01C68:  MOVFF  1B2,1BA
01C6C:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
01C6E:  MOVFF  1B1,1BB
01C72:  CLRF   03
....................      WRITE_ENABLE_OF_COM();  // Enable write operation
01C74:  MOVLB  0
01C76:  BRA    1BD8
....................  
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01C78:  BCF    F94.4
01C7A:  BCF    F8B.4
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
01C7C:  BCF    F93.3
01C7E:  BCF    F8A.3
....................      delay_us(2);  // Small delay for stabilization
01C80:  MOVLW  02
01C82:  MOVWF  00
01C84:  DECFSZ 00,F
01C86:  BRA    1C84
01C88:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT2, WRITE_PAGE);
01C8A:  MOVLW  12
01C8C:  MOVLB  2
01C8E:  MOVWF  xBD
01C90:  MOVLW  08
01C92:  MOVWF  xBE
01C94:  MOVLW  01
01C96:  MOVWF  xBF
01C98:  MOVLB  0
01C9A:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[0]);
01C9C:  MOVFF  1B8,2BD
01CA0:  MOVLW  08
01CA2:  MOVLB  2
01CA4:  MOVWF  xBE
01CA6:  MOVLW  01
01CA8:  MOVWF  xBF
01CAA:  MOVLB  0
01CAC:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[1]);
01CAE:  MOVFF  1B9,2BD
01CB2:  MOVLW  08
01CB4:  MOVLB  2
01CB6:  MOVWF  xBE
01CB8:  MOVLW  01
01CBA:  MOVWF  xBF
01CBC:  MOVLB  0
01CBE:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[2]);
01CC0:  MOVFF  1BA,2BD
01CC4:  MOVLW  08
01CC6:  MOVLB  2
01CC8:  MOVWF  xBE
01CCA:  MOVLW  01
01CCC:  MOVWF  xBF
01CCE:  MOVLB  0
01CD0:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[3]);
01CD2:  MOVFF  1BB,2BD
01CD6:  MOVLW  08
01CD8:  MOVLB  2
01CDA:  MOVWF  xBE
01CDC:  MOVLW  01
01CDE:  MOVWF  xBF
01CE0:  MOVLB  0
01CE2:  RCALL  1A28
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
01CE4:  MOVLB  1
01CE6:  CLRF   xBC
01CE8:  MOVF   xB7,W
01CEA:  SUBWF  xBC,W
01CEC:  BC    1D44
....................          spi_xfer(SPIPORT2, data[i]);  // Send data byte
01CEE:  MOVF   xBC,W
01CF0:  ADDWF  xB5,W
01CF2:  MOVWF  FE9
01CF4:  MOVLW  00
01CF6:  ADDWFC xB6,W
01CF8:  MOVWF  FEA
01CFA:  MOVFF  FEF,2BD
01CFE:  MOVLW  08
01D00:  MOVLB  2
01D02:  MOVWF  xBE
01D04:  MOVLW  01
01D06:  MOVWF  xBF
01D08:  MOVLB  0
01D0A:  RCALL  1A28
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
01D0C:  MOVLB  1
01D0E:  MOVF   xBC,W
01D10:  ADDWF  xB5,W
01D12:  MOVWF  FE9
01D14:  MOVLW  00
01D16:  ADDWFC xB6,W
01D18:  MOVWF  FEA
01D1A:  MOVFF  FEF,1BD
01D1E:  MOVLW  01
01D20:  MOVWF  xBE
01D22:  MOVLW  20
01D24:  MOVLB  2
01D26:  MOVWF  xF3
01D28:  MOVLB  0
01D2A:  CALL   1232
01D2E:  MOVLB  1
01D30:  DECFSZ xBE,F
01D32:  BRA    1D22
01D34:  MOVFF  1BD,2F3
01D38:  MOVLB  0
01D3A:  CALL   1232
01D3E:  MOVLB  1
01D40:  INCF   xBC,F
01D42:  BRA    1CE8
....................      }
....................      
....................      output_high(CS_PIN_COM);  // Deselect SPI devices
01D44:  BCF    F93.3
01D46:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  //Deselect MUX from flash
01D48:  BCF    F94.4
01D4A:  BSF    F8B.4
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN COM!\n", data_number);
01D4C:  MOVLW  0A
01D4E:  MOVLB  2
01D50:  MOVWF  xF3
01D52:  MOVLB  0
01D54:  CALL   1232
01D58:  MOVFF  1B7,2ED
01D5C:  MOVLW  18
01D5E:  MOVLB  2
01D60:  MOVWF  xEE
01D62:  MOVLB  0
01D64:  RCALL  1706
01D66:  MOVLW  5D
01D68:  MOVWF  FF6
01D6A:  MOVLW  00
01D6C:  MOVWF  FF7
01D6E:  MOVLW  00
01D70:  MOVWF  FF8
01D72:  MOVLW  17
01D74:  MOVLB  2
01D76:  MOVWF  xED
01D78:  MOVLB  0
01D7A:  CALL   13F0
01D7E:  GOTO   46F8 (RETURN)
....................  }
....................  
....................  void WRITE_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN ADCS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
03172:  MOVLW  76
03174:  MOVWF  FF6
03176:  MOVLW  00
03178:  MOVWF  FF7
0317A:  MOVLW  00
0317C:  MOVWF  FF8
0317E:  MOVLW  19
03180:  MOVLB  2
03182:  MOVWF  xED
03184:  MOVLB  0
03186:  CALL   13F0
0318A:  MOVFF  1C8,2ED
0318E:  MOVLW  57
03190:  MOVLB  2
03192:  MOVWF  xEE
03194:  MOVLB  0
03196:  CALL   16A2
0319A:  MOVFF  1C7,2ED
0319E:  MOVLW  57
031A0:  MOVLB  2
031A2:  MOVWF  xEE
031A4:  MOVLB  0
031A6:  CALL   16A2
031AA:  MOVFF  1C6,2ED
031AE:  MOVLW  57
031B0:  MOVLB  2
031B2:  MOVWF  xEE
031B4:  MOVLB  0
031B6:  CALL   16A2
031BA:  MOVFF  1C5,2ED
031BE:  MOVLW  57
031C0:  MOVLB  2
031C2:  MOVWF  xEE
031C4:  MOVLB  0
031C6:  CALL   16A2
031CA:  MOVLW  0A
031CC:  MOVLB  2
031CE:  MOVWF  xF3
031D0:  MOVLB  0
031D2:  CALL   1232
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
031D6:  MOVLB  1
031D8:  MOVFF  1C8,1CC
031DC:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
031DE:  MOVFF  1C7,1CD
031E2:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
031E4:  MOVFF  1C6,1CE
031E8:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
031EA:  MOVFF  1C5,1CF
031EE:  CLRF   03
....................      WRITE_ENABLE_OF_ADCS();  // Enable write operation and MX and CS pins are included in here 
031F0:  MOVLB  0
031F2:  RCALL  30A0
....................  
....................      //Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
031F4:  BCF    F92.5
031F6:  BCF    F89.5
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
031F8:  BCF    F92.2
031FA:  BCF    F89.2
....................      delay_us(2);  // Small delay for stabilization
031FC:  MOVLW  02
031FE:  MOVWF  00
03200:  DECFSZ 00,F
03202:  BRA    3200
03204:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT3, WRITE_PAGE);
03206:  MOVLW  12
03208:  MOVLB  1
0320A:  MOVWF  xD2
0320C:  MOVLW  08
0320E:  MOVWF  xD3
03210:  MOVLW  01
03212:  MOVWF  xD4
03214:  MOVLB  0
03216:  CALL   1B02
....................      spi_xfer(SPIPORT3, adsress[0]);
0321A:  MOVFF  1CC,1D2
0321E:  MOVLW  08
03220:  MOVLB  1
03222:  MOVWF  xD3
03224:  MOVLW  01
03226:  MOVWF  xD4
03228:  MOVLB  0
0322A:  CALL   1B02
....................      spi_xfer(SPIPORT3, adsress[1]);
0322E:  MOVFF  1CD,1D2
03232:  MOVLW  08
03234:  MOVLB  1
03236:  MOVWF  xD3
03238:  MOVLW  01
0323A:  MOVWF  xD4
0323C:  MOVLB  0
0323E:  CALL   1B02
....................      spi_xfer(SPIPORT3, adsress[2]);
03242:  MOVFF  1CE,1D2
03246:  MOVLW  08
03248:  MOVLB  1
0324A:  MOVWF  xD3
0324C:  MOVLW  01
0324E:  MOVWF  xD4
03250:  MOVLB  0
03252:  CALL   1B02
....................      spi_xfer(SPIPORT3, adsress[3]);
03256:  MOVFF  1CF,1D2
0325A:  MOVLW  08
0325C:  MOVLB  1
0325E:  MOVWF  xD3
03260:  MOVLW  01
03262:  MOVWF  xD4
03264:  MOVLB  0
03266:  CALL   1B02
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
0326A:  MOVLB  1
0326C:  CLRF   xD0
0326E:  MOVF   xCB,W
03270:  SUBWF  xD0,W
03272:  BC    32CA
....................          spi_xfer(SPIPORT3, data[i]);  // Send data byte
03274:  MOVF   xD0,W
03276:  ADDWF  xC9,W
03278:  MOVWF  FE9
0327A:  MOVLW  00
0327C:  ADDWFC xCA,W
0327E:  MOVWF  FEA
03280:  MOVFF  FEF,1D2
03284:  MOVLW  08
03286:  MOVWF  xD3
03288:  MOVLW  01
0328A:  MOVWF  xD4
0328C:  MOVLB  0
0328E:  CALL   1B02
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
03292:  MOVLB  1
03294:  MOVF   xD0,W
03296:  ADDWF  xC9,W
03298:  MOVWF  FE9
0329A:  MOVLW  00
0329C:  ADDWFC xCA,W
0329E:  MOVWF  FEA
032A0:  MOVFF  FEF,1D1
032A4:  MOVLW  01
032A6:  MOVWF  xD2
032A8:  MOVLW  20
032AA:  MOVLB  2
032AC:  MOVWF  xF3
032AE:  MOVLB  0
032B0:  CALL   1232
032B4:  MOVLB  1
032B6:  DECFSZ xD2,F
032B8:  BRA    32A8
032BA:  MOVFF  1D1,2F3
032BE:  MOVLB  0
032C0:  CALL   1232
032C4:  MOVLB  1
032C6:  INCF   xD0,F
032C8:  BRA    326E
....................      }
....................      
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device5
032CA:  BCF    F92.2
032CC:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
032CE:  BCF    F92.5
032D0:  BSF    F89.5
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN ADCS!\n", data_number);
032D2:  MOVLW  0A
032D4:  MOVLB  2
032D6:  MOVWF  xF3
032D8:  MOVLB  0
032DA:  CALL   1232
032DE:  MOVFF  1CB,2ED
032E2:  MOVLW  18
032E4:  MOVLB  2
032E6:  MOVWF  xEE
032E8:  MOVLB  0
032EA:  CALL   1706
032EE:  MOVLW  99
032F0:  MOVWF  FF6
032F2:  MOVLW  00
032F4:  MOVWF  FF7
032F6:  MOVLW  00
032F8:  MOVWF  FF8
032FA:  MOVLW  18
032FC:  MOVLB  2
032FE:  MOVWF  xED
03300:  MOVLB  0
03302:  CALL   13F0
03306:  GOTO   34D2 (RETURN)
....................  }
....................   
....................  
....................  char* READ_DATA_NBYTES(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  
....................  
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
015B4:  MOVFF  1DD,00
015B8:  MOVLB  2
015BA:  MOVFF  00,1DF
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
015BE:  MOVFF  1DC,00
015C2:  MOVFF  1DD,2E6
015C6:  MOVFF  00,1E0
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
015CA:  MOVFF  1DB,00
015CE:  MOVFF  1DC,2E6
015D2:  MOVFF  1DD,2E7
015D6:  MOVFF  00,1E1
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
015DA:  MOVLB  1
015DC:  MOVFF  1DA,1E2
015E0:  CLRF   03
....................  
....................      output_low(CS_PIN_1);  // Select SPI device
015E2:  BCF    F96.2
015E4:  BCF    F8D.2
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(SPIPORT, READ_DATA_BYTES);
015E6:  MOVLW  13
015E8:  MOVLB  2
015EA:  MOVWF  xEE
015EC:  MOVLW  08
015EE:  MOVWF  xEF
015F0:  MOVLW  01
015F2:  MOVWF  xF0
015F4:  MOVLB  0
015F6:  RCALL  1568
....................      // Send address bytes
....................      spi_xfer(SPIPORT, adsress[0]);
015F8:  MOVFF  1DF,2EE
015FC:  MOVLW  08
015FE:  MOVLB  2
01600:  MOVWF  xEF
01602:  MOVLW  01
01604:  MOVWF  xF0
01606:  MOVLB  0
01608:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[1]);
0160A:  MOVFF  1E0,2EE
0160E:  MOVLW  08
01610:  MOVLB  2
01612:  MOVWF  xEF
01614:  MOVLW  01
01616:  MOVWF  xF0
01618:  MOVLB  0
0161A:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[2]);
0161C:  MOVFF  1E1,2EE
01620:  MOVLW  08
01622:  MOVLB  2
01624:  MOVWF  xEF
01626:  MOVLW  01
01628:  MOVWF  xF0
0162A:  MOVLB  0
0162C:  RCALL  1568
....................      spi_xfer(SPIPORT, adsress[3]);
0162E:  MOVFF  1E2,2EE
01632:  MOVLW  08
01634:  MOVLB  2
01636:  MOVWF  xEF
01638:  MOVLW  01
0163A:  MOVWF  xF0
0163C:  MOVLB  0
0163E:  RCALL  1568
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {  // Avoid overflow
01640:  MOVLB  2
01642:  CLRF   xE3
01644:  MOVLB  1
01646:  MOVF   xDE,W
01648:  MOVLB  2
0164A:  SUBWF  xE3,W
0164C:  BC    168C
....................          Data_return[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy byte to receive data
0164E:  CLRF   03
01650:  MOVF   xE3,W
01652:  ADDLW  E3
01654:  MOVWF  FE9
01656:  MOVLW  01
01658:  ADDWFC 03,W
0165A:  MOVWF  FEA
0165C:  CLRF   xEE
0165E:  MOVLW  08
01660:  MOVWF  xEF
01662:  MOVLW  01
01664:  MOVWF  xF0
01666:  MOVLB  0
01668:  RCALL  1568
0166A:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);  // Print each byte as hex
0166E:  CLRF   03
01670:  MOVLB  2
01672:  MOVF   xE3,W
01674:  ADDLW  E3
01676:  MOVWF  FE9
01678:  MOVLW  01
0167A:  ADDWFC 03,W
0167C:  MOVWF  FEA
0167E:  MOVFF  FEF,2F3
01682:  MOVLB  0
01684:  RCALL  1232
01686:  MOVLB  2
01688:  INCF   xE3,F
0168A:  BRA    1644
....................      }
....................  
....................      output_high(CS_PIN_1);  // Deselect SPI device after reading
0168C:  BCF    F96.2
0168E:  BSF    F8D.2
....................      fprintf(EXT, "\n");
01690:  MOVLW  0A
01692:  MOVWF  xF3
01694:  MOVLB  0
01696:  RCALL  1232
....................  
....................      return Data_return;
01698:  MOVLW  E3
0169A:  MOVWF  01
0169C:  MOVLW  01
0169E:  MOVWF  02
016A0:  RETURN 0
....................  }
....................  
....................  
....................  
....................  char* READ_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  // 
....................      
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
01D82:  MOVFF  1B4,00
01D86:  MOVLB  2
01D88:  MOVFF  00,1B6
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01D8C:  MOVFF  1B3,00
01D90:  MOVFF  1B4,2BD
01D94:  MOVFF  00,1B7
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01D98:  MOVFF  1B2,00
01D9C:  MOVFF  1B3,2BD
01DA0:  MOVFF  1B4,2BE
01DA4:  MOVFF  00,1B8
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
01DA8:  MOVLB  1
01DAA:  MOVFF  1B1,1B9
01DAE:  CLRF   03
....................  
....................      output_low(MX_PIN_COM);  // Lower MX to connect to flash device
01DB0:  BCF    F94.4
01DB2:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Select SPI device
01DB4:  BCF    F93.3
01DB6:  BCF    F8A.3
....................  
....................      // Send READ DATA COMMAND
....................      spi_xfer(SPIPORT2, READ_DATA_BYTES);
01DB8:  MOVLW  13
01DBA:  MOVLB  2
01DBC:  MOVWF  xBD
01DBE:  MOVLW  08
01DC0:  MOVWF  xBE
01DC2:  MOVLW  01
01DC4:  MOVWF  xBF
01DC6:  MOVLB  0
01DC8:  RCALL  1A28
....................      // Send address bytes
....................      spi_xfer(SPIPORT2, adsress[0]);
01DCA:  MOVFF  1B6,2BD
01DCE:  MOVLW  08
01DD0:  MOVLB  2
01DD2:  MOVWF  xBE
01DD4:  MOVLW  01
01DD6:  MOVWF  xBF
01DD8:  MOVLB  0
01DDA:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[1]);
01DDC:  MOVFF  1B7,2BD
01DE0:  MOVLW  08
01DE2:  MOVLB  2
01DE4:  MOVWF  xBE
01DE6:  MOVLW  01
01DE8:  MOVWF  xBF
01DEA:  MOVLB  0
01DEC:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[2]);
01DEE:  MOVFF  1B8,2BD
01DF2:  MOVLW  08
01DF4:  MOVLB  2
01DF6:  MOVWF  xBE
01DF8:  MOVLW  01
01DFA:  MOVWF  xBF
01DFC:  MOVLB  0
01DFE:  RCALL  1A28
....................      spi_xfer(SPIPORT2, adsress[3]);
01E00:  MOVFF  1B9,2BD
01E04:  MOVLW  08
01E06:  MOVLB  2
01E08:  MOVWF  xBE
01E0A:  MOVLW  01
01E0C:  MOVWF  xBF
01E0E:  MOVLB  0
01E10:  RCALL  1A28
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {
01E12:  MOVLB  2
01E14:  CLRF   xBA
01E16:  MOVLB  1
01E18:  MOVF   xB5,W
01E1A:  MOVLB  2
01E1C:  SUBWF  xBA,W
01E1E:  BC    1E60
....................          Data_return[i] = spi_xfer(SPIPORT2, 0x00);  // Send dummy byte to receive data
01E20:  CLRF   03
01E22:  MOVF   xBA,W
01E24:  ADDLW  BA
01E26:  MOVWF  FE9
01E28:  MOVLW  01
01E2A:  ADDWFC 03,W
01E2C:  MOVWF  FEA
01E2E:  CLRF   xBD
01E30:  MOVLW  08
01E32:  MOVWF  xBE
01E34:  MOVLW  01
01E36:  MOVWF  xBF
01E38:  MOVLB  0
01E3A:  RCALL  1A28
01E3C:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);         // Print each byte
01E40:  CLRF   03
01E42:  MOVLB  2
01E44:  MOVF   xBA,W
01E46:  ADDLW  BA
01E48:  MOVWF  FE9
01E4A:  MOVLW  01
01E4C:  ADDWFC 03,W
01E4E:  MOVWF  FEA
01E50:  MOVFF  FEF,2F3
01E54:  MOVLB  0
01E56:  CALL   1232
01E5A:  MOVLB  2
01E5C:  INCF   xBA,F
01E5E:  BRA    1E16
....................      }
....................  
....................      output_high(CS_PIN_COM);  // Deselect SPI device
01E60:  BCF    F93.3
01E62:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  // Deselect MUX from flash
01E64:  BCF    F94.4
01E66:  BSF    F8B.4
....................      fprintf(EXT, "\n");
01E68:  MOVLW  0A
01E6A:  MOVWF  xF3
01E6C:  MOVLB  0
01E6E:  CALL   1232
....................  
....................      return Data_return;
01E72:  MOVLW  BA
01E74:  MOVWF  01
01E76:  MOVLW  01
01E78:  MOVWF  02
01E7A:  GOTO   4722 (RETURN)
....................  }
.................... 
.................... #define MAX_DATA_SIZE 256  // Define the maximum data size
.................... 
.................... unsigned int8 Data_return[MAX_DATA_SIZE];  // Static buffer to hold the data
.................... 
.................... unsigned int8* READ_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned short data_number) {
....................     unsigned int8 adsress[4];
.................... 
....................     // Ensure data_number does not exceed the maximum buffer size
....................     if (data_number > MAX_DATA_SIZE) {
....................         data_number = MAX_DATA_SIZE;
....................     }
.................... 
....................     // Byte extraction for a 32-bit address
....................     adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
0330A:  MOVLB  1
0330C:  MOVFF  1C8,1CA
03310:  CLRF   03
....................     adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
03312:  MOVFF  1C7,1CB
03316:  CLRF   03
....................     adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
03318:  MOVFF  1C6,1CC
0331C:  CLRF   03
....................     adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
0331E:  MOVFF  1C5,1CD
03322:  CLRF   03
.................... 
....................     output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
03324:  BCF    F92.5
03326:  BCF    F89.5
....................     output_low(CS_PIN_MISSION);  // Select SPI device
03328:  BCF    F92.2
0332A:  BCF    F89.2
.................... 
....................     // Send READ DATA COMMAND
....................     spi_xfer(SPIPORT3, READ_DATA_BYTES);
0332C:  MOVLW  13
0332E:  MOVWF  xD2
03330:  MOVLW  08
03332:  MOVWF  xD3
03334:  MOVLW  01
03336:  MOVWF  xD4
03338:  MOVLB  0
0333A:  CALL   1B02
....................     // Send address bytes
....................     spi_xfer(SPIPORT3, adsress[0]);
0333E:  MOVFF  1CA,1D2
03342:  MOVLW  08
03344:  MOVLB  1
03346:  MOVWF  xD3
03348:  MOVLW  01
0334A:  MOVWF  xD4
0334C:  MOVLB  0
0334E:  CALL   1B02
....................     spi_xfer(SPIPORT3, adsress[1]);
03352:  MOVFF  1CB,1D2
03356:  MOVLW  08
03358:  MOVLB  1
0335A:  MOVWF  xD3
0335C:  MOVLW  01
0335E:  MOVWF  xD4
03360:  MOVLB  0
03362:  CALL   1B02
....................     spi_xfer(SPIPORT3, adsress[2]);
03366:  MOVFF  1CC,1D2
0336A:  MOVLW  08
0336C:  MOVLB  1
0336E:  MOVWF  xD3
03370:  MOVLW  01
03372:  MOVWF  xD4
03374:  MOVLB  0
03376:  CALL   1B02
....................     spi_xfer(SPIPORT3, adsress[3]);
0337A:  MOVFF  1CD,1D2
0337E:  MOVLW  08
03380:  MOVLB  1
03382:  MOVWF  xD3
03384:  MOVLW  01
03386:  MOVWF  xD4
03388:  MOVLB  0
0338A:  CALL   1B02
.................... 
....................     // Read the requested number of bytes
....................     for (int i = 0; i < data_number; i++) {
0338E:  MOVLB  1
03390:  CLRF   xCE
03392:  MOVF   xC9,W
03394:  SUBWF  xCE,W
03396:  BC    3408
....................         Data_return[i] = spi_xfer(SPIPORT3, 0x00);  // Send dummy byte to receive data
03398:  CLRF   03
0339A:  MOVF   xCE,W
0339C:  ADDLW  06
0339E:  MOVWF  FE9
033A0:  MOVLW  00
033A2:  ADDWFC 03,W
033A4:  MOVWF  FEA
033A6:  CLRF   xD2
033A8:  MOVLW  08
033AA:  MOVWF  xD3
033AC:  MOVLW  01
033AE:  MOVWF  xD4
033B0:  MOVLB  0
033B2:  CALL   1B02
033B6:  MOVFF  01,FEF
....................         fprintf(EXT, "  0x%02x", Data_return[i]);  // Print each byte (optional)
033BA:  CLRF   03
033BC:  MOVLB  1
033BE:  MOVF   xCE,W
033C0:  ADDLW  06
033C2:  MOVWF  FE9
033C4:  MOVLW  00
033C6:  ADDWFC 03,W
033C8:  MOVWF  FEA
033CA:  MOVFF  FEF,1CF
033CE:  MOVLW  B2
033D0:  MOVWF  FF6
033D2:  MOVLW  00
033D4:  MOVWF  FF7
033D6:  MOVLW  00
033D8:  MOVWF  FF8
033DA:  MOVLW  04
033DC:  MOVLB  2
033DE:  MOVWF  xED
033E0:  MOVLB  0
033E2:  CALL   13F0
033E6:  MOVFF  1CF,2ED
033EA:  MOVLW  57
033EC:  MOVLB  2
033EE:  MOVWF  xEE
033F0:  MOVLB  0
033F2:  CALL   16A2
....................         fprintf(EXT, "\n");
033F6:  MOVLW  0A
033F8:  MOVLB  2
033FA:  MOVWF  xF3
033FC:  MOVLB  0
033FE:  CALL   1232
03402:  MOVLB  1
03404:  INCF   xCE,F
03406:  BRA    3392
....................     }
.................... 
....................     output_high(CS_PIN_MISSION);  // Deselect SPI device
03408:  BCF    F92.2
0340A:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);  // Deselect MUX from flash
0340C:  BCF    F92.5
0340E:  BSF    F89.5
....................     fprintf(EXT, "\n");
03410:  MOVLW  0A
03412:  MOVLB  2
03414:  MOVWF  xF3
03416:  MOVLB  0
03418:  CALL   1232
.................... 
....................     return Data_return;
0341C:  MOVLW  06
0341E:  MOVWF  01
03420:  MOVLW  00
03422:  MOVWF  02
03424:  RETURN 0
.................... }
....................  
....................  
....................  int8 READ_DATA_BYTES_ADCS(unsigned int32 ADDRESS) {
....................      unsigned int8 adsress[4];
....................      unsigned int8 Data_return;
....................     
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
....................  
....................      output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
....................      output_low(CS_PIN_MISSION);  // Select SPI device
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(SPIPORT3, READ_DATA_BYTES);
....................      // Send address bytes
....................      spi_xfer(SPIPORT3, adsress[0]);
....................      spi_xfer(SPIPORT3, adsress[1]);
....................      spi_xfer(SPIPORT3, adsress[2]);
....................      spi_xfer(SPIPORT3, adsress[3]);
....................      // Read the requested number of bytes
....................          Data_return = spi_xfer(SPIPORT3, 0x00);  // Send dummy byte to receive data
....................  
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device after reading
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
....................      return Data_return;
....................  }
....................  void READ_CHIP_ID_OF() {
....................      int8 chip_id[8];
....................      output_low(CS_PIN_1);  // Lower the CS PIN
*
0230E:  BCF    F96.2
02310:  BCF    F8D.2
....................      spi_xfer(SPIPORT, READ_ID);  // READ ID COMMAND (0x9F)
02312:  MOVLW  9F
02314:  MOVLB  2
02316:  MOVWF  xEE
02318:  MOVLW  08
0231A:  MOVWF  xEF
0231C:  MOVLW  01
0231E:  MOVWF  xF0
02320:  MOVLB  0
02322:  CALL   1568
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
02326:  MOVLB  1
02328:  CLRF   xE2
0232A:  MOVF   xE2,W
0232C:  SUBLW  07
0232E:  BNC   2386
....................          chip_id[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy bytes to receive data
02330:  CLRF   03
02332:  MOVF   xE2,W
02334:  ADDLW  DA
02336:  MOVWF  FE9
02338:  MOVLW  01
0233A:  ADDWFC 03,W
0233C:  MOVWF  FEA
0233E:  MOVLB  2
02340:  CLRF   xEE
02342:  MOVLW  08
02344:  MOVWF  xEF
02346:  MOVLW  01
02348:  MOVWF  xF0
0234A:  MOVLB  0
0234C:  CALL   1568
02350:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
02354:  CLRF   03
02356:  MOVLB  1
02358:  MOVF   xE2,W
0235A:  ADDLW  DA
0235C:  MOVWF  FE9
0235E:  MOVLW  01
02360:  ADDWFC 03,W
02362:  MOVWF  FEA
02364:  MOVFF  FEF,2ED
02368:  MOVLW  37
0236A:  MOVLB  2
0236C:  MOVWF  xEE
0236E:  MOVLB  0
02370:  CALL   16A2
02374:  MOVLW  20
02376:  MOVLB  2
02378:  MOVWF  xF3
0237A:  MOVLB  0
0237C:  CALL   1232
02380:  MOVLB  1
02382:  INCF   xE2,F
02384:  BRA    232A
....................      }
....................      fprintf(EXT,"\n");
02386:  MOVLW  0A
02388:  MOVLB  2
0238A:  MOVWF  xF3
0238C:  MOVLB  0
0238E:  CALL   1232
....................  
....................      output_high(CS_PIN_1);  // Raise CS PIN back
02392:  BCF    F96.2
02394:  BSF    F8D.2
02396:  GOTO   2A52 (RETURN)
....................  }
....................  void READ_CHIP_ID_OF_COM() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_COM);
*
01A74:  BCF    F94.4
01A76:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Lower the CS PIN
01A78:  BCF    F93.3
01A7A:  BCF    F8A.3
....................      spi_xfer(SPIPORT2, READ_ID);  // READ ID COMMAND (0x9F)
01A7C:  MOVLW  9F
01A7E:  MOVLB  2
01A80:  MOVWF  xBD
01A82:  MOVLW  08
01A84:  MOVWF  xBE
01A86:  MOVLW  01
01A88:  MOVWF  xBF
01A8A:  MOVLB  0
01A8C:  RCALL  1A28
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01A8E:  MOVLB  1
01A90:  CLRF   xB9
01A92:  MOVF   xB9,W
01A94:  SUBLW  07
01A96:  BNC   1AEA
....................          chip_id[i] = spi_xfer(SPIPORT2, 0x00);  // Send dummy bytes to receive data
01A98:  CLRF   03
01A9A:  MOVF   xB9,W
01A9C:  ADDLW  B1
01A9E:  MOVWF  FE9
01AA0:  MOVLW  01
01AA2:  ADDWFC 03,W
01AA4:  MOVWF  FEA
01AA6:  MOVLB  2
01AA8:  CLRF   xBD
01AAA:  MOVLW  08
01AAC:  MOVWF  xBE
01AAE:  MOVLW  01
01AB0:  MOVWF  xBF
01AB2:  MOVLB  0
01AB4:  RCALL  1A28
01AB6:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01ABA:  CLRF   03
01ABC:  MOVLB  1
01ABE:  MOVF   xB9,W
01AC0:  ADDLW  B1
01AC2:  MOVWF  FE9
01AC4:  MOVLW  01
01AC6:  ADDWFC 03,W
01AC8:  MOVWF  FEA
01ACA:  MOVFF  FEF,2ED
01ACE:  MOVLW  37
01AD0:  MOVLB  2
01AD2:  MOVWF  xEE
01AD4:  MOVLB  0
01AD6:  RCALL  16A2
01AD8:  MOVLW  20
01ADA:  MOVLB  2
01ADC:  MOVWF  xF3
01ADE:  MOVLB  0
01AE0:  CALL   1232
01AE4:  MOVLB  1
01AE6:  INCF   xB9,F
01AE8:  BRA    1A92
....................      }
....................      fprintf(EXT,"\n");
01AEA:  MOVLW  0A
01AEC:  MOVLB  2
01AEE:  MOVWF  xF3
01AF0:  MOVLB  0
01AF2:  CALL   1232
....................  
....................      output_high(CS_PIN_COM);  // Raise CS PIN back
01AF6:  BCF    F93.3
01AF8:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01AFA:  BCF    F94.4
01AFC:  BSF    F8B.4
01AFE:  GOTO   45F4 (RETURN)
....................  }
....................  
....................  void READ_CHIP_ID_OF_ADCS() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_ADCS);
*
01B4E:  BCF    F92.5
01B50:  BCF    F89.5
....................      output_low(CS_PIN_MISSION);  // Lower the CS PIN
01B52:  BCF    F92.2
01B54:  BCF    F89.2
....................      spi_xfer(SPIPORT3, READ_ID);  // READ ID COMMAND (0x9F)
01B56:  MOVLW  9F
01B58:  MOVLB  1
01B5A:  MOVWF  xD2
01B5C:  MOVLW  08
01B5E:  MOVWF  xD3
01B60:  MOVLW  01
01B62:  MOVWF  xD4
01B64:  MOVLB  0
01B66:  RCALL  1B02
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01B68:  MOVLB  1
01B6A:  CLRF   xCD
01B6C:  MOVF   xCD,W
01B6E:  SUBLW  07
01B70:  BNC   1BC2
....................          chip_id[i] = spi_xfer(SPIPORT3, 0x00);  // Send dummy bytes to receive data
01B72:  CLRF   03
01B74:  MOVF   xCD,W
01B76:  ADDLW  C5
01B78:  MOVWF  FE9
01B7A:  MOVLW  01
01B7C:  ADDWFC 03,W
01B7E:  MOVWF  FEA
01B80:  CLRF   xD2
01B82:  MOVLW  08
01B84:  MOVWF  xD3
01B86:  MOVLW  01
01B88:  MOVWF  xD4
01B8A:  MOVLB  0
01B8C:  RCALL  1B02
01B8E:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01B92:  CLRF   03
01B94:  MOVLB  1
01B96:  MOVF   xCD,W
01B98:  ADDLW  C5
01B9A:  MOVWF  FE9
01B9C:  MOVLW  01
01B9E:  ADDWFC 03,W
01BA0:  MOVWF  FEA
01BA2:  MOVFF  FEF,2ED
01BA6:  MOVLW  37
01BA8:  MOVLB  2
01BAA:  MOVWF  xEE
01BAC:  MOVLB  0
01BAE:  RCALL  16A2
01BB0:  MOVLW  20
01BB2:  MOVLB  2
01BB4:  MOVWF  xF3
01BB6:  MOVLB  0
01BB8:  CALL   1232
01BBC:  MOVLB  1
01BBE:  INCF   xCD,F
01BC0:  BRA    1B6C
....................      }
....................      fprintf(EXT,"\n");
01BC2:  MOVLW  0A
01BC4:  MOVLB  2
01BC6:  MOVWF  xF3
01BC8:  MOVLB  0
01BCA:  CALL   1232
....................  
....................      output_high(CS_PIN_MISSION);  // Raise CS PIN back
01BCE:  BCF    F92.2
01BD0:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
01BD2:  BCF    F92.5
01BD4:  BSF    F89.5
01BD6:  RETURN 0
....................  }
.................... //  void READ_CHIP_ID_GENERIC(int SPIPORT, int CS_PIN, int MX_PIN) {
.................... //     int8 chip_id[8];
.................... 
.................... //     // Lower MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_low(MX_PIN);
.................... //     }
.................... 
.................... //     // Lower CS to select the SPI device
.................... //     output_low(CS_PIN);
.................... 
.................... //     // Send READ ID command
.................... //     spi_xfer(SPIPORT, READ_ID);
.................... 
.................... //     // Receive 8 bytes of chip ID
.................... //     for (int i = 0; i < 8; i++) {
.................... //         chip_id[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy bytes to receive data
.................... //         fprintf(EXT, "%02X ", chip_id[i]);    // Print each byte in hex
.................... //     }
.................... //     fprintf(EXT, "\n");
.................... 
.................... //     // Raise CS to deselect the SPI device
.................... //     output_high(CS_PIN);
.................... 
.................... //     // Raise MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_high(MX_PIN);
.................... //     }
.................... // }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //Command operation
....................  //void SEND_COMMAND_ADCS(void){
....................  //    WRITE_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS, ADCS_COMMAND,1);
....................  //}
....................  ////void READ_HK_ADCS(void){
....................  ////    int8 state_of_pin = 0;
....................  ////    
....................  ////    state_of_pin = input_state(EN_SUP_3V3_2);
....................  ////    if(state_of_pin = FALSE){ 
....................  ////        READ_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS[16], READ_HK_ADCS, 16);
....................  ////        
....................  ////    }
....................  ////}
....................  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  ////EEPROM operation 
....................  ////thus functions used to store essential data order to prevent loosing it in unexpected shutdowns  
....................  //void EEPROM_
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // Main menu functions
....................  
....................  void startup_freeze(){
....................      delay_ms(2000);
*
012A0:  MOVLW  08
012A2:  MOVLB  1
012A4:  MOVWF  xB1
012A6:  MOVLW  FA
012A8:  MOVWF  xCD
012AA:  MOVLB  0
012AC:  RCALL  1208
012AE:  MOVLB  1
012B0:  DECFSZ xB1,F
012B2:  BRA    12A6
....................      fprintf(EXT, "POWER ON!\n");
012B4:  MOVLW  BC
012B6:  MOVWF  FF6
012B8:  MOVLW  00
012BA:  MOVWF  FF7
012BC:  MOVLW  00
012BE:  MOVWF  FF8
012C0:  MOVLB  0
012C2:  RCALL  1278
....................      //EPS power control all disabled when startup, using menu function will turn on
....................      output_low(EN_SUP_3V3_1);
012C4:  BCF    F93.0
012C6:  BCF    F8A.0
....................      output_low(EN_SUP_3V3_2 );
012C8:  BCF    F98.1
012CA:  BCF    F8F.1
....................      output_low(EN_SUP_3V3_DAQ);
012CC:  BCF    F95.0
012CE:  BCF    F8C.0
....................      output_low(EN_SUP_UNREG);
012D0:  BCF    F93.1
012D2:  BCF    F8A.1
....................      output_low(EN_SUP_5V0);
012D4:  BCF    F95.1
012D6:  BCF    F8C.1
....................      output_low(MVCAM_PWR);
012D8:  BCF    F98.0
012DA:  BCF    F8F.0
....................      output_low(OVCAM_PWR);
012DC:  BCF    F95.7
012DE:  BCF    F8C.7
....................      output_low(ADCS_PWR); //turns on the power of ADCS instantly 
012E0:  BCF    F95.6
012E2:  BCF    F8C.6
....................      output_high(CS_PIN_1);
012E4:  BCF    F96.2
012E6:  BSF    F8D.2
....................      output_high(CS_PIN_COM );
012E8:  BCF    F93.3
012EA:  BSF    F8A.3
....................      output_high(CS_PIN_MISSION );
012EC:  BCF    F92.2
012EE:  BSF    F89.2
....................      output_high(MX_PIN_OVCAM );
012F0:  BCF    F98.2
012F2:  BSF    F8F.2
....................      output_high(MX_PIN_MVCAM );
012F4:  BCF    F98.3
012F6:  BSF    F8F.3
....................      output_high(MX_PIN_ADCS );
012F8:  BCF    F92.5
012FA:  BSF    F89.5
....................      output_high(MX_PIN_COM );
012FC:  BCF    F94.4
012FE:  BSF    F8B.4
....................      
....................      fprintf(EXT, "Digital pin out configured \n");
01300:  MOVLW  C8
01302:  MOVWF  FF6
01304:  MOVLW  00
01306:  MOVWF  FF7
01308:  MOVLW  00
0130A:  MOVWF  FF8
0130C:  RCALL  1278
0130E:  GOTO   45C8 (RETURN)
....................          
....................  }
....................  //set RTCC functions counting to all zero 
....................  void set_clock(rtc_time_t &date_time){
....................  
....................     date_time.tm_year=0000;
*
01446:  MOVLB  1
01448:  CLRF   xB1
*
02CDA:  MOVLB  1
02CDC:  CLRF   xB3
....................     date_time.tm_mon=00;
*
0144A:  CLRF   xB4
*
02CDE:  CLRF   xB6
....................     date_time.tm_mday=00;
*
0144C:  CLRF   xB3
*
02CE0:  CLRF   xB5
....................     date_time.tm_wday=00;
*
0144E:  CLRF   xB6
*
02CE2:  CLRF   xB8
....................     date_time.tm_hour=00;
*
01450:  CLRF   xB5
*
02CE4:  CLRF   xB7
....................     date_time.tm_min=00;
*
01452:  CLRF   xB8
*
02CE6:  CLRF   xBA
....................     date_time.tm_sec=0; 
*
01454:  CLRF   xB7
01456:  MOVLB  F
*
02CE8:  CLRF   xB9
02CEA:  MOVLB  F
....................  }
.................... 
....................  void RTC_initialize(){
....................      setup_lcd(LCD_DISABLED);
*
01420:  MOVLB  E
01422:  CLRF   xD6
01424:  CLRF   xD7
01426:  CLRF   xDA
01428:  CLRF   xD8
0142A:  CLRF   xD9
0142C:  MOVLB  F
....................      rtc_time_t write_clock, read_clock;
....................      setup_rtc(RTC_ENABLE | RTC_CLOCK_SOSC | RTC_CLOCK_INT, 0);
0142E:  MOVLB  F
01430:  MOVLW  55
01432:  MOVWF  F7E
01434:  MOVLW  AA
01436:  MOVWF  F7E
01438:  BSF    x5F.5
0143A:  CLRF   x5E
0143C:  MOVLW  04
0143E:  MOVWF  x57
01440:  MOVLW  80
01442:  MOVWF  x5F
01444:  BCF    x5F.5
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
01458:  MOVLB  F
0145A:  MOVLW  55
0145C:  MOVWF  F7E
0145E:  MOVLW  AA
01460:  MOVWF  F7E
01462:  BSF    x5F.5
01464:  BSF    x5F.0
01466:  BSF    x5F.1
01468:  MOVLW  01
0146A:  MOVWF  FEA
0146C:  MOVLW  B1
0146E:  MOVWF  FE9
01470:  MOVLW  04
01472:  MOVWF  01
01474:  MOVF   FEE,W
01476:  MOVLB  0
01478:  RCALL  1312
0147A:  MOVLB  F
0147C:  MOVWF  x5C
0147E:  MOVF   FEE,W
01480:  MOVLB  0
01482:  RCALL  1312
01484:  MOVLB  F
01486:  MOVWF  x5D
01488:  DECFSZ 01,F
0148A:  BRA    1474
0148C:  BCF    x5F.5
....................      rtc_read(&read_clock);
0148E:  BSF    x5F.0
01490:  BSF    x5F.1
01492:  MOVLW  01
01494:  MOVWF  FEA
01496:  MOVLW  BA
01498:  MOVWF  FE9
0149A:  MOVLW  04
0149C:  MOVWF  01
0149E:  MOVF   x5C,W
014A0:  MOVLB  0
014A2:  RCALL  1336
014A4:  MOVWF  FEE
014A6:  MOVLB  F
014A8:  MOVF   x5D,W
014AA:  MOVLB  0
014AC:  RCALL  1336
014AE:  MOVWF  FEE
014B0:  DECFSZ 01,F
014B2:  BRA    14B6
014B4:  BRA    14BA
014B6:  MOVLB  F
014B8:  BRA    149E
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
014BA:  MOVLW  0D
014BC:  MOVLB  2
014BE:  MOVWF  xF3
014C0:  MOVLB  0
014C2:  RCALL  1232
014C4:  MOVFF  1BD,1C5
014C8:  MOVLW  01
014CA:  MOVLB  1
014CC:  MOVWF  xC6
014CE:  MOVLB  0
014D0:  RCALL  1374
014D2:  MOVLW  2F
014D4:  MOVLB  2
014D6:  MOVWF  xF3
014D8:  MOVLB  0
014DA:  RCALL  1232
014DC:  MOVFF  1BC,1C5
014E0:  MOVLW  01
014E2:  MOVLB  1
014E4:  MOVWF  xC6
014E6:  MOVLB  0
014E8:  RCALL  1374
014EA:  MOVLW  F0
014EC:  MOVWF  FF6
014EE:  MOVLW  00
014F0:  MOVWF  FF7
014F2:  MOVLW  00
014F4:  MOVWF  FF8
014F6:  MOVLW  03
014F8:  MOVLB  2
014FA:  MOVWF  xED
014FC:  MOVLB  0
014FE:  RCALL  13F0
01500:  MOVFF  1BA,1C5
01504:  MOVLW  01
01506:  MOVLB  1
01508:  MOVWF  xC6
0150A:  MOVLB  0
0150C:  RCALL  1374
0150E:  MOVLW  20
01510:  MOVLB  2
01512:  MOVWF  xF3
01514:  MOVLB  0
01516:  RCALL  1232
01518:  MOVFF  1BE,1C5
0151C:  MOVLW  01
0151E:  MOVLB  1
01520:  MOVWF  xC6
01522:  MOVLB  0
01524:  RCALL  1374
01526:  MOVLW  3A
01528:  MOVLB  2
0152A:  MOVWF  xF3
0152C:  MOVLB  0
0152E:  RCALL  1232
01530:  MOVFF  1C1,1C5
01534:  MOVLW  01
01536:  MOVLB  1
01538:  MOVWF  xC6
0153A:  MOVLB  0
0153C:  RCALL  1374
0153E:  MOVLW  3A
01540:  MOVLB  2
01542:  MOVWF  xF3
01544:  MOVLB  0
01546:  RCALL  1232
01548:  MOVFF  1C0,1C5
0154C:  MOVLW  01
0154E:  MOVLB  1
01550:  MOVWF  xC6
01552:  MOVLB  0
01554:  RCALL  1374
.................... 
....................      fprintf(EXT, "RTCC setup finished!\n");
01556:  MOVLW  08
01558:  MOVWF  FF6
0155A:  MOVLW  01
0155C:  MOVWF  FF7
0155E:  MOVLW  00
01560:  MOVWF  FF8
01562:  RCALL  1278
01564:  GOTO   45CC (RETURN)
....................  
....................  }
....................  
....................  //this function will receive from EPS and sent to external port of EXT single character by character   
....................  void uart_repeater() {
....................      int received_data;
....................      while (TRUE) {
....................          // Check if data is available on the EPS stream
....................          if (kbhit(EPS)) {
*
03088:  BTFSC  F84.4
0308A:  BRA    309A
....................              // Read one byte from the EPS stream
....................              received_data = fgetc(EPS);
0308C:  RCALL  303E
0308E:  MOVFF  01,1B2
....................              // Send the received byte to the EXT stream
....................              fputc(received_data, EXT);
03092:  MOVFF  1B2,2F3
03096:  CALL   1232
....................          }
0309A:  BRA    3088
....................      }
0309C:  GOTO   44AA (RETURN)
....................  }
....................  // Function to receive exactly 16 bytes from UART
....................  void receive_16_bytes(int8* buffer) {
....................      for (int8 i = 0; i < 16; i++) {
....................          buffer[i] = getc(EPS);  // Blocks until a byte is received
....................      }
....................  }
....................  
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //adcs command
....................  //
....................  //#define SHUTDOWN_COUNT_ADDRESS  0x00001000  // Address where shutdown count is stored
....................  // this function is not working correctly need to fix it 
....................  int8 *read_data_adcs; //ADCS flash received data will be stored in here 
.................... int8 adcs_mission[3] = {0x33, 0x05, 0x05}; // mission command for ADCS all sensors will run for 3 minutes 
.................... int8 adcs_mag[3] = {0x22, 0x01, 0x05}; // mag each 9 bytes for measurement
.................... int8 adcs_gyro[3] = {0x11, 0x01, 0x05}; // gyro each 9 bytes for measurement 
.................... int8 last_adcs[5] = {0x00, 0x00, 0x00, 0x00, 0x00}; // last command for ADCS 
....................                 // (how many measurements are taken), (last address of the data)x4 not inverted
....................                 // we will multiply measurement size and how many measurements are taken and subtract from the last address
....................                 // to get the first measurement address of the data
....................                 // later we will read the data from the first address to the last address
.................... int8 adcs_status_address = 0x00020000; // status address of the adcs first byte is measrument count /each 9 byte/, last 4 is last address
.................... int8 adcs_gyro_first_address = 0x00030000; // first address of the gyro data 
....................  void adcs_mission_mode(void){
....................      output_high(ADCS_PWR);
*
03426:  BCF    F95.6
03428:  BSF    F8C.6
.................... delay_ms(1000);
0342A:  MOVLW  04
0342C:  MOVLB  1
0342E:  MOVWF  xC5
03430:  MOVLW  FA
03432:  MOVWF  xCD
03434:  MOVLB  0
03436:  CALL   1208
0343A:  MOVLB  1
0343C:  DECFSZ xC5,F
0343E:  BRA    3430
.................... READ_CHIP_ID_OF_ADCS();
03440:  MOVLB  0
03442:  CALL   1B4E
.................... fprintf(EXT, "deleting command address of the adcs\n");
03446:  MOVLW  1E
03448:  MOVWF  FF6
0344A:  MOVLW  01
0344C:  MOVWF  FF7
0344E:  MOVLW  00
03450:  MOVWF  FF8
03452:  CALL   1278
.................... SECTOR_ERASE_OF_ADCS(0x00000000);
03456:  MOVLB  1
03458:  CLRF   xC8
0345A:  CLRF   xC7
0345C:  CLRF   xC6
0345E:  CLRF   xC5
03460:  MOVLB  0
03462:  BRA    30C6
.................... delay_ms(100);
03464:  MOVLW  64
03466:  MOVLB  1
03468:  MOVWF  xCD
0346A:  MOVLB  0
0346C:  CALL   1208
.................... //SECTOR_ERASE_OF_ADCS(0x00020000);
.................... delay_ms(100);
03470:  MOVLW  64
03472:  MOVLB  1
03474:  MOVWF  xCD
03476:  MOVLB  0
03478:  CALL   1208
.................... fprintf(EXT, "Command address of the adcs is deleted!\n");
0347C:  MOVLW  44
0347E:  MOVWF  FF6
03480:  MOVLW  01
03482:  MOVWF  FF7
03484:  MOVLW  00
03486:  MOVWF  FF8
03488:  CALL   1278
.................... delay_ms(100);
0348C:  MOVLW  64
0348E:  MOVLB  1
03490:  MOVWF  xCD
03492:  MOVLB  0
03494:  CALL   1208
.................... fprintf(EXT, "Sending command to the adcs\n");
03498:  MOVLW  6E
0349A:  MOVWF  FF6
0349C:  MOVLW  01
0349E:  MOVWF  FF7
034A0:  MOVLW  00
034A2:  MOVWF  FF8
034A4:  CALL   1278
.................... 
.................... // Write and read from ADCS flash memory
.................... fprintf(EXT, "Starting to write data in ADCS flash memory\n");
034A8:  MOVLW  8C
034AA:  MOVWF  FF6
034AC:  MOVLW  01
034AE:  MOVWF  FF7
034B0:  MOVLW  00
034B2:  MOVWF  FF8
034B4:  CALL   1278
.................... WRITE_DATA_NBYTES_ADCS(0x00000000, adcs_gyro, sizeof(adcs_gyro));
034B8:  MOVLB  1
034BA:  CLRF   xC8
034BC:  CLRF   xC7
034BE:  CLRF   xC6
034C0:  CLRF   xC5
034C2:  MOVLW  01
034C4:  MOVWF  xCA
034C6:  MOVLW  10
034C8:  MOVWF  xC9
034CA:  MOVLW  03
034CC:  MOVWF  xCB
034CE:  MOVLB  0
034D0:  BRA    3172
.................... delay_ms(100);
034D2:  MOVLW  64
034D4:  MOVLB  1
034D6:  MOVWF  xCD
034D8:  MOVLB  0
034DA:  CALL   1208
.................... read_data_adcs = READ_DATA_NBYTES_ADCS(0x00000000, sizeof(adcs_gyro));
034DE:  MOVLB  1
034E0:  CLRF   xC8
034E2:  CLRF   xC7
034E4:  CLRF   xC6
034E6:  CLRF   xC5
034E8:  MOVLW  03
034EA:  MOVWF  xC9
034EC:  MOVLB  0
034EE:  RCALL  330A
034F0:  MOVFF  02,109
034F4:  MOVFF  01,108
.................... delay_ms(100);
034F8:  MOVLW  64
034FA:  MOVLB  1
034FC:  MOVWF  xCD
034FE:  MOVLB  0
03500:  CALL   1208
.................... for (int i = 0; i < sizeof(adcs_gyro); i++) {
03504:  MOVLB  1
03506:  CLRF   xB3
03508:  MOVF   xB3,W
0350A:  SUBLW  02
0350C:  BNC   3536
....................     fprintf(EXT, "%c", read_data_adcs[i]);
0350E:  MOVF   xB3,W
03510:  ADDWF  x08,W
03512:  MOVWF  FE9
03514:  MOVLW  00
03516:  ADDWFC x09,W
03518:  MOVWF  FEA
0351A:  MOVFF  FEF,2F3
0351E:  MOVLB  0
03520:  CALL   1232
....................     delay_ms(2);
03524:  MOVLW  02
03526:  MOVLB  1
03528:  MOVWF  xCD
0352A:  MOVLB  0
0352C:  CALL   1208
03530:  MOVLB  1
03532:  INCF   xB3,F
03534:  BRA    3508
.................... }
.................... fprintf(EXT, "\n"); 
03536:  MOVLW  0A
03538:  MOVLB  2
0353A:  MOVWF  xF3
0353C:  MOVLB  0
0353E:  CALL   1232
.................... fprintf(EXT, "ADCS command is written!\n");
03542:  MOVLW  BA
03544:  MOVWF  FF6
03546:  MOVLW  01
03548:  MOVWF  FF7
0354A:  MOVLW  00
0354C:  MOVWF  FF8
0354E:  CALL   1278
.................... 
.................... // Wait 70 seconds for ADCS to complete the mission
.................... for (int i = 0; i < 7; i++) {
03552:  MOVLB  1
03554:  CLRF   xB4
03556:  MOVF   xB4,W
03558:  SUBLW  06
0355A:  BNC   35B6
....................     fprintf(EXT, "waiting for adcs to finish 70s/%d0s\n", i);
0355C:  MOVLW  D4
0355E:  MOVWF  FF6
03560:  MOVLW  01
03562:  MOVWF  FF7
03564:  MOVLW  00
03566:  MOVWF  FF8
03568:  MOVLW  1F
0356A:  MOVLB  2
0356C:  MOVWF  xED
0356E:  MOVLB  0
03570:  CALL   13F0
03574:  MOVFF  1B4,2ED
03578:  MOVLW  18
0357A:  MOVLB  2
0357C:  MOVWF  xEE
0357E:  MOVLB  0
03580:  CALL   1706
03584:  MOVLW  F5
03586:  MOVWF  FF6
03588:  MOVLW  01
0358A:  MOVWF  FF7
0358C:  MOVLW  00
0358E:  MOVWF  FF8
03590:  MOVLW  03
03592:  MOVLB  2
03594:  MOVWF  xED
03596:  MOVLB  0
03598:  CALL   13F0
....................     delay_ms(10000);
0359C:  MOVLW  28
0359E:  MOVLB  1
035A0:  MOVWF  xC5
035A2:  MOVLW  FA
035A4:  MOVWF  xCD
035A6:  MOVLB  0
035A8:  CALL   1208
035AC:  MOVLB  1
035AE:  DECFSZ xC5,F
035B0:  BRA    35A2
035B2:  INCF   xB4,F
035B4:  BRA    3556
.................... }
.................... fprintf(EXT, "ADCS command is finished!\n");
035B6:  MOVLW  FA
035B8:  MOVWF  FF6
035BA:  MOVLW  01
035BC:  MOVWF  FF7
035BE:  MOVLW  00
035C0:  MOVWF  FF8
035C2:  MOVLB  0
035C4:  CALL   1278
.................... 
.................... // Read status and last address from ADCS
.................... fprintf(EXT, "reading the status address of the adcs!\n");
035C8:  MOVLW  16
035CA:  MOVWF  FF6
035CC:  MOVLW  02
035CE:  MOVWF  FF7
035D0:  MOVLW  00
035D2:  MOVWF  FF8
035D4:  CALL   1278
.................... read_data_adcs = READ_DATA_NBYTES_ADCS(0x00020000, 5); // Read 5 bytes: 1 for status, 4 for last address
035D8:  MOVLB  1
035DA:  CLRF   xC8
035DC:  MOVLW  02
035DE:  MOVWF  xC7
035E0:  CLRF   xC6
035E2:  CLRF   xC5
035E4:  MOVLW  05
035E6:  MOVWF  xC9
035E8:  MOVLB  0
035EA:  RCALL  330A
035EC:  MOVFF  02,109
035F0:  MOVFF  01,108
.................... delay_ms(100);
035F4:  MOVLW  64
035F6:  MOVLB  1
035F8:  MOVWF  xCD
035FA:  MOVLB  0
035FC:  CALL   1208
.................... 
.................... // Extract status and last address
.................... int8 adcs_status = read_data_adcs[0];  // Number of measurements (status)
.................... int32 last_adcs_address = 0;
03600:  MOVLB  1
03602:  MOVFF  108,FE9
03606:  MOVFF  109,FEA
0360A:  MOVFF  FEF,1B5
0360E:  CLRF   xB9
03610:  CLRF   xB8
03612:  CLRF   xB7
03614:  CLRF   xB6
.................... for (int i = 1; i < 5; i++) {
03616:  MOVLW  01
03618:  MOVWF  xBA
0361A:  MOVF   xBA,W
0361C:  SUBLW  04
0361E:  BNC   3644
....................     last_adcs_address = (last_adcs_address << 8) | (int8)read_data_adcs[i]; // Combine 4 bytes into a 32-bit address
03620:  MOVFF  1B8,1B9
03624:  MOVFF  1B7,1B8
03628:  MOVFF  1B6,1B7
0362C:  CLRF   xC6
0362E:  MOVF   xBA,W
03630:  ADDWF  x08,W
03632:  MOVWF  FE9
03634:  MOVLW  00
03636:  ADDWFC x09,W
03638:  MOVWF  FEA
0363A:  MOVF   FEF,W
0363C:  IORWF  xC6,W
0363E:  MOVWF  xB6
03640:  INCF   xBA,F
03642:  BRA    361A
.................... }
.................... fprintf(EXT, "ADCS status: %d, last address: 0x%08x\n", adcs_status, last_adcs_address);
03644:  MOVLW  40
03646:  MOVWF  FF6
03648:  MOVLW  02
0364A:  MOVWF  FF7
0364C:  MOVLW  00
0364E:  MOVWF  FF8
03650:  MOVLW  0D
03652:  MOVLB  2
03654:  MOVWF  xED
03656:  MOVLB  0
03658:  CALL   13F0
0365C:  MOVFF  1B5,2ED
03660:  MOVLW  18
03662:  MOVLB  2
03664:  MOVWF  xEE
03666:  MOVLB  0
03668:  CALL   1706
0366C:  MOVLW  4F
0366E:  MOVWF  FF6
03670:  MOVLW  02
03672:  MOVWF  FF7
03674:  MOVLW  00
03676:  MOVWF  FF8
03678:  MOVLW  12
0367A:  MOVLB  2
0367C:  MOVWF  xED
0367E:  MOVLB  0
03680:  CALL   13F0
03684:  MOVLW  06
03686:  MOVLB  1
03688:  MOVWF  xC5
0368A:  MOVLW  30
0368C:  MOVLB  2
0368E:  MOVWF  xF3
03690:  MOVLB  0
03692:  CALL   1232
03696:  MOVLB  1
03698:  DECFSZ xC5,F
0369A:  BRA    368A
0369C:  MOVFF  1B6,2ED
036A0:  MOVLW  57
036A2:  MOVLB  2
036A4:  MOVWF  xEE
036A6:  MOVLB  0
036A8:  CALL   16A2
036AC:  MOVLW  0A
036AE:  MOVLB  2
036B0:  MOVWF  xF3
036B2:  MOVLB  0
036B4:  CALL   1232
.................... 
.................... // Handle mission status
.................... if (adcs_status <= 0) {  // Assuming 0 or -1 indicates failure based on your original code
036B8:  MOVLB  1
036BA:  MOVF   xB5,F
036BC:  BNZ   36FE
....................     fprintf(EXT, "ADCS mission failed!\n");
036BE:  MOVLW  68
036C0:  MOVWF  FF6
036C2:  MOVLW  02
036C4:  MOVWF  FF7
036C6:  MOVLW  00
036C8:  MOVWF  FF8
036CA:  MOVLB  0
036CC:  CALL   1278
....................     while (TRUE) {
....................         fprintf(EXT, "ADCS mission failed!\n");
036D0:  MOVLW  7E
036D2:  MOVWF  FF6
036D4:  MOVLW  02
036D6:  MOVWF  FF7
036D8:  MOVLW  00
036DA:  MOVWF  FF8
036DC:  CALL   1278
....................         delay_ms(5000);
036E0:  MOVLW  14
036E2:  MOVLB  1
036E4:  MOVWF  xC5
036E6:  MOVLW  FA
036E8:  MOVWF  xCD
036EA:  MOVLB  0
036EC:  CALL   1208
036F0:  MOVLB  1
036F2:  DECFSZ xC5,F
036F4:  BRA    36E6
036F6:  MOVLB  0
036F8:  BRA    36D0
....................     }
.................... } else {
036FA:  BRA    38D0
036FC:  MOVLB  1
....................     fprintf(EXT, "ADCS mission success with %d measurements!\n", adcs_status);
036FE:  MOVLW  94
03700:  MOVWF  FF6
03702:  MOVLW  02
03704:  MOVWF  FF7
03706:  MOVLW  00
03708:  MOVWF  FF8
0370A:  MOVLW  1A
0370C:  MOVLB  2
0370E:  MOVWF  xED
03710:  MOVLB  0
03712:  CALL   13F0
03716:  MOVFF  1B5,2ED
0371A:  MOVLW  18
0371C:  MOVLB  2
0371E:  MOVWF  xEE
03720:  MOVLB  0
03722:  CALL   1706
03726:  MOVLW  B0
03728:  MOVWF  FF6
0372A:  MOVLW  02
0372C:  MOVWF  FF7
0372E:  MOVLW  00
03730:  MOVWF  FF8
03732:  MOVLW  0F
03734:  MOVLB  2
03736:  MOVWF  xED
03738:  MOVLB  0
0373A:  CALL   13F0
.................... 
....................     // Calculate the first data address
....................     int32 first_adcs_data_address = last_adcs_address - (adcs_status * 9); // Each measurement is 9 bytes
0373E:  MOVLB  1
03740:  MOVF   xB5,W
03742:  MULLW  09
03744:  MOVF   FF3,W
03746:  SUBWF  xB6,W
03748:  MOVWF  xBB
0374A:  MOVLW  00
0374C:  SUBWFB xB7,W
0374E:  MOVWF  xBC
03750:  MOVLW  00
03752:  SUBWFB xB8,W
03754:  MOVWF  xBD
03756:  MOVLW  00
03758:  SUBWFB xB9,W
0375A:  MOVWF  xBE
....................     fprintf(EXT, "First data address: 0x%08x\n", first_adcs_data_address);
0375C:  MOVLW  C0
0375E:  MOVWF  FF6
03760:  MOVLW  02
03762:  MOVWF  FF7
03764:  MOVLW  00
03766:  MOVWF  FF8
03768:  MOVLW  16
0376A:  MOVLB  2
0376C:  MOVWF  xED
0376E:  MOVLB  0
03770:  CALL   13F0
03774:  MOVLW  06
03776:  MOVLB  1
03778:  MOVWF  xC5
0377A:  MOVLW  30
0377C:  MOVLB  2
0377E:  MOVWF  xF3
03780:  MOVLB  0
03782:  CALL   1232
03786:  MOVLB  1
03788:  DECFSZ xC5,F
0378A:  BRA    377A
0378C:  MOVFF  1BB,2ED
03790:  MOVLW  57
03792:  MOVLB  2
03794:  MOVWF  xEE
03796:  MOVLB  0
03798:  CALL   16A2
0379C:  MOVLW  0A
0379E:  MOVLB  2
037A0:  MOVWF  xF3
037A2:  MOVLB  0
037A4:  CALL   1232
.................... 
....................     // Read and print each measurement
....................     for (int i = 0; i < adcs_status; i++) {
037A8:  MOVLB  1
037AA:  CLRF   xBF
037AC:  MOVF   xB5,W
037AE:  SUBWF  xBF,W
037B0:  BTFSC  FD8.0
037B2:  BRA    38CE
....................         int32 current_address = first_adcs_data_address + (i * 9);
037B4:  MOVF   xBF,W
037B6:  MULLW  09
037B8:  MOVF   FF3,W
037BA:  ADDWF  xBB,W
037BC:  MOVWF  xC0
037BE:  MOVLW  00
037C0:  ADDWFC xBC,W
037C2:  MOVWF  xC1
037C4:  MOVLW  00
037C6:  ADDWFC xBD,W
037C8:  MOVWF  xC2
037CA:  MOVLW  00
037CC:  ADDWFC xBE,W
037CE:  MOVWF  xC3
....................         read_data_adcs = READ_DATA_NBYTES_ADCS(current_address, 9); // Read 9 bytes per measurement
037D0:  MOVFF  1C3,1C8
037D4:  MOVFF  1C2,1C7
037D8:  MOVFF  1C1,1C6
037DC:  MOVFF  1C0,1C5
037E0:  MOVLW  09
037E2:  MOVWF  xC9
037E4:  MOVLB  0
037E6:  RCALL  330A
037E8:  MOVFF  02,109
037EC:  MOVFF  01,108
....................         fprintf(EXT, "Measurement %d at address 0x%08x: ", i + 1, current_address);
037F0:  MOVLW  01
037F2:  MOVLB  1
037F4:  ADDWF  xBF,W
037F6:  MOVWF  xC5
037F8:  MOVLW  DC
037FA:  MOVWF  FF6
037FC:  MOVLW  02
037FE:  MOVWF  FF7
03800:  MOVLW  00
03802:  MOVWF  FF8
03804:  MOVLW  0C
03806:  MOVLB  2
03808:  MOVWF  xED
0380A:  MOVLB  0
0380C:  CALL   13F0
03810:  MOVFF  1C5,2ED
03814:  MOVLW  18
03816:  MOVLB  2
03818:  MOVWF  xEE
0381A:  MOVLB  0
0381C:  CALL   1706
03820:  MOVLW  EA
03822:  MOVWF  FF6
03824:  MOVLW  02
03826:  MOVWF  FF7
03828:  MOVLW  00
0382A:  MOVWF  FF8
0382C:  MOVLW  0E
0382E:  MOVLB  2
03830:  MOVWF  xED
03832:  MOVLB  0
03834:  CALL   13F0
03838:  MOVLW  06
0383A:  MOVLB  1
0383C:  MOVWF  xC6
0383E:  MOVLW  30
03840:  MOVLB  2
03842:  MOVWF  xF3
03844:  MOVLB  0
03846:  CALL   1232
0384A:  MOVLB  1
0384C:  DECFSZ xC6,F
0384E:  BRA    383E
03850:  MOVFF  1C0,2ED
03854:  MOVLW  57
03856:  MOVLB  2
03858:  MOVWF  xEE
0385A:  MOVLB  0
0385C:  CALL   16A2
03860:  MOVLW  3A
03862:  MOVLB  2
03864:  MOVWF  xF3
03866:  MOVLB  0
03868:  CALL   1232
0386C:  MOVLW  20
0386E:  MOVLB  2
03870:  MOVWF  xF3
03872:  MOVLB  0
03874:  CALL   1232
....................         for (int j = 0; j < 9; j++) {
03878:  MOVLB  1
0387A:  CLRF   xC4
0387C:  MOVF   xC4,W
0387E:  SUBLW  08
03880:  BNC   38B0
....................             fprintf(EXT, "%02x ", (int8)read_data_adcs[j]); // Print each byte in hex
03882:  MOVF   xC4,W
03884:  ADDWF  x08,W
03886:  MOVWF  FE9
03888:  MOVLW  00
0388A:  ADDWFC x09,W
0388C:  MOVWF  FEA
0388E:  MOVFF  FEF,2ED
03892:  MOVLW  57
03894:  MOVLB  2
03896:  MOVWF  xEE
03898:  MOVLB  0
0389A:  CALL   16A2
0389E:  MOVLW  20
038A0:  MOVLB  2
038A2:  MOVWF  xF3
038A4:  MOVLB  0
038A6:  CALL   1232
038AA:  MOVLB  1
038AC:  INCF   xC4,F
038AE:  BRA    387C
....................         }
....................         fprintf(EXT, "\n");
038B0:  MOVLW  0A
038B2:  MOVLB  2
038B4:  MOVWF  xF3
038B6:  MOVLB  0
038B8:  CALL   1232
....................         delay_ms(2); // Small delay between reads
038BC:  MOVLW  02
038BE:  MOVLB  1
038C0:  MOVWF  xCD
038C2:  MOVLB  0
038C4:  CALL   1208
038C8:  MOVLB  1
038CA:  INCF   xBF,F
038CC:  BRA    37AC
038CE:  MOVLB  0
....................     }
.................... }
.................... output_low(ADCS_PWR);
038D0:  BCF    F95.6
038D2:  BCF    F8C.6
038D4:  GOTO   42E6 (RETURN)
....................  }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // eps functions 
....................  char cmd = 'G'; // Command character to trigger EPS
.................... unsigned int8 temperature[7];
.................... unsigned int8 solar_panel_current[5];
.................... unsigned int8 solar_panel_voltage[5];
.................... unsigned int8 sc_pwr;
.................... unsigned int8 sc_i_sens;
.................... unsigned int8 batt_i_sens;
.................... unsigned int8 batt_pwr;
.................... unsigned int8 raw_i_sens;
.................... unsigned int8 raw_v_sens;
.................... unsigned int8 batt_temp;
.................... unsigned int8 DCDC_output_i[5];
.................... bool KS_OBC_STAT;
.................... bool KS_EPS_STAT;
.................... 
.................... // Function to receive 33 bytes from EPS into the buffer
.................... void get_data(char* buffer) {
....................     putc(cmd, EPS); // Send command to EPS
*
03946:  MOVFF  11A,1D7
0394A:  BRA    38FE
....................     for (int8 i = 0; i < 33; i++) {
0394C:  MOVLB  1
0394E:  CLRF   xD6
03950:  MOVF   xD6,W
03952:  SUBLW  20
03954:  BNC   3982
....................         buffer[i] = fgetc(EPS); // Receive byte from EPS (blocks until received)
03956:  MOVF   xD6,W
03958:  ADDWF  xD4,W
0395A:  MOVWF  FE9
0395C:  MOVLW  00
0395E:  ADDWFC xD5,W
03960:  MOVWF  FEA
03962:  MOVFF  FEA,1DA
03966:  MOVFF  FE9,1D9
0396A:  MOVLB  0
0396C:  CALL   303E
03970:  MOVFF  1DA,FEA
03974:  MOVFF  1D9,FE9
03978:  MOVFF  01,FEF
0397C:  MOVLB  1
0397E:  INCF   xD6,F
03980:  BRA    3950
....................     }
03982:  MOVLB  0
03984:  GOTO   4236 (RETURN)
.................... }
.................... 
.................... // Function to send 33 bytes to EXT
.................... void send_data(char* buffer) {
....................     for (int8 i = 0; i < 33; i++) {
*
041D8:  MOVLB  1
041DA:  CLRF   xD6
041DC:  MOVF   xD6,W
041DE:  SUBLW  20
041E0:  BNC   41FE
....................         putc(buffer[i], EXT); // Send each byte to EXT
041E2:  MOVF   xD6,W
041E4:  ADDWF  xD4,W
041E6:  MOVWF  FE9
041E8:  MOVLW  00
041EA:  ADDWFC xD5,W
041EC:  MOVWF  FEA
041EE:  MOVFF  FEF,2F3
041F2:  MOVLB  0
041F4:  CALL   1232
041F8:  MOVLB  1
041FA:  INCF   xD6,F
041FC:  BRA    41DC
....................     }
....................     printf(EXT, "\n"); // Newline after sending all bytes
041FE:  CLRF   FEA
04200:  MOVLW  02
04202:  MOVWF  FE9
04204:  MOVLB  0
04206:  CALL   38D8
0420A:  GOTO   4256 (RETURN)
.................... }
.................... // Function to store data
.................... void store_eps_data(unsigned int8* buffer) {
....................     if (buffer[0] == '}' && buffer[32] == 'f') {
*
03988:  MOVLB  1
0398A:  MOVFF  1D4,FE9
0398E:  MOVFF  1D5,FEA
03992:  MOVF   FEF,W
03994:  SUBLW  7D
03996:  BTFSS  FD8.2
03998:  BRA    3AFE
0399A:  MOVLW  20
0399C:  ADDWF  xD4,W
0399E:  MOVWF  FE9
039A0:  MOVLW  00
039A2:  ADDWFC xD5,W
039A4:  MOVWF  FEA
039A6:  MOVF   FEF,W
039A8:  SUBLW  66
039AA:  BTFSS  FD8.2
039AC:  BRA    3AFE
....................         memcpy(temperature, &buffer[1], 7);
039AE:  MOVLW  01
039B0:  ADDWF  xD4,W
039B2:  MOVWF  01
039B4:  MOVLW  00
039B6:  ADDWFC xD5,W
039B8:  MOVWF  03
039BA:  MOVFF  01,1D6
039BE:  MOVWF  xD7
039C0:  MOVLW  01
039C2:  MOVWF  FEA
039C4:  MOVLW  1B
039C6:  MOVWF  FE9
039C8:  MOVFF  03,FE2
039CC:  MOVFF  01,FE1
039D0:  MOVLW  07
039D2:  MOVWF  01
039D4:  MOVFF  FE6,FEE
039D8:  DECFSZ 01,F
039DA:  BRA    39D4
....................         memcpy(solar_panel_current, &buffer[8], 5);
039DC:  MOVLW  08
039DE:  ADDWF  xD4,W
039E0:  MOVWF  01
039E2:  MOVLW  00
039E4:  ADDWFC xD5,W
039E6:  MOVWF  03
039E8:  MOVFF  01,1D6
039EC:  MOVWF  xD7
039EE:  MOVLW  01
039F0:  MOVWF  FEA
039F2:  MOVLW  22
039F4:  MOVWF  FE9
039F6:  MOVFF  03,FE2
039FA:  MOVFF  01,FE1
039FE:  MOVLW  05
03A00:  MOVWF  01
03A02:  MOVFF  FE6,FEE
03A06:  DECFSZ 01,F
03A08:  BRA    3A02
....................         memcpy(solar_panel_voltage, &buffer[13], 5);
03A0A:  MOVLW  0D
03A0C:  ADDWF  xD4,W
03A0E:  MOVWF  01
03A10:  MOVLW  00
03A12:  ADDWFC xD5,W
03A14:  MOVWF  03
03A16:  MOVFF  01,1D6
03A1A:  MOVWF  xD7
03A1C:  MOVLW  01
03A1E:  MOVWF  FEA
03A20:  MOVLW  27
03A22:  MOVWF  FE9
03A24:  MOVFF  03,FE2
03A28:  MOVFF  01,FE1
03A2C:  MOVLW  05
03A2E:  MOVWF  01
03A30:  MOVFF  FE6,FEE
03A34:  DECFSZ 01,F
03A36:  BRA    3A30
....................         sc_pwr = buffer[18];
03A38:  MOVLW  12
03A3A:  ADDWF  xD4,W
03A3C:  MOVWF  FE9
03A3E:  MOVLW  00
03A40:  ADDWFC xD5,W
03A42:  MOVWF  FEA
03A44:  MOVFF  FEF,12C
....................         sc_i_sens = buffer[19];
03A48:  MOVLW  13
03A4A:  ADDWF  xD4,W
03A4C:  MOVWF  FE9
03A4E:  MOVLW  00
03A50:  ADDWFC xD5,W
03A52:  MOVWF  FEA
03A54:  MOVFF  FEF,12D
....................         batt_i_sens = buffer[20];
03A58:  MOVLW  14
03A5A:  ADDWF  xD4,W
03A5C:  MOVWF  FE9
03A5E:  MOVLW  00
03A60:  ADDWFC xD5,W
03A62:  MOVWF  FEA
03A64:  MOVFF  FEF,12E
....................         batt_pwr = buffer[21];
03A68:  MOVLW  15
03A6A:  ADDWF  xD4,W
03A6C:  MOVWF  FE9
03A6E:  MOVLW  00
03A70:  ADDWFC xD5,W
03A72:  MOVWF  FEA
03A74:  MOVFF  FEF,12F
....................         raw_i_sens = buffer[22];
03A78:  MOVLW  16
03A7A:  ADDWF  xD4,W
03A7C:  MOVWF  FE9
03A7E:  MOVLW  00
03A80:  ADDWFC xD5,W
03A82:  MOVWF  FEA
03A84:  MOVFF  FEF,130
....................         raw_v_sens = buffer[23];
03A88:  MOVLW  17
03A8A:  ADDWF  xD4,W
03A8C:  MOVWF  FE9
03A8E:  MOVLW  00
03A90:  ADDWFC xD5,W
03A92:  MOVWF  FEA
03A94:  MOVFF  FEF,131
....................         batt_temp = buffer[24];
03A98:  MOVLW  18
03A9A:  ADDWF  xD4,W
03A9C:  MOVWF  FE9
03A9E:  MOVLW  00
03AA0:  ADDWFC xD5,W
03AA2:  MOVWF  FEA
03AA4:  MOVFF  FEF,132
....................         memcpy(DCDC_output_i, &buffer[25], 5);
03AA8:  MOVLW  19
03AAA:  ADDWF  xD4,W
03AAC:  MOVWF  01
03AAE:  MOVLW  00
03AB0:  ADDWFC xD5,W
03AB2:  MOVWF  03
03AB4:  MOVFF  01,1D6
03AB8:  MOVWF  xD7
03ABA:  MOVLW  01
03ABC:  MOVWF  FEA
03ABE:  MOVLW  33
03AC0:  MOVWF  FE9
03AC2:  MOVFF  03,FE2
03AC6:  MOVFF  01,FE1
03ACA:  MOVLW  05
03ACC:  MOVWF  01
03ACE:  MOVFF  FE6,FEE
03AD2:  DECFSZ 01,F
03AD4:  BRA    3ACE
....................         KS_OBC_STAT = buffer[30] != 0;
03AD6:  BCF    x38.0
03AD8:  MOVLW  1E
03ADA:  ADDWF  xD4,W
03ADC:  MOVWF  FE9
03ADE:  MOVLW  00
03AE0:  ADDWFC xD5,W
03AE2:  MOVWF  FEA
03AE4:  MOVF   FEF,F
03AE6:  BZ    3AEA
03AE8:  BSF    x38.0
....................         KS_EPS_STAT = buffer[31] != 0;
03AEA:  BCF    x38.1
03AEC:  MOVLW  1F
03AEE:  ADDWF  xD4,W
03AF0:  MOVWF  FE9
03AF2:  MOVLW  00
03AF4:  ADDWFC xD5,W
03AF6:  MOVWF  FEA
03AF8:  MOVF   FEF,F
03AFA:  BZ    3AFE
03AFC:  BSF    x38.1
....................     }
03AFE:  MOVLB  0
03B00:  GOTO   4246 (RETURN)
.................... }
.................... void print_table() {
....................     printf(EXT, "%-15s | %-8s | %-12s\n", "Variable", "Original", "Processed (V/A)");
*
03D8E:  CLRF   FEA
03D90:  MOVLW  02
03D92:  MOVWF  FE9
03D94:  RCALL  38D8
....................     printf(EXT, "--------------------------------------------------\n");
03D96:  CLRF   FEA
03D98:  MOVLW  02
03D9A:  MOVWF  FE9
03D9C:  RCALL  38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_pwr", sc_pwr, ((sc_pwr * 3.3) / 256.0) / 20.0);
03D9E:  MOVLB  1
03DA0:  CLRF   xD5
03DA2:  MOVFF  12C,1D4
03DA6:  MOVLB  0
03DA8:  RCALL  3B04
03DAA:  MOVFF  03,1D7
03DAE:  MOVFF  02,1D6
03DB2:  MOVFF  01,1D5
03DB6:  MOVFF  00,1D4
03DBA:  MOVLW  33
03DBC:  MOVLB  1
03DBE:  MOVWF  xDB
03DC0:  MOVWF  xDA
03DC2:  MOVLW  53
03DC4:  MOVWF  xD9
03DC6:  MOVLW  80
03DC8:  MOVWF  xD8
03DCA:  MOVLB  0
03DCC:  RCALL  3B3A
03DCE:  MOVFF  03,1D7
03DD2:  MOVFF  02,1D6
03DD6:  MOVFF  01,1D5
03DDA:  MOVFF  00,1D4
03DDE:  MOVFF  03,1DB
03DE2:  MOVFF  02,1DA
03DE6:  MOVFF  01,1D9
03DEA:  MOVFF  00,1D8
03DEE:  MOVLB  1
03DF0:  CLRF   xDF
03DF2:  CLRF   xDE
03DF4:  CLRF   xDD
03DF6:  MOVLW  87
03DF8:  MOVWF  xDC
03DFA:  MOVLB  0
03DFC:  RCALL  3C30
03DFE:  MOVFF  03,1D7
03E02:  MOVFF  02,1D6
03E06:  MOVFF  01,1D5
03E0A:  MOVFF  00,1D4
03E0E:  MOVFF  03,1DB
03E12:  MOVFF  02,1DA
03E16:  MOVFF  01,1D9
03E1A:  MOVFF  00,1D8
03E1E:  MOVLB  1
03E20:  CLRF   xDF
03E22:  CLRF   xDE
03E24:  MOVLW  20
03E26:  MOVWF  xDD
03E28:  MOVLW  83
03E2A:  MOVWF  xDC
03E2C:  MOVLB  0
03E2E:  RCALL  3C30
03E30:  MOVFF  03,1D7
03E34:  MOVFF  02,1D6
03E38:  MOVFF  01,1D5
03E3C:  MOVFF  00,1D4
03E40:  CLRF   FEA
03E42:  MOVLW  02
03E44:  MOVWF  FE9
03E46:  RCALL  38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_i_sens", sc_i_sens, ((sc_i_sens * 3.3) / 256.0) / 20.0);
03E48:  MOVLB  1
03E4A:  CLRF   xD5
03E4C:  MOVFF  12D,1D4
03E50:  MOVLB  0
03E52:  RCALL  3B04
03E54:  MOVFF  03,1D7
03E58:  MOVFF  02,1D6
03E5C:  MOVFF  01,1D5
03E60:  MOVFF  00,1D4
03E64:  MOVLW  33
03E66:  MOVLB  1
03E68:  MOVWF  xDB
03E6A:  MOVWF  xDA
03E6C:  MOVLW  53
03E6E:  MOVWF  xD9
03E70:  MOVLW  80
03E72:  MOVWF  xD8
03E74:  MOVLB  0
03E76:  RCALL  3B3A
03E78:  MOVFF  03,1D7
03E7C:  MOVFF  02,1D6
03E80:  MOVFF  01,1D5
03E84:  MOVFF  00,1D4
03E88:  MOVFF  03,1DB
03E8C:  MOVFF  02,1DA
03E90:  MOVFF  01,1D9
03E94:  MOVFF  00,1D8
03E98:  MOVLB  1
03E9A:  CLRF   xDF
03E9C:  CLRF   xDE
03E9E:  CLRF   xDD
03EA0:  MOVLW  87
03EA2:  MOVWF  xDC
03EA4:  MOVLB  0
03EA6:  RCALL  3C30
03EA8:  MOVFF  03,1D7
03EAC:  MOVFF  02,1D6
03EB0:  MOVFF  01,1D5
03EB4:  MOVFF  00,1D4
03EB8:  MOVFF  03,1DB
03EBC:  MOVFF  02,1DA
03EC0:  MOVFF  01,1D9
03EC4:  MOVFF  00,1D8
03EC8:  MOVLB  1
03ECA:  CLRF   xDF
03ECC:  CLRF   xDE
03ECE:  MOVLW  20
03ED0:  MOVWF  xDD
03ED2:  MOVLW  83
03ED4:  MOVWF  xDC
03ED6:  MOVLB  0
03ED8:  RCALL  3C30
03EDA:  MOVFF  03,1D7
03EDE:  MOVFF  02,1D6
03EE2:  MOVFF  01,1D5
03EE6:  MOVFF  00,1D4
03EEA:  CLRF   FEA
03EEC:  MOVLW  02
03EEE:  MOVWF  FE9
03EF0:  RCALL  38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_i_sens", raw_i_sens, ((raw_i_sens * 3.3) / 256.0) / 20.0);
03EF2:  MOVLB  1
03EF4:  CLRF   xD5
03EF6:  MOVFF  130,1D4
03EFA:  MOVLB  0
03EFC:  RCALL  3B04
03EFE:  MOVFF  03,1D7
03F02:  MOVFF  02,1D6
03F06:  MOVFF  01,1D5
03F0A:  MOVFF  00,1D4
03F0E:  MOVLW  33
03F10:  MOVLB  1
03F12:  MOVWF  xDB
03F14:  MOVWF  xDA
03F16:  MOVLW  53
03F18:  MOVWF  xD9
03F1A:  MOVLW  80
03F1C:  MOVWF  xD8
03F1E:  MOVLB  0
03F20:  RCALL  3B3A
03F22:  MOVFF  03,1D7
03F26:  MOVFF  02,1D6
03F2A:  MOVFF  01,1D5
03F2E:  MOVFF  00,1D4
03F32:  MOVFF  03,1DB
03F36:  MOVFF  02,1DA
03F3A:  MOVFF  01,1D9
03F3E:  MOVFF  00,1D8
03F42:  MOVLB  1
03F44:  CLRF   xDF
03F46:  CLRF   xDE
03F48:  CLRF   xDD
03F4A:  MOVLW  87
03F4C:  MOVWF  xDC
03F4E:  MOVLB  0
03F50:  RCALL  3C30
03F52:  MOVFF  03,1D7
03F56:  MOVFF  02,1D6
03F5A:  MOVFF  01,1D5
03F5E:  MOVFF  00,1D4
03F62:  MOVFF  03,1DB
03F66:  MOVFF  02,1DA
03F6A:  MOVFF  01,1D9
03F6E:  MOVFF  00,1D8
03F72:  MOVLB  1
03F74:  CLRF   xDF
03F76:  CLRF   xDE
03F78:  MOVLW  20
03F7A:  MOVWF  xDD
03F7C:  MOVLW  83
03F7E:  MOVWF  xDC
03F80:  MOVLB  0
03F82:  RCALL  3C30
03F84:  MOVFF  03,1D7
03F88:  MOVFF  02,1D6
03F8C:  MOVFF  01,1D5
03F90:  MOVFF  00,1D4
03F94:  CLRF   FEA
03F96:  MOVLW  02
03F98:  MOVWF  FE9
03F9A:  RCALL  38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_v_sens", raw_v_sens, ((raw_v_sens * 3.3) / 256.0) / 20.0);
03F9C:  MOVLB  1
03F9E:  CLRF   xD5
03FA0:  MOVFF  131,1D4
03FA4:  MOVLB  0
03FA6:  RCALL  3B04
03FA8:  MOVFF  03,1D7
03FAC:  MOVFF  02,1D6
03FB0:  MOVFF  01,1D5
03FB4:  MOVFF  00,1D4
03FB8:  MOVLW  33
03FBA:  MOVLB  1
03FBC:  MOVWF  xDB
03FBE:  MOVWF  xDA
03FC0:  MOVLW  53
03FC2:  MOVWF  xD9
03FC4:  MOVLW  80
03FC6:  MOVWF  xD8
03FC8:  MOVLB  0
03FCA:  RCALL  3B3A
03FCC:  MOVFF  03,1D7
03FD0:  MOVFF  02,1D6
03FD4:  MOVFF  01,1D5
03FD8:  MOVFF  00,1D4
03FDC:  MOVFF  03,1DB
03FE0:  MOVFF  02,1DA
03FE4:  MOVFF  01,1D9
03FE8:  MOVFF  00,1D8
03FEC:  MOVLB  1
03FEE:  CLRF   xDF
03FF0:  CLRF   xDE
03FF2:  CLRF   xDD
03FF4:  MOVLW  87
03FF6:  MOVWF  xDC
03FF8:  MOVLB  0
03FFA:  RCALL  3C30
03FFC:  MOVFF  03,1D7
04000:  MOVFF  02,1D6
04004:  MOVFF  01,1D5
04008:  MOVFF  00,1D4
0400C:  MOVFF  03,1DB
04010:  MOVFF  02,1DA
04014:  MOVFF  01,1D9
04018:  MOVFF  00,1D8
0401C:  MOVLB  1
0401E:  CLRF   xDF
04020:  CLRF   xDE
04022:  MOVLW  20
04024:  MOVWF  xDD
04026:  MOVLW  83
04028:  MOVWF  xDC
0402A:  MOVLB  0
0402C:  RCALL  3C30
0402E:  MOVFF  03,1D7
04032:  MOVFF  02,1D6
04036:  MOVFF  01,1D5
0403A:  MOVFF  00,1D4
0403E:  CLRF   FEA
04040:  MOVLW  02
04042:  MOVWF  FE9
04044:  RCALL  38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_pwr", batt_pwr, ((batt_pwr * 3.3) / 256.0) / 20.0);
04046:  MOVLB  1
04048:  CLRF   xD5
0404A:  MOVFF  12F,1D4
0404E:  MOVLB  0
04050:  RCALL  3B04
04052:  MOVFF  03,1D7
04056:  MOVFF  02,1D6
0405A:  MOVFF  01,1D5
0405E:  MOVFF  00,1D4
04062:  MOVLW  33
04064:  MOVLB  1
04066:  MOVWF  xDB
04068:  MOVWF  xDA
0406A:  MOVLW  53
0406C:  MOVWF  xD9
0406E:  MOVLW  80
04070:  MOVWF  xD8
04072:  MOVLB  0
04074:  RCALL  3B3A
04076:  MOVFF  03,1D7
0407A:  MOVFF  02,1D6
0407E:  MOVFF  01,1D5
04082:  MOVFF  00,1D4
04086:  MOVFF  03,1DB
0408A:  MOVFF  02,1DA
0408E:  MOVFF  01,1D9
04092:  MOVFF  00,1D8
04096:  MOVLB  1
04098:  CLRF   xDF
0409A:  CLRF   xDE
0409C:  CLRF   xDD
0409E:  MOVLW  87
040A0:  MOVWF  xDC
040A2:  MOVLB  0
040A4:  RCALL  3C30
040A6:  MOVFF  03,1D7
040AA:  MOVFF  02,1D6
040AE:  MOVFF  01,1D5
040B2:  MOVFF  00,1D4
040B6:  MOVFF  03,1DB
040BA:  MOVFF  02,1DA
040BE:  MOVFF  01,1D9
040C2:  MOVFF  00,1D8
040C6:  MOVLB  1
040C8:  CLRF   xDF
040CA:  CLRF   xDE
040CC:  MOVLW  20
040CE:  MOVWF  xDD
040D0:  MOVLW  83
040D2:  MOVWF  xDC
040D4:  MOVLB  0
040D6:  RCALL  3C30
040D8:  MOVFF  03,1D7
040DC:  MOVFF  02,1D6
040E0:  MOVFF  01,1D5
040E4:  MOVFF  00,1D4
040E8:  CLRF   FEA
040EA:  MOVLW  02
040EC:  MOVWF  FE9
040EE:  CALL   38D8
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_i_sens", batt_i_sens, ((batt_i_sens * 3.3) / 256.0) / 20.0);
040F2:  MOVLB  1
040F4:  CLRF   xD5
040F6:  MOVFF  12E,1D4
040FA:  MOVLB  0
040FC:  RCALL  3B04
040FE:  MOVFF  03,1D7
04102:  MOVFF  02,1D6
04106:  MOVFF  01,1D5
0410A:  MOVFF  00,1D4
0410E:  MOVLW  33
04110:  MOVLB  1
04112:  MOVWF  xDB
04114:  MOVWF  xDA
04116:  MOVLW  53
04118:  MOVWF  xD9
0411A:  MOVLW  80
0411C:  MOVWF  xD8
0411E:  MOVLB  0
04120:  RCALL  3B3A
04122:  MOVFF  03,1D7
04126:  MOVFF  02,1D6
0412A:  MOVFF  01,1D5
0412E:  MOVFF  00,1D4
04132:  MOVFF  03,1DB
04136:  MOVFF  02,1DA
0413A:  MOVFF  01,1D9
0413E:  MOVFF  00,1D8
04142:  MOVLB  1
04144:  CLRF   xDF
04146:  CLRF   xDE
04148:  CLRF   xDD
0414A:  MOVLW  87
0414C:  MOVWF  xDC
0414E:  MOVLB  0
04150:  RCALL  3C30
04152:  MOVFF  03,1D7
04156:  MOVFF  02,1D6
0415A:  MOVFF  01,1D5
0415E:  MOVFF  00,1D4
04162:  MOVFF  03,1DB
04166:  MOVFF  02,1DA
0416A:  MOVFF  01,1D9
0416E:  MOVFF  00,1D8
04172:  MOVLB  1
04174:  CLRF   xDF
04176:  CLRF   xDE
04178:  MOVLW  20
0417A:  MOVWF  xDD
0417C:  MOVLW  83
0417E:  MOVWF  xDC
04180:  MOVLB  0
04182:  RCALL  3C30
04184:  MOVFF  03,1D7
04188:  MOVFF  02,1D6
0418C:  MOVFF  01,1D5
04190:  MOVFF  00,1D4
04194:  CLRF   FEA
04196:  MOVLW  02
04198:  MOVWF  FE9
0419A:  CALL   38D8
....................     printf(EXT, "\n"); // Add a newline after the table
0419E:  CLRF   FEA
041A0:  MOVLW  02
041A2:  MOVWF  FE9
041A4:  CALL   38D8
....................     printf(EXT, "KS of OBC status is %d", KS_OBC_STAT);
041A8:  MOVLW  00
041AA:  MOVLB  1
041AC:  BTFSC  x38.0
041AE:  MOVLW  01
041B0:  MOVWF  xD4
041B2:  CLRF   FEA
041B4:  MOVLW  02
041B6:  MOVWF  FE9
041B8:  MOVLB  0
041BA:  CALL   38D8
....................     printf(EXT, "KS of EPS status is %d", KS_EPS_STAT);
041BE:  MOVLW  00
041C0:  MOVLB  1
041C2:  BTFSC  x38.1
041C4:  MOVLW  01
041C6:  MOVWF  xD4
041C8:  CLRF   FEA
041CA:  MOVLW  02
041CC:  MOVWF  FE9
041CE:  MOVLB  0
041D0:  CALL   38D8
041D4:  GOTO   4248 (RETURN)
.................... }
.................... // Main function to test UART communication
.................... void eps_mission_mode(void) {
....................     output_high(EN_SUP_3V3_DAQ); // Enable 3.3V supply for DAQ
*
0420E:  BCF    F95.0
04210:  BSF    F8C.0
....................     printf(EXT, "EPS power on!\n");  // Initial message to EXT
04212:  CLRF   FEA
04214:  MOVLW  02
04216:  MOVWF  FE9
04218:  CALL   38D8
.................... 
....................     char buffer[33]; // Buffer to hold 33 bytes
.................... 
....................         printf(EXT, "Sending request...\n");
0421C:  CLRF   FEA
0421E:  MOVLW  02
04220:  MOVWF  FE9
04222:  CALL   38D8
....................         get_data(buffer);          // Get data from EPS
04226:  MOVLW  01
04228:  MOVLB  1
0422A:  MOVWF  xD5
0422C:  MOVLW  B3
0422E:  MOVWF  xD4
04230:  MOVLB  0
04232:  GOTO   3946
....................         store_eps_data(buffer);    // Parse buffer into variables
04236:  MOVLW  01
04238:  MOVLB  1
0423A:  MOVWF  xD5
0423C:  MOVLW  B3
0423E:  MOVWF  xD4
04240:  MOVLB  0
04242:  GOTO   3988
....................         print_table();             // Print the table
04246:  BRA    3D8E
....................         send_data(buffer);         // Forward data to EXT
04248:  MOVLW  01
0424A:  MOVLB  1
0424C:  MOVWF  xD5
0424E:  MOVLW  B3
04250:  MOVWF  xD4
04252:  MOVLB  0
04254:  BRA    41D8
04256:  GOTO   42E6 (RETURN)
....................     
.................... }
....................  
....................  int8 update_shutdown_count(void) {
....................      fprintf(EXT, "Shutdown count started\n");
*
0192A:  MOVLW  00
0192C:  MOVWF  FF6
0192E:  MOVLW  03
01930:  MOVWF  FF7
01932:  MOVLW  00
01934:  MOVWF  FF8
01936:  RCALL  1278
....................  
....................      // Read shutdown count directly from memory
....................      unsigned char shutdown_count[1];
....................      shutdown_count[0] = READ_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, 1); // Updated call
01938:  MOVLB  1
0193A:  CLRF   xDD
0193C:  MOVLW  10
0193E:  MOVWF  xDC
01940:  CLRF   xDB
01942:  MOVLW  11
01944:  MOVWF  xDA
01946:  MOVLW  01
01948:  MOVWF  xDE
0194A:  MOVLB  0
0194C:  RCALL  15B4
0194E:  MOVFF  01,1B1
....................      delay_ms(10);
01952:  MOVLW  0A
01954:  MOVLB  1
01956:  MOVWF  xCD
01958:  MOVLB  0
0195A:  RCALL  1208
....................  
....................      fprintf(EXT, "Read shutdown count: %u\n", shutdown_count[0]);
0195C:  MOVLW  18
0195E:  MOVWF  FF6
01960:  MOVLW  03
01962:  MOVWF  FF7
01964:  MOVLW  00
01966:  MOVWF  FF8
01968:  MOVLW  15
0196A:  MOVLB  2
0196C:  MOVWF  xED
0196E:  MOVLB  0
01970:  RCALL  13F0
01972:  MOVFF  1B1,1C5
01976:  MOVLW  1B
01978:  MOVLB  1
0197A:  MOVWF  xC6
0197C:  MOVLB  0
0197E:  RCALL  1374
01980:  MOVLW  0A
01982:  MOVLB  2
01984:  MOVWF  xF3
01986:  MOVLB  0
01988:  RCALL  1232
....................  
....................      shutdown_count[0]++;  // Increment the shutdown count
0198A:  MOVLB  1
0198C:  INCF   xB1,F
....................      fprintf(EXT, "Incremented shutdown count: %u\n", shutdown_count[0]);
0198E:  MOVLW  32
01990:  MOVWF  FF6
01992:  MOVLW  03
01994:  MOVWF  FF7
01996:  MOVLW  00
01998:  MOVWF  FF8
0199A:  MOVLW  1C
0199C:  MOVLB  2
0199E:  MOVWF  xED
019A0:  MOVLB  0
019A2:  RCALL  13F0
019A4:  MOVFF  1B1,1C5
019A8:  MOVLW  1B
019AA:  MOVLB  1
019AC:  MOVWF  xC6
019AE:  MOVLB  0
019B0:  RCALL  1374
019B2:  MOVLW  0A
019B4:  MOVLB  2
019B6:  MOVWF  xF3
019B8:  MOVLB  0
019BA:  RCALL  1232
....................  
....................      // Write the updated shutdown count back to memory
....................      WRITE_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, shutdown_count, 1);
019BC:  MOVLB  2
019BE:  CLRF   xE4
019C0:  MOVLW  10
019C2:  MOVWF  xE3
019C4:  CLRF   xE2
019C6:  MOVLW  11
019C8:  MOVWF  xE1
019CA:  MOVLW  01
019CC:  MOVWF  xE6
019CE:  MOVLW  B1
019D0:  MOVWF  xE5
019D2:  MOVLW  01
019D4:  MOVWF  xE7
019D6:  MOVLB  0
019D8:  RCALL  17C2
....................      delay_ms(10);
019DA:  MOVLW  0A
019DC:  MOVLB  1
019DE:  MOVWF  xCD
019E0:  MOVLB  0
019E2:  RCALL  1208
....................  
....................      fprintf(EXT, "Now shutdown count is : %u\n\n", shutdown_count[0]);
019E4:  MOVLW  52
019E6:  MOVWF  FF6
019E8:  MOVLW  03
019EA:  MOVWF  FF7
019EC:  MOVLW  00
019EE:  MOVWF  FF8
019F0:  MOVLW  18
019F2:  MOVLB  2
019F4:  MOVWF  xED
019F6:  MOVLB  0
019F8:  RCALL  13F0
019FA:  MOVFF  1B1,1C5
019FE:  MOVLW  1B
01A00:  MOVLB  1
01A02:  MOVWF  xC6
01A04:  MOVLB  0
01A06:  RCALL  1374
01A08:  MOVLW  0A
01A0A:  MOVLB  2
01A0C:  MOVWF  xF3
01A0E:  MOVLB  0
01A10:  RCALL  1232
01A12:  MOVLW  0A
01A14:  MOVLB  2
01A16:  MOVWF  xF3
01A18:  MOVLB  0
01A1A:  RCALL  1232
....................  
....................      return shutdown_count[0];
01A1C:  MOVLB  1
01A1E:  MOVFF  1B1,01
01A22:  MOVLB  0
01A24:  GOTO   45D0 (RETURN)
....................  }
....................  
....................  
....................  //main flash memory consol for main_menu() function
....................  void write_to_main_flash_menu(){
....................              unsigned int32 address;
....................              unsigned int8 data[256]; // Buffer for data to be written (adjust size as needed)
....................              unsigned char data_number;
....................              unsigned char choice;
....................              unsigned int8 i;
....................              // Prompt user to enter the address
....................              fprintf(EXT, "\nEnter Address (hex, 0x1234): 0x");
*
025F4:  MOVLW  70
025F6:  MOVWF  FF6
025F8:  MOVLW  03
025FA:  MOVWF  FF7
025FC:  MOVLW  00
025FE:  MOVWF  FF8
02600:  CALL   1278
....................              fscanf(EXT, "%x", &address); // Read address input in hex
02604:  MOVLB  2
02606:  CLRF   xE1
02608:  CLRF   xE2
0260A:  MOVLW  01
0260C:  MOVWF  xE4
0260E:  MOVLW  DA
02610:  MOVWF  xE3
02612:  CLRF   xE6
02614:  CLRF   xE5
02616:  MOVLB  0
02618:  RCALL  2414
0261A:  MOVF   01,F
0261C:  BNZ   2626
0261E:  MOVLB  2
02620:  CLRF   xE2
02622:  BRA    262E
02624:  MOVLB  0
02626:  MOVF   01,W
02628:  MOVLB  2
0262A:  ADDWF  xE1,F
0262C:  INCF   xE2,F
....................  
....................              // Prompt user to enter the number of bytes
....................              fprintf(EXT, "\nEnter number of bytes to write (max 256): ");
0262E:  MOVLW  92
02630:  MOVWF  FF6
02632:  MOVLW  03
02634:  MOVWF  FF7
02636:  MOVLW  00
02638:  MOVWF  FF8
0263A:  MOVLB  0
0263C:  CALL   1278
....................              fscanf(EXT, "%x", &data_number); // Read number of bytes
02640:  MOVLB  2
02642:  CLRF   xE1
02644:  CLRF   xE2
02646:  MOVLW  02
02648:  MOVWF  xE6
0264A:  MOVLW  DE
0264C:  MOVWF  xE5
0264E:  CLRF   xE8
02650:  CLRF   xE7
02652:  MOVLB  0
02654:  RCALL  2524
02656:  MOVF   01,F
02658:  BNZ   2662
0265A:  MOVLB  2
0265C:  CLRF   xE2
0265E:  BRA    266A
02660:  MOVLB  0
02662:  MOVF   01,W
02664:  MOVLB  2
02666:  ADDWF  xE1,F
02668:  INCF   xE2,F
....................  
.................... //             if (data_number > 256) {
.................... //                 fprintf(EXT, "Error: Maximum data length is 256 bytes.\n");
.................... //                 continue;
.................... //             }
....................  
....................              // Get data from user
....................              fprintf(EXT, "Enter %d bytes of data (in hex):\n", data_number);
0266A:  MOVLW  BE
0266C:  MOVWF  FF6
0266E:  MOVLW  03
02670:  MOVWF  FF7
02672:  MOVLW  00
02674:  MOVWF  FF8
02676:  MOVLW  06
02678:  MOVWF  xED
0267A:  MOVLB  0
0267C:  CALL   13F0
02680:  MOVFF  2DE,2ED
02684:  MOVLW  18
02686:  MOVLB  2
02688:  MOVWF  xEE
0268A:  MOVLB  0
0268C:  CALL   1706
02690:  MOVLW  C6
02692:  MOVWF  FF6
02694:  MOVLW  03
02696:  MOVWF  FF7
02698:  MOVLW  00
0269A:  MOVWF  FF8
0269C:  MOVLW  19
0269E:  MOVLB  2
026A0:  MOVWF  xED
026A2:  MOVLB  0
026A4:  CALL   13F0
....................              for (i = 0; i < data_number; i++) {
026A8:  MOVLB  2
026AA:  CLRF   xE0
026AC:  MOVF   xDE,W
026AE:  SUBWF  xE0,W
026B0:  BC    2738
....................                  fprintf(EXT, "Byte %d: 0x", i + 1);
026B2:  MOVLW  01
026B4:  ADDWF  xE0,W
026B6:  MOVWF  xE1
026B8:  MOVLW  E0
026BA:  MOVWF  FF6
026BC:  MOVLW  03
026BE:  MOVWF  FF7
026C0:  MOVLW  00
026C2:  MOVWF  FF8
026C4:  MOVLW  05
026C6:  MOVWF  xED
026C8:  MOVLB  0
026CA:  CALL   13F0
026CE:  MOVFF  2E1,2ED
026D2:  MOVLW  18
026D4:  MOVLB  2
026D6:  MOVWF  xEE
026D8:  MOVLB  0
026DA:  CALL   1706
026DE:  MOVLW  E7
026E0:  MOVWF  FF6
026E2:  MOVLW  03
026E4:  MOVWF  FF7
026E6:  MOVLW  00
026E8:  MOVWF  FF8
026EA:  MOVLW  04
026EC:  MOVLB  2
026EE:  MOVWF  xED
026F0:  MOVLB  0
026F2:  CALL   13F0
....................                  fscanf(EXT, "%x", &data[i]); // Read byte in hex format
026F6:  CLRF   03
026F8:  MOVLB  2
026FA:  MOVF   xE0,W
026FC:  ADDLW  DE
026FE:  MOVWF  01
02700:  MOVLW  01
02702:  ADDWFC 03,F
02704:  MOVFF  01,2E1
02708:  MOVFF  03,2E2
0270C:  CLRF   xE3
0270E:  CLRF   xE4
02710:  MOVFF  03,2E6
02714:  MOVFF  01,2E5
02718:  CLRF   xE8
0271A:  CLRF   xE7
0271C:  MOVLB  0
0271E:  RCALL  2524
02720:  MOVF   01,F
02722:  BNZ   272C
02724:  MOVLB  2
02726:  CLRF   xE4
02728:  BRA    2734
0272A:  MOVLB  0
0272C:  MOVF   01,W
0272E:  MOVLB  2
02730:  ADDWF  xE3,F
02732:  INCF   xE4,F
02734:  INCF   xE0,F
02736:  BRA    26AC
....................              }
....................  
....................              // Call the function to write data to the address
....................              WRITE_DATA_NBYTES(address, data, data_number);
02738:  MOVFF  1DD,2E4
0273C:  MOVFF  1DC,2E3
02740:  MOVFF  1DB,2E2
02744:  MOVFF  1DA,2E1
02748:  MOVLW  01
0274A:  MOVWF  xE6
0274C:  MOVLW  DE
0274E:  MOVWF  xE5
02750:  MOVFF  2DE,2E7
02754:  MOVLB  0
02756:  CALL   17C2
....................  
....................              fprintf(EXT, "\nData successfully written.\n");
0275A:  MOVLW  EC
0275C:  MOVWF  FF6
0275E:  MOVLW  03
02760:  MOVWF  FF7
02762:  MOVLW  00
02764:  MOVWF  FF8
02766:  CALL   1278
0276A:  GOTO   2A52 (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_main_flash_memory() {
....................      char main_flash_option;
....................      unsigned int32 address;
....................      unsigned char data[32];
....................      unsigned char data_length;
....................  
....................      fprintf(EXT, "MAIN flash memory chosen\n");
*
0289A:  MOVLW  0A
0289C:  MOVWF  FF6
0289E:  MOVLW  04
028A0:  MOVWF  FF7
028A2:  MOVLW  00
028A4:  MOVWF  FF8
028A6:  CALL   1278
....................      fprintf(EXT, "press a: Read ID of the chip\n");
028AA:  MOVLW  24
028AC:  MOVWF  FF6
028AE:  MOVLW  04
028B0:  MOVWF  FF7
028B2:  MOVLW  00
028B4:  MOVWF  FF8
028B6:  CALL   1278
....................      fprintf(EXT, "press b: Write data set in specified address\n");
028BA:  MOVLW  42
028BC:  MOVWF  FF6
028BE:  MOVLW  04
028C0:  MOVWF  FF7
028C2:  MOVLW  00
028C4:  MOVWF  FF8
028C6:  CALL   1278
....................      fprintf(EXT, "press c: Read data set in specified address\n");
028CA:  MOVLW  70
028CC:  MOVWF  FF6
028CE:  MOVLW  04
028D0:  MOVWF  FF7
028D2:  MOVLW  00
028D4:  MOVWF  FF8
028D6:  CALL   1278
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
028DA:  MOVLW  9E
028DC:  MOVWF  FF6
028DE:  MOVLW  04
028E0:  MOVWF  FF7
028E2:  MOVLW  00
028E4:  MOVWF  FF8
028E6:  CALL   1278
....................  
....................      main_flash_option = fgetc(EXT);
028EA:  CALL   1E7E
028EE:  MOVFF  01,1B4
....................  
....................      switch (main_flash_option) {
028F2:  MOVLB  1
028F4:  MOVF   xB4,W
028F6:  XORLW  61
028F8:  MOVLB  0
028FA:  BZ    290C
028FC:  XORLW  03
028FE:  BZ    2920
02900:  XORLW  01
02902:  BZ    2924
02904:  XORLW  1B
02906:  BTFSC  FD8.2
02908:  BRA    2A40
0290A:  BRA    2A42
....................          case 'a':
....................              fprintf(EXT, "Started reading chip ID of MAIN flash memory\n");
0290C:  MOVLW  BC
0290E:  MOVWF  FF6
02910:  MOVLW  04
02912:  MOVWF  FF7
02914:  MOVLW  00
02916:  MOVWF  FF8
02918:  CALL   1278
....................              READ_CHIP_ID_OF();  
0291C:  BRA    230E
....................              break;
0291E:  BRA    2A52
....................          case 'b':
....................              write_to_main_flash_menu();
02920:  BRA    25F4
....................              break;
02922:  BRA    2A52
....................          case 'c':
....................              fprintf(EXT, "Read data set in specified address\n");
02924:  MOVLW  EA
02926:  MOVWF  FF6
02928:  MOVLW  04
0292A:  MOVWF  FF7
0292C:  MOVLW  00
0292E:  MOVWF  FF8
02930:  CALL   1278
....................              fprintf(EXT, "Enter your specified address and length (e.g., 0x1234 10): ");
02934:  MOVLW  0E
02936:  MOVWF  FF6
02938:  MOVLW  05
0293A:  MOVWF  FF7
0293C:  MOVLW  00
0293E:  MOVWF  FF8
02940:  CALL   1278
....................              if (scanf("%x %d", &address, &data_length)) {
02944:  MOVLB  1
02946:  CLRF   xDA
02948:  CLRF   xDB
0294A:  MOVLW  01
0294C:  MOVLB  2
0294E:  MOVWF  xE4
02950:  MOVLW  B5
02952:  MOVWF  xE3
02954:  CLRF   xE6
02956:  CLRF   xE5
02958:  MOVLB  0
0295A:  RCALL  2414
0295C:  MOVF   01,F
0295E:  BNZ   2968
02960:  MOVLB  1
02962:  CLRF   xDB
02964:  BRA    2998
02966:  MOVLB  0
02968:  MOVF   01,W
0296A:  MOVLB  1
0296C:  ADDWF  xDA,F
0296E:  INCF   xDB,F
02970:  CLRF   xDD
02972:  CLRF   xDC
02974:  MOVLW  01
02976:  MOVWF  xDF
02978:  MOVLW  D9
0297A:  MOVWF  xDE
0297C:  MOVLW  0A
0297E:  MOVWF  xE0
02980:  MOVLB  0
02982:  BRA    27BE
02984:  MOVF   01,F
02986:  BNZ   2990
02988:  MOVLB  1
0298A:  CLRF   xDB
0298C:  BRA    2998
0298E:  MOVLB  0
02990:  MOVF   01,W
02992:  MOVLB  1
02994:  ADDWF  xDA,F
02996:  INCF   xDB,F
02998:  MOVF   xDB,W
0299A:  BZ    2A2C
....................                  fprintf(EXT, "Address: 0x%09x, Length: %d\n", address, data_length);
0299C:  MOVLW  4A
0299E:  MOVWF  FF6
029A0:  MOVLW  05
029A2:  MOVWF  FF7
029A4:  MOVLW  00
029A6:  MOVWF  FF8
029A8:  MOVLW  0B
029AA:  MOVLB  2
029AC:  MOVWF  xED
029AE:  MOVLB  0
029B0:  CALL   13F0
029B4:  MOVLW  07
029B6:  MOVLB  1
029B8:  MOVWF  xDA
029BA:  MOVLW  30
029BC:  MOVLB  2
029BE:  MOVWF  xF3
029C0:  MOVLB  0
029C2:  CALL   1232
029C6:  MOVLB  1
029C8:  DECFSZ xDA,F
029CA:  BRA    29BA
029CC:  MOVFF  1B5,2ED
029D0:  MOVLW  57
029D2:  MOVLB  2
029D4:  MOVWF  xEE
029D6:  MOVLB  0
029D8:  CALL   16A2
029DC:  MOVLW  59
029DE:  MOVWF  FF6
029E0:  MOVLW  05
029E2:  MOVWF  FF7
029E4:  MOVLW  00
029E6:  MOVWF  FF8
029E8:  MOVLW  0A
029EA:  MOVLB  2
029EC:  MOVWF  xED
029EE:  MOVLB  0
029F0:  CALL   13F0
029F4:  MOVFF  1D9,2ED
029F8:  MOVLW  18
029FA:  MOVLB  2
029FC:  MOVWF  xEE
029FE:  MOVLB  0
02A00:  CALL   1706
02A04:  MOVLW  0A
02A06:  MOVLB  2
02A08:  MOVWF  xF3
02A0A:  MOVLB  0
02A0C:  CALL   1232
....................                  READ_DATA_NBYTES(address, data_length);  // Replace with actual function
02A10:  MOVFF  1B8,1DD
02A14:  MOVFF  1B7,1DC
02A18:  MOVFF  1B6,1DB
02A1C:  MOVFF  1B5,1DA
02A20:  MOVFF  1D9,1DE
02A24:  CALL   15B4
....................              } else {
02A28:  BRA    2A3E
02A2A:  MOVLB  1
....................                  fprintf(EXT, "Invalid input. Please enter a valid address and length.\n");
02A2C:  MOVLW  68
02A2E:  MOVWF  FF6
02A30:  MOVLW  05
02A32:  MOVWF  FF7
02A34:  MOVLW  00
02A36:  MOVWF  FF8
02A38:  MOVLB  0
02A3A:  CALL   1278
....................              }
....................              break;
02A3E:  BRA    2A52
....................  
....................          case 'x':
....................              return;
02A40:  BRA    2A52
....................          default:
....................              fprintf(EXT, "Invalid MAIN flash memory option. Please try again.\n");
02A42:  MOVLW  A2
02A44:  MOVWF  FF6
02A46:  MOVLW  05
02A48:  MOVWF  FF7
02A4A:  MOVLW  00
02A4C:  MOVWF  FF8
02A4E:  CALL   1278
....................              break;
....................      }
02A52:  GOTO   2B6C (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_flash_memories() {
....................      char flash_option;
....................      fprintf(EXT, "pressed option d: Check Flash Memories\n\n");
02A56:  MOVLW  D8
02A58:  MOVWF  FF6
02A5A:  MOVLW  05
02A5C:  MOVWF  FF7
02A5E:  MOVLW  00
02A60:  MOVWF  FF8
02A62:  CALL   1278
....................      fprintf(EXT, "Please choose which flash memory to work on (a, b, c, d, e):\n");
02A66:  MOVLW  02
02A68:  MOVWF  FF6
02A6A:  MOVLW  06
02A6C:  MOVWF  FF7
02A6E:  MOVLW  00
02A70:  MOVWF  FF8
02A72:  CALL   1278
....................      fprintf(EXT, "press a: MAIN flash memory\n");
02A76:  MOVLW  40
02A78:  MOVWF  FF6
02A7A:  MOVLW  06
02A7C:  MOVWF  FF7
02A7E:  MOVLW  00
02A80:  MOVWF  FF8
02A82:  CALL   1278
....................      fprintf(EXT, "press b: COM shared flash memory\n");
02A86:  MOVLW  5C
02A88:  MOVWF  FF6
02A8A:  MOVLW  06
02A8C:  MOVWF  FF7
02A8E:  MOVLW  00
02A90:  MOVWF  FF8
02A92:  CALL   1278
....................      fprintf(EXT, "press c: ADCS shared flash memory\n");
02A96:  MOVLW  7E
02A98:  MOVWF  FF6
02A9A:  MOVLW  06
02A9C:  MOVWF  FF7
02A9E:  MOVLW  00
02AA0:  MOVWF  FF8
02AA2:  CALL   1278
....................      fprintf(EXT, "press d: OVCAM shared flash memory\n");
02AA6:  MOVLW  A2
02AA8:  MOVWF  FF6
02AAA:  MOVLW  06
02AAC:  MOVWF  FF7
02AAE:  MOVLW  00
02AB0:  MOVWF  FF8
02AB2:  CALL   1278
....................      fprintf(EXT, "press e: MVCAM shared flash memory\n");
02AB6:  MOVLW  C6
02AB8:  MOVWF  FF6
02ABA:  MOVLW  06
02ABC:  MOVWF  FF7
02ABE:  MOVLW  00
02AC0:  MOVWF  FF8
02AC2:  CALL   1278
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
02AC6:  MOVLW  EA
02AC8:  MOVWF  FF6
02ACA:  MOVLW  06
02ACC:  MOVWF  FF7
02ACE:  MOVLW  00
02AD0:  MOVWF  FF8
02AD2:  CALL   1278
....................  
....................      flash_option = fgetc(EXT);
02AD6:  CALL   1E7E
02ADA:  MOVFF  01,1B3
....................  
....................      switch (flash_option) {
02ADE:  MOVLB  1
02AE0:  MOVF   xB3,W
02AE2:  XORLW  61
02AE4:  MOVLB  0
02AE6:  BZ    2AFE
02AE8:  XORLW  03
02AEA:  BZ    2B12
02AEC:  XORLW  01
02AEE:  BZ    2B24
02AF0:  XORLW  07
02AF2:  BZ    2B36
02AF4:  XORLW  01
02AF6:  BZ    2B48
02AF8:  XORLW  1D
02AFA:  BZ    2B5A
02AFC:  BRA    2B5C
....................          case 'a':
....................              fprintf(EXT, "MAIN shared flash memory chosen\n");
02AFE:  MOVLW  08
02B00:  MOVWF  FF6
02B02:  MOVLW  07
02B04:  MOVWF  FF7
02B06:  MOVLW  00
02B08:  MOVWF  FF8
02B0A:  CALL   1278
....................              handle_main_flash_memory();
02B0E:  BRA    289A
....................              break;
02B10:  BRA    2B6C
....................          case 'b':
....................              fprintf(EXT, "COM shared flash memory chosen\n");
02B12:  MOVLW  2A
02B14:  MOVWF  FF6
02B16:  MOVLW  07
02B18:  MOVWF  FF7
02B1A:  MOVLW  00
02B1C:  MOVWF  FF8
02B1E:  CALL   1278
....................              // Implement COM shared flash memory handling
....................              break;
02B22:  BRA    2B6C
....................          case 'c':
....................              fprintf(EXT, "ADCS shared flash memory chosen\n");
02B24:  MOVLW  4A
02B26:  MOVWF  FF6
02B28:  MOVLW  07
02B2A:  MOVWF  FF7
02B2C:  MOVLW  00
02B2E:  MOVWF  FF8
02B30:  CALL   1278
....................              // Implement ADCS shared flash memory handling
....................              break;
02B34:  BRA    2B6C
....................           case 'd':
....................              fprintf(EXT, "OVCAM shared flash memory chosen\n");
02B36:  MOVLW  6C
02B38:  MOVWF  FF6
02B3A:  MOVLW  07
02B3C:  MOVWF  FF7
02B3E:  MOVLW  00
02B40:  MOVWF  FF8
02B42:  CALL   1278
....................              // Implement ADCS shared flash memory handling
....................              break;
02B46:  BRA    2B6C
....................           case 'e':
....................              fprintf(EXT, "MVCAM shared flash memory chosen\n");
02B48:  MOVLW  8E
02B4A:  MOVWF  FF6
02B4C:  MOVLW  07
02B4E:  MOVWF  FF7
02B50:  MOVLW  00
02B52:  MOVWF  FF8
02B54:  CALL   1278
....................              // Implement ADCS shared flash memory handling
....................              break;
02B58:  BRA    2B6C
....................           case'x':
....................               break;
02B5A:  BRA    2B6C
....................          default:
....................              fprintf(EXT, "Invalid flash memory option. Please try again.\n");
02B5C:  MOVLW  B0
02B5E:  MOVWF  FF6
02B60:  MOVLW  07
02B62:  MOVWF  FF7
02B64:  MOVLW  00
02B66:  MOVWF  FF8
02B68:  CALL   1278
....................              break;
....................      }
02B6C:  RETURN 0
....................  }
....................  
....................  //main RTCC functions consol for main_menu() function
....................  void handle_set_time() {
....................      char handle_set_time_option;
....................      fprintf(EXT, "Settings of RTC chosen\n");
02B6E:  MOVLW  E0
02B70:  MOVWF  FF6
02B72:  MOVLW  07
02B74:  MOVWF  FF7
02B76:  MOVLW  00
02B78:  MOVWF  FF8
02B7A:  CALL   1278
....................      fprintf(EXT, "    press a: to reset the RTC /all current time will be set zero/\n");
02B7E:  MOVLW  F8
02B80:  MOVWF  FF6
02B82:  MOVLW  07
02B84:  MOVWF  FF7
02B86:  MOVLW  00
02B88:  MOVWF  FF8
02B8A:  CALL   1278
....................      fprintf(EXT, "    press b: display current time\n");
02B8E:  MOVLW  3C
02B90:  MOVWF  FF6
02B92:  MOVLW  08
02B94:  MOVWF  FF7
02B96:  MOVLW  00
02B98:  MOVWF  FF8
02B9A:  CALL   1278
....................      fprintf(EXT, "    press c: display current time nonstop\n");
02B9E:  MOVLW  60
02BA0:  MOVWF  FF6
02BA2:  MOVLW  08
02BA4:  MOVWF  FF7
02BA6:  MOVLW  00
02BA8:  MOVWF  FF8
02BAA:  CALL   1278
....................      handle_set_time_option = fgetc(EXT);
02BAE:  CALL   1E7E
02BB2:  MOVFF  01,1B2
....................  
....................      switch (handle_set_time_option) {
02BB6:  MOVLB  1
02BB8:  MOVF   xB2,W
02BBA:  XORLW  61
02BBC:  MOVLB  0
02BBE:  BZ    2BD4
02BC0:  XORLW  03
02BC2:  BTFSC  FD8.2
02BC4:  BRA    2E20
02BC6:  XORLW  01
02BC8:  BTFSC  FD8.2
02BCA:  BRA    2F08
02BCC:  XORLW  1B
02BCE:  BTFSC  FD8.2
02BD0:  BRA    3026
02BD2:  BRA    302A
....................          case 'a':
....................      rtc_time_t write_clock, read_clock;
....................      rtc_read(&read_clock);
02BD4:  MOVLB  F
02BD6:  BSF    x5F.0
02BD8:  BSF    x5F.1
02BDA:  MOVLW  01
02BDC:  MOVWF  FEA
02BDE:  MOVLW  BC
02BE0:  MOVWF  FE9
02BE2:  MOVLW  04
02BE4:  MOVWF  01
02BE6:  MOVF   x5C,W
02BE8:  MOVLB  0
02BEA:  CALL   1336
02BEE:  MOVWF  FEE
02BF0:  MOVLB  F
02BF2:  MOVF   x5D,W
02BF4:  MOVLB  0
02BF6:  CALL   1336
02BFA:  MOVWF  FEE
02BFC:  DECFSZ 01,F
02BFE:  BRA    2C02
02C00:  BRA    2C06
02C02:  MOVLB  F
02C04:  BRA    2BE6
....................      fprintf(EXT, "Now time is\n");
02C06:  MOVLW  8C
02C08:  MOVWF  FF6
02C0A:  MOVLW  08
02C0C:  MOVWF  FF7
02C0E:  MOVLW  00
02C10:  MOVWF  FF8
02C12:  CALL   1278
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02C16:  MOVLW  0D
02C18:  MOVLB  2
02C1A:  MOVWF  xF3
02C1C:  MOVLB  0
02C1E:  CALL   1232
02C22:  MOVFF  1BF,1C5
02C26:  MOVLW  01
02C28:  MOVLB  1
02C2A:  MOVWF  xC6
02C2C:  MOVLB  0
02C2E:  CALL   1374
02C32:  MOVLW  2F
02C34:  MOVLB  2
02C36:  MOVWF  xF3
02C38:  MOVLB  0
02C3A:  CALL   1232
02C3E:  MOVFF  1BE,1C5
02C42:  MOVLW  01
02C44:  MOVLB  1
02C46:  MOVWF  xC6
02C48:  MOVLB  0
02C4A:  CALL   1374
02C4E:  MOVLW  A4
02C50:  MOVWF  FF6
02C52:  MOVLW  08
02C54:  MOVWF  FF7
02C56:  MOVLW  00
02C58:  MOVWF  FF8
02C5A:  MOVLW  03
02C5C:  MOVLB  2
02C5E:  MOVWF  xED
02C60:  MOVLB  0
02C62:  CALL   13F0
02C66:  MOVFF  1BC,1C5
02C6A:  MOVLW  01
02C6C:  MOVLB  1
02C6E:  MOVWF  xC6
02C70:  MOVLB  0
02C72:  CALL   1374
02C76:  MOVLW  20
02C78:  MOVLB  2
02C7A:  MOVWF  xF3
02C7C:  MOVLB  0
02C7E:  CALL   1232
02C82:  MOVFF  1C0,1C5
02C86:  MOVLW  01
02C88:  MOVLB  1
02C8A:  MOVWF  xC6
02C8C:  MOVLB  0
02C8E:  CALL   1374
02C92:  MOVLW  3A
02C94:  MOVLB  2
02C96:  MOVWF  xF3
02C98:  MOVLB  0
02C9A:  CALL   1232
02C9E:  MOVFF  1C3,1C5
02CA2:  MOVLW  01
02CA4:  MOVLB  1
02CA6:  MOVWF  xC6
02CA8:  MOVLB  0
02CAA:  CALL   1374
02CAE:  MOVLW  3A
02CB0:  MOVLB  2
02CB2:  MOVWF  xF3
02CB4:  MOVLB  0
02CB6:  CALL   1232
02CBA:  MOVFF  1C2,1C5
02CBE:  MOVLW  01
02CC0:  MOVLB  1
02CC2:  MOVWF  xC6
02CC4:  MOVLB  0
02CC6:  CALL   1374
....................      fprintf(EXT, "Time changing function activated\n");
02CCA:  MOVLW  BC
02CCC:  MOVWF  FF6
02CCE:  MOVLW  08
02CD0:  MOVWF  FF7
02CD2:  MOVLW  00
02CD4:  MOVWF  FF8
02CD6:  CALL   1278
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
02CEC:  MOVLB  F
02CEE:  MOVLW  55
02CF0:  MOVWF  F7E
02CF2:  MOVLW  AA
02CF4:  MOVWF  F7E
02CF6:  BSF    x5F.5
02CF8:  BSF    x5F.0
02CFA:  BSF    x5F.1
02CFC:  MOVLW  01
02CFE:  MOVWF  FEA
02D00:  MOVLW  B3
02D02:  MOVWF  FE9
02D04:  MOVLW  04
02D06:  MOVWF  01
02D08:  MOVF   FEE,W
02D0A:  MOVLB  0
02D0C:  CALL   1312
02D10:  MOVLB  F
02D12:  MOVWF  x5C
02D14:  MOVF   FEE,W
02D16:  MOVLB  0
02D18:  CALL   1312
02D1C:  MOVLB  F
02D1E:  MOVWF  x5D
02D20:  DECFSZ 01,F
02D22:  BRA    2D08
02D24:  BCF    x5F.5
....................      fprintf(EXT, "Time successfully changed. Current time is:\n");
02D26:  MOVLW  DE
02D28:  MOVWF  FF6
02D2A:  MOVLW  08
02D2C:  MOVWF  FF7
02D2E:  MOVLW  00
02D30:  MOVWF  FF8
02D32:  MOVLB  0
02D34:  CALL   1278
....................      rtc_read(&read_clock);
02D38:  MOVLB  F
02D3A:  BSF    x5F.0
02D3C:  BSF    x5F.1
02D3E:  MOVLW  01
02D40:  MOVWF  FEA
02D42:  MOVLW  BC
02D44:  MOVWF  FE9
02D46:  MOVLW  04
02D48:  MOVWF  01
02D4A:  MOVF   x5C,W
02D4C:  MOVLB  0
02D4E:  CALL   1336
02D52:  MOVWF  FEE
02D54:  MOVLB  F
02D56:  MOVF   x5D,W
02D58:  MOVLB  0
02D5A:  CALL   1336
02D5E:  MOVWF  FEE
02D60:  DECFSZ 01,F
02D62:  BRA    2D66
02D64:  BRA    2D6A
02D66:  MOVLB  F
02D68:  BRA    2D4A
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02D6A:  MOVLW  0D
02D6C:  MOVLB  2
02D6E:  MOVWF  xF3
02D70:  MOVLB  0
02D72:  CALL   1232
02D76:  MOVFF  1BF,1C5
02D7A:  MOVLW  01
02D7C:  MOVLB  1
02D7E:  MOVWF  xC6
02D80:  MOVLB  0
02D82:  CALL   1374
02D86:  MOVLW  2F
02D88:  MOVLB  2
02D8A:  MOVWF  xF3
02D8C:  MOVLB  0
02D8E:  CALL   1232
02D92:  MOVFF  1BE,1C5
02D96:  MOVLW  01
02D98:  MOVLB  1
02D9A:  MOVWF  xC6
02D9C:  MOVLB  0
02D9E:  CALL   1374
02DA2:  MOVLW  16
02DA4:  MOVWF  FF6
02DA6:  MOVLW  09
02DA8:  MOVWF  FF7
02DAA:  MOVLW  00
02DAC:  MOVWF  FF8
02DAE:  MOVLW  03
02DB0:  MOVLB  2
02DB2:  MOVWF  xED
02DB4:  MOVLB  0
02DB6:  CALL   13F0
02DBA:  MOVFF  1BC,1C5
02DBE:  MOVLW  01
02DC0:  MOVLB  1
02DC2:  MOVWF  xC6
02DC4:  MOVLB  0
02DC6:  CALL   1374
02DCA:  MOVLW  20
02DCC:  MOVLB  2
02DCE:  MOVWF  xF3
02DD0:  MOVLB  0
02DD2:  CALL   1232
02DD6:  MOVFF  1C0,1C5
02DDA:  MOVLW  01
02DDC:  MOVLB  1
02DDE:  MOVWF  xC6
02DE0:  MOVLB  0
02DE2:  CALL   1374
02DE6:  MOVLW  3A
02DE8:  MOVLB  2
02DEA:  MOVWF  xF3
02DEC:  MOVLB  0
02DEE:  CALL   1232
02DF2:  MOVFF  1C3,1C5
02DF6:  MOVLW  01
02DF8:  MOVLB  1
02DFA:  MOVWF  xC6
02DFC:  MOVLB  0
02DFE:  CALL   1374
02E02:  MOVLW  3A
02E04:  MOVLB  2
02E06:  MOVWF  xF3
02E08:  MOVLB  0
02E0A:  CALL   1232
02E0E:  MOVFF  1C2,1C5
02E12:  MOVLW  01
02E14:  MOVLB  1
02E16:  MOVWF  xC6
02E18:  MOVLB  0
02E1A:  CALL   1374
....................      break;
02E1E:  BRA    303A
....................          case 'b':
....................              rtc_read(&read_clock);
02E20:  MOVLB  F
02E22:  BSF    x5F.0
02E24:  BSF    x5F.1
02E26:  MOVLW  01
02E28:  MOVWF  FEA
02E2A:  MOVLW  BC
02E2C:  MOVWF  FE9
02E2E:  MOVLW  04
02E30:  MOVWF  01
02E32:  MOVF   x5C,W
02E34:  MOVLB  0
02E36:  CALL   1336
02E3A:  MOVWF  FEE
02E3C:  MOVLB  F
02E3E:  MOVF   x5D,W
02E40:  MOVLB  0
02E42:  CALL   1336
02E46:  MOVWF  FEE
02E48:  DECFSZ 01,F
02E4A:  BRA    2E4E
02E4C:  BRA    2E52
02E4E:  MOVLB  F
02E50:  BRA    2E32
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02E52:  MOVLW  0D
02E54:  MOVLB  2
02E56:  MOVWF  xF3
02E58:  MOVLB  0
02E5A:  CALL   1232
02E5E:  MOVFF  1BF,1C5
02E62:  MOVLW  01
02E64:  MOVLB  1
02E66:  MOVWF  xC6
02E68:  MOVLB  0
02E6A:  CALL   1374
02E6E:  MOVLW  2F
02E70:  MOVLB  2
02E72:  MOVWF  xF3
02E74:  MOVLB  0
02E76:  CALL   1232
02E7A:  MOVFF  1BE,1C5
02E7E:  MOVLW  01
02E80:  MOVLB  1
02E82:  MOVWF  xC6
02E84:  MOVLB  0
02E86:  CALL   1374
02E8A:  MOVLW  38
02E8C:  MOVWF  FF6
02E8E:  MOVLW  09
02E90:  MOVWF  FF7
02E92:  MOVLW  00
02E94:  MOVWF  FF8
02E96:  MOVLW  03
02E98:  MOVLB  2
02E9A:  MOVWF  xED
02E9C:  MOVLB  0
02E9E:  CALL   13F0
02EA2:  MOVFF  1BC,1C5
02EA6:  MOVLW  01
02EA8:  MOVLB  1
02EAA:  MOVWF  xC6
02EAC:  MOVLB  0
02EAE:  CALL   1374
02EB2:  MOVLW  20
02EB4:  MOVLB  2
02EB6:  MOVWF  xF3
02EB8:  MOVLB  0
02EBA:  CALL   1232
02EBE:  MOVFF  1C0,1C5
02EC2:  MOVLW  01
02EC4:  MOVLB  1
02EC6:  MOVWF  xC6
02EC8:  MOVLB  0
02ECA:  CALL   1374
02ECE:  MOVLW  3A
02ED0:  MOVLB  2
02ED2:  MOVWF  xF3
02ED4:  MOVLB  0
02ED6:  CALL   1232
02EDA:  MOVFF  1C3,1C5
02EDE:  MOVLW  01
02EE0:  MOVLB  1
02EE2:  MOVWF  xC6
02EE4:  MOVLB  0
02EE6:  CALL   1374
02EEA:  MOVLW  3A
02EEC:  MOVLB  2
02EEE:  MOVWF  xF3
02EF0:  MOVLB  0
02EF2:  CALL   1232
02EF6:  MOVFF  1C2,1C5
02EFA:  MOVLW  01
02EFC:  MOVLB  1
02EFE:  MOVWF  xC6
02F00:  MOVLB  0
02F02:  CALL   1374
....................      break;
02F06:  BRA    303A
....................          case 'c':
....................                  while(true){
....................                      rtc_read(&read_clock);
02F08:  MOVLB  F
02F0A:  BSF    x5F.0
02F0C:  BSF    x5F.1
02F0E:  MOVLW  01
02F10:  MOVWF  FEA
02F12:  MOVLW  BC
02F14:  MOVWF  FE9
02F16:  MOVLW  04
02F18:  MOVWF  01
02F1A:  MOVF   x5C,W
02F1C:  MOVLB  0
02F1E:  CALL   1336
02F22:  MOVWF  FEE
02F24:  MOVLB  F
02F26:  MOVF   x5D,W
02F28:  MOVLB  0
02F2A:  CALL   1336
02F2E:  MOVWF  FEE
02F30:  DECFSZ 01,F
02F32:  BRA    2F36
02F34:  BRA    2F3A
02F36:  MOVLB  F
02F38:  BRA    2F1A
....................                      fprintf(EXT, "Now time is\n");
02F3A:  MOVLW  50
02F3C:  MOVWF  FF6
02F3E:  MOVLW  09
02F40:  MOVWF  FF7
02F42:  MOVLW  00
02F44:  MOVWF  FF8
02F46:  CALL   1278
....................                      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u\n", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);   
02F4A:  MOVLW  0D
02F4C:  MOVLB  2
02F4E:  MOVWF  xF3
02F50:  MOVLB  0
02F52:  CALL   1232
02F56:  MOVFF  1BF,1C5
02F5A:  MOVLW  01
02F5C:  MOVLB  1
02F5E:  MOVWF  xC6
02F60:  MOVLB  0
02F62:  CALL   1374
02F66:  MOVLW  2F
02F68:  MOVLB  2
02F6A:  MOVWF  xF3
02F6C:  MOVLB  0
02F6E:  CALL   1232
02F72:  MOVFF  1BE,1C5
02F76:  MOVLW  01
02F78:  MOVLB  1
02F7A:  MOVWF  xC6
02F7C:  MOVLB  0
02F7E:  CALL   1374
02F82:  MOVLW  68
02F84:  MOVWF  FF6
02F86:  MOVLW  09
02F88:  MOVWF  FF7
02F8A:  MOVLW  00
02F8C:  MOVWF  FF8
02F8E:  MOVLW  03
02F90:  MOVLB  2
02F92:  MOVWF  xED
02F94:  MOVLB  0
02F96:  CALL   13F0
02F9A:  MOVFF  1BC,1C5
02F9E:  MOVLW  01
02FA0:  MOVLB  1
02FA2:  MOVWF  xC6
02FA4:  MOVLB  0
02FA6:  CALL   1374
02FAA:  MOVLW  20
02FAC:  MOVLB  2
02FAE:  MOVWF  xF3
02FB0:  MOVLB  0
02FB2:  CALL   1232
02FB6:  MOVFF  1C0,1C5
02FBA:  MOVLW  01
02FBC:  MOVLB  1
02FBE:  MOVWF  xC6
02FC0:  MOVLB  0
02FC2:  CALL   1374
02FC6:  MOVLW  3A
02FC8:  MOVLB  2
02FCA:  MOVWF  xF3
02FCC:  MOVLB  0
02FCE:  CALL   1232
02FD2:  MOVFF  1C3,1C5
02FD6:  MOVLW  01
02FD8:  MOVLB  1
02FDA:  MOVWF  xC6
02FDC:  MOVLB  0
02FDE:  CALL   1374
02FE2:  MOVLW  3A
02FE4:  MOVLB  2
02FE6:  MOVWF  xF3
02FE8:  MOVLB  0
02FEA:  CALL   1232
02FEE:  MOVFF  1C2,1C5
02FF2:  MOVLW  01
02FF4:  MOVLB  1
02FF6:  MOVWF  xC6
02FF8:  MOVLB  0
02FFA:  CALL   1374
02FFE:  MOVLW  0A
03000:  MOVLB  2
03002:  MOVWF  xF3
03004:  MOVLB  0
03006:  CALL   1232
....................                      delay_ms(1000);
0300A:  MOVLW  04
0300C:  MOVLB  1
0300E:  MOVWF  xC5
03010:  MOVLW  FA
03012:  MOVWF  xCD
03014:  MOVLB  0
03016:  CALL   1208
0301A:  MOVLB  1
0301C:  DECFSZ xC5,F
0301E:  BRA    3010
03020:  MOVLB  0
03022:  BRA    2F08
....................                  }
....................              break;
03024:  BRA    303A
....................          case 'x':
....................              break;
03026:  BRA    303A
....................              return;
03028:  BRA    303A
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
0302A:  MOVLW  80
0302C:  MOVWF  FF6
0302E:  MOVLW  09
03030:  MOVWF  FF7
03032:  MOVLW  00
03034:  MOVWF  FF8
03036:  CALL   1278
....................      break;
....................              
....................  }
0303A:  GOTO   44AA (RETURN)
....................  }
....................  //main IO control consol for main_menu() function
....................  void handle_io_control() {
....................      char io_option;
....................      int8 state_of_pin;
....................  
....................      fprintf(EXT, "IO control chosen\n");
*
01EC8:  MOVLW  A6
01ECA:  MOVWF  FF6
01ECC:  MOVLW  09
01ECE:  MOVWF  FF7
01ED0:  MOVLW  00
01ED2:  MOVWF  FF8
01ED4:  CALL   1278
....................  
....................      // Check and display the state of each pin before providing options
....................      state_of_pin = input_state(EN_SUP_3V3_1);
01ED8:  MOVLB  1
01EDA:  CLRF   xB3
01EDC:  BTFSC  F81.0
01EDE:  INCF   xB3,F
....................      fprintf(EXT, "    press a: Toggle EN_SUP_3V3_1 /is currently/");
01EE0:  MOVLW  BA
01EE2:  MOVWF  FF6
01EE4:  MOVLW  09
01EE6:  MOVWF  FF7
01EE8:  MOVLW  00
01EEA:  MOVWF  FF8
01EEC:  MOVLB  0
01EEE:  CALL   1278
....................      if(state_of_pin == 1 ){
01EF2:  MOVLB  1
01EF4:  DECFSZ xB3,W
01EF6:  BRA    1F0E
....................          fprintf(EXT, "HIGH\n");
01EF8:  MOVLW  EA
01EFA:  MOVWF  FF6
01EFC:  MOVLW  09
01EFE:  MOVWF  FF7
01F00:  MOVLW  00
01F02:  MOVWF  FF8
01F04:  MOVLB  0
01F06:  CALL   1278
....................      }else if(state_of_pin == 0){
01F0A:  BRA    1F3A
01F0C:  MOVLB  1
01F0E:  MOVF   xB3,F
01F10:  BNZ   1F28
....................          fprintf(EXT, "LOW\n");
01F12:  MOVLW  F0
01F14:  MOVWF  FF6
01F16:  MOVLW  09
01F18:  MOVWF  FF7
01F1A:  MOVLW  00
01F1C:  MOVWF  FF8
01F1E:  MOVLB  0
01F20:  CALL   1278
....................      }else {
01F24:  BRA    1F3A
01F26:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
01F28:  MOVLW  F6
01F2A:  MOVWF  FF6
01F2C:  MOVLW  09
01F2E:  MOVWF  FF7
01F30:  MOVLW  00
01F32:  MOVWF  FF8
01F34:  MOVLB  0
01F36:  CALL   1278
....................      }
....................      state_of_pin = input_state(EN_SUP_3V3_2);
01F3A:  MOVLB  1
01F3C:  CLRF   xB3
01F3E:  BTFSC  F86.1
01F40:  INCF   xB3,F
....................      fprintf(EXT, "    press b: Toggle EN_SUP_3V3_2 /is currently/");
01F42:  MOVLW  00
01F44:  MOVWF  FF6
01F46:  MOVLW  0A
01F48:  MOVWF  FF7
01F4A:  MOVLW  00
01F4C:  MOVWF  FF8
01F4E:  MOVLB  0
01F50:  CALL   1278
....................      if(state_of_pin == 1 ){
01F54:  MOVLB  1
01F56:  DECFSZ xB3,W
01F58:  BRA    1F70
....................          fprintf(EXT, "HIGH\n");
01F5A:  MOVLW  30
01F5C:  MOVWF  FF6
01F5E:  MOVLW  0A
01F60:  MOVWF  FF7
01F62:  MOVLW  00
01F64:  MOVWF  FF8
01F66:  MOVLB  0
01F68:  CALL   1278
....................      }else if(state_of_pin == 0){
01F6C:  BRA    1F9C
01F6E:  MOVLB  1
01F70:  MOVF   xB3,F
01F72:  BNZ   1F8A
....................          fprintf(EXT, "LOW\n");
01F74:  MOVLW  36
01F76:  MOVWF  FF6
01F78:  MOVLW  0A
01F7A:  MOVWF  FF7
01F7C:  MOVLW  00
01F7E:  MOVWF  FF8
01F80:  MOVLB  0
01F82:  CALL   1278
....................      }else {
01F86:  BRA    1F9C
01F88:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
01F8A:  MOVLW  3C
01F8C:  MOVWF  FF6
01F8E:  MOVLW  0A
01F90:  MOVWF  FF7
01F92:  MOVLW  00
01F94:  MOVWF  FF8
01F96:  MOVLB  0
01F98:  CALL   1278
....................      }
....................       state_of_pin = input_state(EN_SUP_3V3_DAQ);
01F9C:  MOVLB  1
01F9E:  CLRF   xB3
01FA0:  BTFSC  F83.0
01FA2:  INCF   xB3,F
....................      fprintf(EXT, "    press c: Toggle EN_SUP_3V3_DAQ /is currently/");
01FA4:  MOVLW  46
01FA6:  MOVWF  FF6
01FA8:  MOVLW  0A
01FAA:  MOVWF  FF7
01FAC:  MOVLW  00
01FAE:  MOVWF  FF8
01FB0:  MOVLB  0
01FB2:  CALL   1278
....................      if(state_of_pin == 1 ){
01FB6:  MOVLB  1
01FB8:  DECFSZ xB3,W
01FBA:  BRA    1FD2
....................          fprintf(EXT, "HIGH\n");
01FBC:  MOVLW  78
01FBE:  MOVWF  FF6
01FC0:  MOVLW  0A
01FC2:  MOVWF  FF7
01FC4:  MOVLW  00
01FC6:  MOVWF  FF8
01FC8:  MOVLB  0
01FCA:  CALL   1278
....................      }else if(state_of_pin == 0){
01FCE:  BRA    1FFE
01FD0:  MOVLB  1
01FD2:  MOVF   xB3,F
01FD4:  BNZ   1FEC
....................          fprintf(EXT, "LOW\n");
01FD6:  MOVLW  7E
01FD8:  MOVWF  FF6
01FDA:  MOVLW  0A
01FDC:  MOVWF  FF7
01FDE:  MOVLW  00
01FE0:  MOVWF  FF8
01FE2:  MOVLB  0
01FE4:  CALL   1278
....................      }else {
01FE8:  BRA    1FFE
01FEA:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
01FEC:  MOVLW  84
01FEE:  MOVWF  FF6
01FF0:  MOVLW  0A
01FF2:  MOVWF  FF7
01FF4:  MOVLW  00
01FF6:  MOVWF  FF8
01FF8:  MOVLB  0
01FFA:  CALL   1278
....................      }
....................      state_of_pin = input_state(EN_SUP_UNREG);
01FFE:  MOVLB  1
02000:  CLRF   xB3
02002:  BTFSC  F81.1
02004:  INCF   xB3,F
....................      fprintf(EXT, "    press d: Toggle EN_SUP_UNREG /is currently/");
02006:  MOVLW  8E
02008:  MOVWF  FF6
0200A:  MOVLW  0A
0200C:  MOVWF  FF7
0200E:  MOVLW  00
02010:  MOVWF  FF8
02012:  MOVLB  0
02014:  CALL   1278
....................      if(state_of_pin == 1 ){
02018:  MOVLB  1
0201A:  DECFSZ xB3,W
0201C:  BRA    2034
....................          fprintf(EXT, "HIGH\n");
0201E:  MOVLW  BE
02020:  MOVWF  FF6
02022:  MOVLW  0A
02024:  MOVWF  FF7
02026:  MOVLW  00
02028:  MOVWF  FF8
0202A:  MOVLB  0
0202C:  CALL   1278
....................      }else if(state_of_pin == 0){
02030:  BRA    2060
02032:  MOVLB  1
02034:  MOVF   xB3,F
02036:  BNZ   204E
....................          fprintf(EXT, "LOW\n");
02038:  MOVLW  C4
0203A:  MOVWF  FF6
0203C:  MOVLW  0A
0203E:  MOVWF  FF7
02040:  MOVLW  00
02042:  MOVWF  FF8
02044:  MOVLB  0
02046:  CALL   1278
....................      }else {
0204A:  BRA    2060
0204C:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
0204E:  MOVLW  CA
02050:  MOVWF  FF6
02052:  MOVLW  0A
02054:  MOVWF  FF7
02056:  MOVLW  00
02058:  MOVWF  FF8
0205A:  MOVLB  0
0205C:  CALL   1278
....................      }
....................      state_of_pin = input_state(EN_SUP_5V0);
02060:  MOVLB  1
02062:  CLRF   xB3
02064:  BTFSC  F83.1
02066:  INCF   xB3,F
....................      fprintf(EXT, "    press e: Toggle EN_SUP_5V0 /is currently/");
02068:  MOVLW  D4
0206A:  MOVWF  FF6
0206C:  MOVLW  0A
0206E:  MOVWF  FF7
02070:  MOVLW  00
02072:  MOVWF  FF8
02074:  MOVLB  0
02076:  CALL   1278
....................      if(state_of_pin == 1 ){
0207A:  MOVLB  1
0207C:  DECFSZ xB3,W
0207E:  BRA    2096
....................          fprintf(EXT, "HIGH\n");
02080:  MOVLW  02
02082:  MOVWF  FF6
02084:  MOVLW  0B
02086:  MOVWF  FF7
02088:  MOVLW  00
0208A:  MOVWF  FF8
0208C:  MOVLB  0
0208E:  CALL   1278
....................      }else if(state_of_pin == 0){
02092:  BRA    20C2
02094:  MOVLB  1
02096:  MOVF   xB3,F
02098:  BNZ   20B0
....................          fprintf(EXT, "LOW\n");
0209A:  MOVLW  08
0209C:  MOVWF  FF6
0209E:  MOVLW  0B
020A0:  MOVWF  FF7
020A2:  MOVLW  00
020A4:  MOVWF  FF8
020A6:  MOVLB  0
020A8:  CALL   1278
....................      }else {
020AC:  BRA    20C2
020AE:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
020B0:  MOVLW  0E
020B2:  MOVWF  FF6
020B4:  MOVLW  0B
020B6:  MOVWF  FF7
020B8:  MOVLW  00
020BA:  MOVWF  FF8
020BC:  MOVLB  0
020BE:  CALL   1278
....................      }
....................      state_of_pin = input_state(KILL_SWITCH);
020C2:  MOVLB  1
020C4:  CLRF   xB3
020C6:  BTFSC  F80.4
020C8:  INCF   xB3,F
....................      fprintf(EXT, "    press f: Toggle KILL_SWITCH /is currently/");
020CA:  MOVLW  18
020CC:  MOVWF  FF6
020CE:  MOVLW  0B
020D0:  MOVWF  FF7
020D2:  MOVLW  00
020D4:  MOVWF  FF8
020D6:  MOVLB  0
020D8:  CALL   1278
....................      if(state_of_pin == 1 ){
020DC:  MOVLB  1
020DE:  DECFSZ xB3,W
020E0:  BRA    20F8
....................          fprintf(EXT, "HIGH\n");
020E2:  MOVLW  48
020E4:  MOVWF  FF6
020E6:  MOVLW  0B
020E8:  MOVWF  FF7
020EA:  MOVLW  00
020EC:  MOVWF  FF8
020EE:  MOVLB  0
020F0:  CALL   1278
....................      }else if(state_of_pin == 0){
020F4:  BRA    2124
020F6:  MOVLB  1
020F8:  MOVF   xB3,F
020FA:  BNZ   2112
....................          fprintf(EXT, "LOW\n");
020FC:  MOVLW  4E
020FE:  MOVWF  FF6
02100:  MOVLW  0B
02102:  MOVWF  FF7
02104:  MOVLW  00
02106:  MOVWF  FF8
02108:  MOVLB  0
0210A:  CALL   1278
....................      }else {
0210E:  BRA    2124
02110:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02112:  MOVLW  54
02114:  MOVWF  FF6
02116:  MOVLW  0B
02118:  MOVWF  FF7
0211A:  MOVLW  00
0211C:  MOVWF  FF8
0211E:  MOVLB  0
02120:  CALL   1278
....................      }
....................          state_of_pin = input_state(MVCAM_PWR);
02124:  MOVLB  1
02126:  CLRF   xB3
02128:  BTFSC  F86.0
0212A:  INCF   xB3,F
....................      fprintf(EXT, "    press g: Toggle MVCAM_PWR /is currently/");
0212C:  MOVLW  5E
0212E:  MOVWF  FF6
02130:  MOVLW  0B
02132:  MOVWF  FF7
02134:  MOVLW  00
02136:  MOVWF  FF8
02138:  MOVLB  0
0213A:  CALL   1278
....................      if(state_of_pin == 1 ){
0213E:  MOVLB  1
02140:  DECFSZ xB3,W
02142:  BRA    215A
....................          fprintf(EXT, "HIGH\n");
02144:  MOVLW  8C
02146:  MOVWF  FF6
02148:  MOVLW  0B
0214A:  MOVWF  FF7
0214C:  MOVLW  00
0214E:  MOVWF  FF8
02150:  MOVLB  0
02152:  CALL   1278
....................      }else if(state_of_pin == 0){
02156:  BRA    2186
02158:  MOVLB  1
0215A:  MOVF   xB3,F
0215C:  BNZ   2174
....................          fprintf(EXT, "LOW\n");
0215E:  MOVLW  92
02160:  MOVWF  FF6
02162:  MOVLW  0B
02164:  MOVWF  FF7
02166:  MOVLW  00
02168:  MOVWF  FF8
0216A:  MOVLB  0
0216C:  CALL   1278
....................      }else {
02170:  BRA    2186
02172:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02174:  MOVLW  98
02176:  MOVWF  FF6
02178:  MOVLW  0B
0217A:  MOVWF  FF7
0217C:  MOVLW  00
0217E:  MOVWF  FF8
02180:  MOVLB  0
02182:  CALL   1278
....................      }
....................          state_of_pin = input_state(OVCAM_PWR);
02186:  MOVLB  1
02188:  CLRF   xB3
0218A:  BTFSC  F83.7
0218C:  INCF   xB3,F
....................      fprintf(EXT, "    press h: Toggle OVCAM_PWR /is currently/");
0218E:  MOVLW  A2
02190:  MOVWF  FF6
02192:  MOVLW  0B
02194:  MOVWF  FF7
02196:  MOVLW  00
02198:  MOVWF  FF8
0219A:  MOVLB  0
0219C:  CALL   1278
....................      if(state_of_pin == 1 ){
021A0:  MOVLB  1
021A2:  DECFSZ xB3,W
021A4:  BRA    21BC
....................          fprintf(EXT, "HIGH\n");
021A6:  MOVLW  D0
021A8:  MOVWF  FF6
021AA:  MOVLW  0B
021AC:  MOVWF  FF7
021AE:  MOVLW  00
021B0:  MOVWF  FF8
021B2:  MOVLB  0
021B4:  CALL   1278
....................      }else if(state_of_pin == 0){
021B8:  BRA    21E8
021BA:  MOVLB  1
021BC:  MOVF   xB3,F
021BE:  BNZ   21D6
....................          fprintf(EXT, "LOW\n");
021C0:  MOVLW  D6
021C2:  MOVWF  FF6
021C4:  MOVLW  0B
021C6:  MOVWF  FF7
021C8:  MOVLW  00
021CA:  MOVWF  FF8
021CC:  MOVLB  0
021CE:  CALL   1278
....................      }else {
021D2:  BRA    21E8
021D4:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
021D6:  MOVLW  DC
021D8:  MOVWF  FF6
021DA:  MOVLW  0B
021DC:  MOVWF  FF7
021DE:  MOVLW  00
021E0:  MOVWF  FF8
021E2:  MOVLB  0
021E4:  CALL   1278
....................      }
....................          state_of_pin = input_state(ADCS_PWR);
021E8:  MOVLB  1
021EA:  CLRF   xB3
021EC:  BTFSC  F83.6
021EE:  INCF   xB3,F
....................      fprintf(EXT, "    press i: Toggle ADCS_PWR /is currently/");
021F0:  MOVLW  E6
021F2:  MOVWF  FF6
021F4:  MOVLW  0B
021F6:  MOVWF  FF7
021F8:  MOVLW  00
021FA:  MOVWF  FF8
021FC:  MOVLB  0
021FE:  CALL   1278
....................      if(state_of_pin == 1 ){
02202:  MOVLB  1
02204:  DECFSZ xB3,W
02206:  BRA    221E
....................          fprintf(EXT, "HIGH\n");
02208:  MOVLW  12
0220A:  MOVWF  FF6
0220C:  MOVLW  0C
0220E:  MOVWF  FF7
02210:  MOVLW  00
02212:  MOVWF  FF8
02214:  MOVLB  0
02216:  CALL   1278
....................      }else if(state_of_pin == 0){
0221A:  BRA    224A
0221C:  MOVLB  1
0221E:  MOVF   xB3,F
02220:  BNZ   2238
....................          fprintf(EXT, "LOW\n");
02222:  MOVLW  18
02224:  MOVWF  FF6
02226:  MOVLW  0C
02228:  MOVWF  FF7
0222A:  MOVLW  00
0222C:  MOVWF  FF8
0222E:  MOVLB  0
02230:  CALL   1278
....................      }else {
02234:  BRA    224A
02236:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02238:  MOVLW  1E
0223A:  MOVWF  FF6
0223C:  MOVLW  0C
0223E:  MOVWF  FF7
02240:  MOVLW  00
02242:  MOVWF  FF8
02244:  MOVLB  0
02246:  CALL   1278
....................      }
....................      fprintf(EXT, "    press j: Toggle all Pins");
0224A:  MOVLW  28
0224C:  MOVWF  FF6
0224E:  MOVLW  0C
02250:  MOVWF  FF7
02252:  MOVLW  00
02254:  MOVWF  FF8
02256:  CALL   1278
....................      
....................  
....................      io_option = fgetc(EXT);
0225A:  RCALL  1E7E
0225C:  MOVFF  01,1B2
....................  
....................      switch (io_option) {
02260:  MOVLB  1
02262:  MOVF   xB2,W
02264:  XORLW  61
02266:  MOVLB  0
02268:  BZ    2298
0226A:  XORLW  03
0226C:  BZ    229E
0226E:  XORLW  01
02270:  BZ    22A4
02272:  XORLW  07
02274:  BZ    22AA
02276:  XORLW  01
02278:  BZ    22B0
0227A:  XORLW  03
0227C:  BZ    22B6
0227E:  XORLW  01
02280:  BZ    22BC
02282:  XORLW  0F
02284:  BZ    22C2
02286:  XORLW  01
02288:  BZ    22C8
0228A:  XORLW  03
0228C:  BZ    22CE
0228E:  XORLW  01
02290:  BZ    22F0
02292:  XORLW  13
02294:  BZ    22F6
02296:  BRA    22FA
....................          case 'a':
....................              output_toggle(EN_SUP_3V3_1);
02298:  BCF    F93.0
0229A:  BTG    F8A.0
....................              break;
0229C:  BRA    230A
....................          case 'b':
....................              output_toggle(EN_SUP_3V3_2);
0229E:  BCF    F98.1
022A0:  BTG    F8F.1
....................              break;
022A2:  BRA    230A
....................          case 'c':
....................              output_toggle(EN_SUP_3V3_DAQ);
022A4:  BCF    F95.0
022A6:  BTG    F8C.0
....................              break;
022A8:  BRA    230A
....................          case 'd':
....................              output_toggle(EN_SUP_UNREG);
022AA:  BCF    F93.1
022AC:  BTG    F8A.1
....................              break;
022AE:  BRA    230A
....................          case 'e':
....................              output_toggle(EN_SUP_5V0);
022B0:  BCF    F95.1
022B2:  BTG    F8C.1
....................              break;
022B4:  BRA    230A
....................          case 'f':
....................              output_toggle(KILL_SWITCH);
022B6:  BCF    F92.4
022B8:  BTG    F89.4
....................              break;
022BA:  BRA    230A
....................          case 'g':
....................              output_toggle(MVCAM_PWR);
022BC:  BCF    F98.0
022BE:  BTG    F8F.0
....................              break;
022C0:  BRA    230A
....................          case 'h':
....................              output_toggle(OVCAM_PWR);        
022C2:  BCF    F95.7
022C4:  BTG    F8C.7
....................              break;
022C6:  BRA    230A
....................          case 'i':
....................              output_toggle(ADCS_PWR);        
022C8:  BCF    F95.6
022CA:  BTG    F8C.6
....................              break;    
022CC:  BRA    230A
....................          case 'j' :
....................              output_toggle(OVCAM_PWR);
022CE:  BCF    F95.7
022D0:  BTG    F8C.7
....................              output_toggle(MVCAM_PWR);  
022D2:  BCF    F98.0
022D4:  BTG    F8F.0
....................              output_toggle(KILL_SWITCH);
022D6:  BCF    F92.4
022D8:  BTG    F89.4
....................              output_toggle(EN_SUP_5V0);
022DA:  BCF    F95.1
022DC:  BTG    F8C.1
....................              output_toggle(EN_SUP_UNREG);
022DE:  BCF    F93.1
022E0:  BTG    F8A.1
....................              output_toggle(EN_SUP_3V3_DAQ);
022E2:  BCF    F95.0
022E4:  BTG    F8C.0
....................              output_toggle(EN_SUP_3V3_2);
022E6:  BCF    F98.1
022E8:  BTG    F8F.1
....................              output_toggle(EN_SUP_3V3_1);
022EA:  BCF    F93.0
022EC:  BTG    F8A.0
....................              break;
022EE:  BRA    230A
....................          case 'k' :
....................              output_toggle(MX_PIN_COM);
022F0:  BCF    F94.4
022F2:  BTG    F8B.4
....................              break;
022F4:  BRA    230A
....................          case 'x':
....................              break;
022F6:  BRA    230A
....................              return;
022F8:  BRA    230A
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
022FA:  MOVLW  46
022FC:  MOVWF  FF6
022FE:  MOVLW  0C
02300:  MOVWF  FF7
02302:  MOVLW  00
02304:  MOVWF  FF8
02306:  CALL   1278
....................              break;
....................      }
0230A:  GOTO   44AA (RETURN)
....................  }
....................  void testmode(void){
....................     fprintf(EXT, "    press a: ADCS mission mode\n");
*
0425A:  MOVLW  6C
0425C:  MOVWF  FF6
0425E:  MOVLW  0C
04260:  MOVWF  FF7
04262:  MOVLW  00
04264:  MOVWF  FF8
04266:  CALL   1278
....................     fprintf(EXT, "    press b: EPS mission mode\n");
0426A:  MOVLW  8C
0426C:  MOVWF  FF6
0426E:  MOVLW  0C
04270:  MOVWF  FF7
04272:  MOVLW  00
04274:  MOVWF  FF8
04276:  CALL   1278
....................     fprintf(EXT, "    press c: Check Flash Memories\n");
0427A:  MOVLW  AC
0427C:  MOVWF  FF6
0427E:  MOVLW  0C
04280:  MOVWF  FF7
04282:  MOVLW  00
04284:  MOVWF  FF8
04286:  CALL   1278
....................           //fprintf(EXT, "    press e: See satellite Log\n");
....................           char io_option;
....................             io_option = fgetc(EXT);
0428A:  CALL   1E7E
0428E:  MOVFF  01,1B2
....................             switch (io_option) {
04292:  MOVLB  1
04294:  MOVF   xB2,W
04296:  XORLW  61
04298:  MOVLB  0
0429A:  BZ    42A6
0429C:  XORLW  03
0429E:  BZ    42BC
042A0:  XORLW  01
042A2:  BZ    42D0
042A4:  BRA    42D6
....................               case 'a':
....................                 fprintf(EXT, "ADCS mission mode\n");
042A6:  MOVLW  D0
042A8:  MOVWF  FF6
042AA:  MOVLW  0C
042AC:  MOVWF  FF7
042AE:  MOVLW  00
042B0:  MOVWF  FF8
042B2:  CALL   1278
....................                 adcs_mission_mode();
042B6:  GOTO   3426
....................                 break;
042BA:  BRA    42E6
....................                 case 'b':
....................                 fprintf(EXT, "EPS mission mode\n");
042BC:  MOVLW  E4
042BE:  MOVWF  FF6
042C0:  MOVLW  0C
042C2:  MOVWF  FF7
042C4:  MOVLW  00
042C6:  MOVWF  FF8
042C8:  CALL   1278
....................                 eps_mission_mode();
042CC:  BRA    420E
....................                 break;
042CE:  BRA    42E6
....................                 case 'c':
....................                 handle_flash_memories();
042D0:  CALL   2A56
....................                 break;
042D4:  BRA    42E6
....................                 default:
....................                 fprintf(EXT, "Invalid IO option. Please try again.\n");
042D6:  MOVLW  F6
042D8:  MOVWF  FF6
042DA:  MOVLW  0C
042DC:  MOVWF  FF7
042DE:  MOVLW  00
042E0:  MOVWF  FF8
042E2:  CALL   1278
....................                 break;
....................    }
042E6:  GOTO   44AA (RETURN)
....................  }
....................          
.................... void main_menu(void) {
....................     char option;
....................   fprintf(EXT, " __  __ _____ _   _ _   _   _____                 _   _             \n");
042EA:  MOVLW  1C
042EC:  MOVWF  FF6
042EE:  MOVLW  0D
042F0:  MOVWF  FF7
042F2:  MOVLW  00
042F4:  MOVWF  FF8
042F6:  CALL   1278
....................   fprintf(EXT, "|  \\/  | ____| \\ | | | | | |  ___|   _ _ __   ___| |_(_) ___  _ __  \n");
042FA:  MOVLW  62
042FC:  MOVWF  FF6
042FE:  MOVLW  0D
04300:  MOVWF  FF7
04302:  MOVLW  00
04304:  MOVWF  FF8
04306:  CALL   1278
....................   fprintf(EXT, "| |\\/| |  _| |  \\| | | | | | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\ \n");
0430A:  MOVLW  A8
0430C:  MOVWF  FF6
0430E:  MOVLW  0D
04310:  MOVWF  FF7
04312:  MOVLW  00
04314:  MOVWF  FF8
04316:  CALL   1278
....................   fprintf(EXT, "| |  | | |___| |\\  | |_| | |  _|| |_| | | | | (__| |_| | (_) | | | |\n");
0431A:  MOVLW  EE
0431C:  MOVWF  FF6
0431E:  MOVLW  0D
04320:  MOVWF  FF7
04322:  MOVLW  00
04324:  MOVWF  FF8
04326:  CALL   1278
....................   fprintf(EXT, "|_| _|_|_____|_| \\_|\\___/  |_|_  \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|\n");
0432A:  MOVLW  34
0432C:  MOVWF  FF6
0432E:  MOVLW  0E
04330:  MOVWF  FF7
04332:  MOVLW  00
04334:  MOVWF  FF8
04336:  CALL   1278
....................   fprintf(EXT, "   / \\   ___| |_(_)_   ____ _| |_ ___  __| | |                      \n");
0433A:  MOVLW  7A
0433C:  MOVWF  FF6
0433E:  MOVLW  0E
04340:  MOVWF  FF7
04342:  MOVLW  00
04344:  MOVWF  FF8
04346:  CALL   1278
....................   fprintf(EXT, "  / _ \\ / __| __| \\ \\ / / _` | __/ _ \\/ _` | |                      \n");
0434A:  MOVLW  C0
0434C:  MOVWF  FF6
0434E:  MOVLW  0E
04350:  MOVWF  FF7
04352:  MOVLW  00
04354:  MOVWF  FF8
04356:  CALL   1278
....................   fprintf(EXT, " / ___ \\ (__| |_| |\\ V / (_| | ||  __/ (_| |_|                      \n");
0435A:  MOVLW  06
0435C:  MOVWF  FF6
0435E:  MOVLW  0F
04360:  MOVWF  FF7
04362:  MOVLW  00
04364:  MOVWF  FF8
04366:  CALL   1278
....................   fprintf(EXT, "/_/   \\_\\___|\\__|_| \\_/ \\__,_|\\__\\___|\\__,_(_)                      \n");
0436A:  MOVLW  4C
0436C:  MOVWF  FF6
0436E:  MOVLW  0F
04370:  MOVWF  FF7
04372:  MOVLW  00
04374:  MOVWF  FF8
04376:  CALL   1278
....................     
....................     while (1) {
....................         // Display Main Menu
....................         fprintf(EXT, "\n-----------------Main Menu-----------------\n");
0437A:  MOVLW  92
0437C:  MOVWF  FF6
0437E:  MOVLW  0F
04380:  MOVWF  FF7
04382:  MOVLW  00
04384:  MOVWF  FF8
04386:  CALL   1278
....................         //fprintf(EXT, "    press a: Get House keeping data\n");
....................         fprintf(EXT, "    press b: EPS Power output control\n");
0438A:  MOVLW  C0
0438C:  MOVWF  FF6
0438E:  MOVLW  0F
04390:  MOVWF  FF7
04392:  MOVLW  00
04394:  MOVWF  FF8
04396:  CALL   1278
....................         fprintf(EXT, "    press c: House keeping data collection\n");
0439A:  MOVLW  E8
0439C:  MOVWF  FF6
0439E:  MOVLW  0F
043A0:  MOVWF  FF7
043A2:  MOVLW  00
043A4:  MOVWF  FF8
043A6:  CALL   1278
....................         fprintf(EXT, "    press d: Check Flash Memories\n");
043AA:  MOVLW  14
043AC:  MOVWF  FF6
043AE:  MOVLW  10
043B0:  MOVWF  FF7
043B2:  MOVLW  00
043B4:  MOVWF  FF8
043B6:  CALL   1278
....................         //fprintf(EXT, "    press e: See satellite Log\n");
....................         fprintf(EXT, "    press f: Settings of RTC\n");
043BA:  MOVLW  38
043BC:  MOVWF  FF6
043BE:  MOVLW  10
043C0:  MOVWF  FF7
043C2:  MOVLW  00
043C4:  MOVWF  FF8
043C6:  CALL   1278
....................         //fprintf(EXT, "    press g: Satellite log down-link command\n");
....................         //fprintf(EXT, "    press h: IHC Mission start\n");
....................         //fprintf(EXT, "    press i: SEL current Measurement\n");
....................         //fprintf(EXT, "    press j: H8 COM Reset\n");
....................         fprintf(EXT, "    press k: UART repeater of EPS\n");
043CA:  MOVLW  56
043CC:  MOVWF  FF6
043CE:  MOVLW  10
043D0:  MOVWF  FF7
043D2:  MOVLW  00
043D4:  MOVWF  FF8
043D6:  CALL   1278
....................         fprintf(EXT, "    press l: testmode \n");
043DA:  MOVLW  7A
043DC:  MOVWF  FF6
043DE:  MOVLW  10
043E0:  MOVWF  FF7
043E2:  MOVLW  00
043E4:  MOVWF  FF8
043E6:  CALL   1278
....................         fprintf(EXT, "    press x: Exit Main Menu\n");
043EA:  MOVLW  92
043EC:  MOVWF  FF6
043EE:  MOVLW  10
043F0:  MOVWF  FF7
043F2:  MOVLW  00
043F4:  MOVWF  FF8
043F6:  CALL   1278
....................         fprintf(EXT, "    DO NOT USE CAPITAL CHARACTERS TO WRITE!\n\n");
043FA:  MOVLW  B0
043FC:  MOVWF  FF6
043FE:  MOVLW  10
04400:  MOVWF  FF7
04402:  MOVLW  00
04404:  MOVWF  FF8
04406:  CALL   1278
.................... 
....................         // Read the user's choice
....................         option = fgetc(EXT);
0440A:  CALL   1E7E
0440E:  MOVFF  01,1B1
.................... 
....................         // Main menu switch
....................         switch (option) {
04412:  MOVLB  1
04414:  MOVF   xB1,W
04416:  XORLW  61
04418:  MOVLB  0
0441A:  BZ    444E
0441C:  XORLW  03
0441E:  BZ    4450
04420:  XORLW  01
04422:  BZ    4456
04424:  XORLW  07
04426:  BZ    4458
04428:  XORLW  01
0442A:  BZ    445E
0442C:  XORLW  03
0442E:  BZ    4460
04430:  XORLW  01
04432:  BZ    4466
04434:  XORLW  0F
04436:  BZ    4468
04438:  XORLW  01
0443A:  BZ    446A
0443C:  XORLW  03
0443E:  BZ    446C
04440:  XORLW  01
04442:  BZ    446E
04444:  XORLW  07
04446:  BZ    4484
04448:  XORLW  14
0444A:  BZ    4498
0444C:  BRA    449A
....................             case 'a':
....................                 // Call a function to get housekeeping data
....................                 // get_housekeeping_data();
....................                 break;
0444E:  BRA    44AA
....................             case 'b':
....................                 // Call a function to control EPS power output
....................                 handle_io_control();
04450:  GOTO   1EC8
....................                 break;
04454:  BRA    44AA
....................             case 'c':
....................                 // Call a function to collect housekeeping data
....................                 // collect_housekeeping_data();
....................                 break;
04456:  BRA    44AA
....................             case 'd':
....................                 handle_flash_memories();
04458:  CALL   2A56
....................                 break;
0445C:  BRA    44AA
....................             case 'e':
....................                 // Call a function to see satellite log
....................                 // see_satellite_log();
....................                 break;
0445E:  BRA    44AA
....................             case 'f':
....................                 handle_set_time();
04460:  GOTO   2B6E
....................                 break;
04464:  BRA    44AA
....................             case 'g':
....................                 // Call a function for satellite log downlink command
....................                 // satellite_log_downlink_command();
....................                 break;
04466:  BRA    44AA
....................             case 'h':
....................                 // Call a function for IHC mission start
....................                 // ihc_mission_start();
....................                 break;
04468:  BRA    44AA
....................             case 'i':
....................                 // Call a function for SEL current measurement
....................                 // sel_current_measurement();
....................                 break;
0446A:  BRA    44AA
....................             case 'j':
....................                 // Call a function for H8 COM reset
....................                 // h8_com_reset();
....................                 break;
0446C:  BRA    44AA
....................             case 'k':
....................                 fprintf(EXT, "UART Repeater Initialized.\n");
0446E:  MOVLW  DE
04470:  MOVWF  FF6
04472:  MOVLW  10
04474:  MOVWF  FF7
04476:  MOVLW  00
04478:  MOVWF  FF8
0447A:  CALL   1278
....................                 uart_repeater();
0447E:  GOTO   3088
....................                 break;
04482:  BRA    44AA
....................             case 'l':
....................                 fprintf(EXT, "Testmode initialized\n");
04484:  MOVLW  FA
04486:  MOVWF  FF6
04488:  MOVLW  10
0448A:  MOVWF  FF7
0448C:  MOVLW  00
0448E:  MOVWF  FF8
04490:  CALL   1278
....................                 testmode();
04494:  BRA    425A
....................                 break;
04496:  BRA    44AA
....................                 
....................             case 'x':
....................                 return;
04498:  BRA    44AC
....................             default:
....................                 fprintf(EXT, "Invalid option. Please try again.\n");
0449A:  MOVLW  10
0449C:  MOVWF  FF6
0449E:  MOVLW  11
044A0:  MOVWF  FF7
044A2:  MOVLW  00
044A4:  MOVWF  FF8
044A6:  CALL   1278
....................                 break;
....................         }
044AA:  BRA    437A
....................     }
044AC:  GOTO   4792 (RETURN)
.................... }
.................... //void receive_16_bytes(int16* buffer) {
.................... //    for (int8 i = 0; i < 33; i++) {
.................... //        buffer[i] = getc(EPS);  // Blocks until a byte is received
.................... //    }
.................... //}
.................... //void EPS_DATA_ACQUISITION (){
.................... //        output_high(EN_SUP_3V3_DAQ);
.................... //    printf(EXT,"Power on!\n");
.................... //    int16 buffer[33];  // Buffer to hold the 16 bytes
.................... //    while (1) {
.................... //        printf(EXT,"sending request...\n");
.................... //        putc(cmd, EPS);
.................... //        // Receive 16 bytes into the buffer
.................... //        printf(EXT,"Waiting to respond...\n");
.................... //        receive_16_bytes(buffer);
.................... //        // Send the 16 bytes back via UART
.................... //        for (int8 i = 0; i < 33; i++) {
.................... //            putc(buffer[i], EXT);
.................... //        }
.................... //        printf("\n");
.................... //    }
.................... //}
.................... 
....................  
....................  #ifdef	__cplusplus
....................  }
....................  #endif
....................  
....................  #endif	/* MAIN_H */
....................  
....................  
.................... 
.................... 
.................... char bichig[25] = "test data update of MAIN"; //test data for testing 
.................... char bichigcom[24] = "test data update of COM"; //test data for testing 
.................... char bichigadcs[25] = "test data update of ADCS"; //test data for testing 
.................... char *read_data; //MAIN flash received data will be stored in here 
.................... unsigned char buffer[40]; //secondary buffer 
.................... char *read_data_com; //COM flash received data will be stored in here 
.................... 
.................... 
.................... void main() {
044B0:  CLRF   FF8
044B2:  BCF    FD0.7
044B4:  CLRF   F9B
044B6:  CLRF   F64
044B8:  CLRF   F65
044BA:  CLRF   F66
044BC:  MOVLW  02
044BE:  MOVWF  FD3
044C0:  BCF    F96.5
044C2:  BSF    F8D.5
044C4:  BCF    F94.6
044C6:  BSF    F8B.6
044C8:  BCF    F95.2
044CA:  BSF    F8C.2
044CC:  BCF    F97.7
044CE:  BSF    F8E.7
044D0:  BSF    F96.0
044D2:  BCF    F96.6
044D4:  BCF    F96.1
044D6:  BCF    F8D.1
044D8:  BSF    F93.5
044DA:  BCF    F93.4
044DC:  BCF    F93.2
044DE:  BCF    F8A.2
044E0:  BSF    F92.0
044E2:  BCF    F92.1
044E4:  BCF    F92.3
044E6:  BCF    F89.3
044E8:  MOVLB  1
044EA:  CLRF   x07
044EC:  CLRF   x06
044EE:  CLRF   x18
044F0:  CLRF   x19
044F2:  MOVLW  47
044F4:  MOVWF  x1A
044F6:  MOVLB  E
044F8:  CLRF   xD9
044FA:  CLRF   xDA
044FC:  CLRF   xCE
044FE:  CLRF   xCF
04500:  CLRF   xD0
04502:  CLRF   xD1
04504:  CLRF   xD2
04506:  CLRF   xD3
04508:  CLRF   xD4
0450A:  CLRF   xD5
0450C:  CLRF   x45
0450E:  CLRF   x46
04510:  CLRF   x47
04512:  BCF    x8D.7
04514:  BCF    x8D.6
04516:  BCF    x8D.5
04518:  MOVLB  F
0451A:  CLRF   x53
0451C:  CLRF   x38
0451E:  CLRF   x37
04520:  BRA    4584
04522:  DATA 02,00
04524:  DATA 04,00
04526:  DATA 00,09
04528:  DATA 01,0A
0452A:  DATA 33,05
0452C:  DATA 05,22
0452E:  DATA 01,05
04530:  DATA 11,01
04532:  DATA 05,05
04534:  DATA C0,00
04536:  DATA 4A,01
04538:  DATA 39,74
0453A:  DATA 65,73
0453C:  DATA 74,20
0453E:  DATA 64,61
04540:  DATA 74,61
04542:  DATA 20,75
04544:  DATA 70,64
04546:  DATA 61,74
04548:  DATA 65,20
0454A:  DATA 6F,66
0454C:  DATA 20,4D
0454E:  DATA 41,49
04550:  DATA 4E,00
04552:  DATA 74,65
04554:  DATA 73,74
04556:  DATA 20,64
04558:  DATA 61,74
0455A:  DATA 61,20
0455C:  DATA 75,70
0455E:  DATA 64,61
04560:  DATA 74,65
04562:  DATA 20,6F
04564:  DATA 66,20
04566:  DATA 43,4F
04568:  DATA 4D,00
0456A:  DATA 74,65
0456C:  DATA 73,74
0456E:  DATA 20,64
04570:  DATA 61,74
04572:  DATA 61,20
04574:  DATA 75,70
04576:  DATA 64,61
04578:  DATA 74,65
0457A:  DATA 20,6F
0457C:  DATA 66,20
0457E:  DATA 41,44
04580:  DATA 43,53
04582:  DATA 00,00
04584:  MOVLW  00
04586:  MOVWF  FF8
04588:  MOVLW  45
0458A:  MOVWF  FF7
0458C:  MOVLW  22
0458E:  MOVWF  FF6
04590:  TBLRD*+
04592:  MOVF   FF5,W
04594:  MOVWF  00
04596:  XORLW  00
04598:  BZ    45C0
0459A:  TBLRD*+
0459C:  MOVF   FF5,W
0459E:  MOVWF  01
045A0:  BTFSC  FE8.7
045A2:  BRA    45AE
045A4:  ANDLW  3F
045A6:  MOVWF  FEA
045A8:  TBLRD*+
045AA:  MOVFF  FF5,FE9
045AE:  BTFSC  01.6
045B0:  TBLRD*+
045B2:  BTFSS  01.6
045B4:  TBLRD*+
045B6:  MOVFF  FF5,FEE
045BA:  DCFSNZ 00,F
045BC:  BRA    4590
045BE:  BRA    45B2
045C0:  CLRF   FF8
....................     //------------------------Start_Indicator-------------------------
....................     startup_freeze();
045C2:  MOVLB  0
045C4:  GOTO   12A0
....................     //--------------------------RTC-----------------------------------
....................     RTC_initialize();
045C8:  GOTO   1420
....................     //------------------------restart_indicator-----------------------
....................     update_shutdown_count();
045CC:  GOTO   192A
....................     //------------------------read_chip_ID----------------------------
....................     fprintf(EXT, "Reading chip ID of main\n");
045D0:  MOVLW  34
045D2:  MOVWF  FF6
045D4:  MOVLW  11
045D6:  MOVWF  FF7
045D8:  MOVLW  00
045DA:  MOVWF  FF8
045DC:  CALL   1278
....................     // READ_CHIP_ID_GENERIC(SPIPORT, CS_PIN_1, -1);  // Pass the array to be filled by the function
....................     fprintf(EXT, "Reading chip ID of COM\n");
045E0:  MOVLW  4E
045E2:  MOVWF  FF6
045E4:  MOVLW  11
045E6:  MOVWF  FF7
045E8:  MOVLW  00
045EA:  MOVWF  FF8
045EC:  CALL   1278
....................     READ_CHIP_ID_OF_COM();
045F0:  GOTO   1A74
....................     fprintf(EXT, "Reading chip ID of ADCS\n");
045F4:  MOVLW  66
045F6:  MOVWF  FF6
045F8:  MOVLW  11
045FA:  MOVWF  FF7
045FC:  MOVLW  00
045FE:  MOVWF  FF8
04600:  CALL   1278
....................     READ_CHIP_ID_OF_ADCS();
04604:  CALL   1B4E
....................     fprintf(EXT, "Done reading chip ID\n");
04608:  MOVLW  80
0460A:  MOVWF  FF6
0460C:  MOVLW  11
0460E:  MOVWF  FF7
04610:  MOVLW  00
04612:  MOVWF  FF8
04614:  CALL   1278
....................     delay_ms(1000);
04618:  MOVLW  04
0461A:  MOVLB  1
0461C:  MOVWF  xB1
0461E:  MOVLW  FA
04620:  MOVWF  xCD
04622:  MOVLB  0
04624:  CALL   1208
04628:  MOVLB  1
0462A:  DECFSZ xB1,F
0462C:  BRA    461E
.................... 
....................     //------------------------write_flash_memory--------------------------
....................     // Write and read from MAIN flash memory 
....................     fprintf(EXT, "Starting to write data in MAIN flash memory\n");
0462E:  MOVLW  96
04630:  MOVWF  FF6
04632:  MOVLW  11
04634:  MOVWF  FF7
04636:  MOVLW  00
04638:  MOVWF  FF8
0463A:  MOVLB  0
0463C:  CALL   1278
....................     WRITE_DATA_NBYTES (0x00005000, bichig, sizeof(bichig));
04640:  MOVLB  2
04642:  CLRF   xE4
04644:  CLRF   xE3
04646:  MOVLW  50
04648:  MOVWF  xE2
0464A:  CLRF   xE1
0464C:  MOVLW  01
0464E:  MOVWF  xE6
04650:  MOVLW  39
04652:  MOVWF  xE5
04654:  MOVLW  19
04656:  MOVWF  xE7
04658:  MOVLB  0
0465A:  CALL   17C2
....................     delay_ms(1000);
0465E:  MOVLW  04
04660:  MOVLB  1
04662:  MOVWF  xB1
04664:  MOVLW  FA
04666:  MOVWF  xCD
04668:  MOVLB  0
0466A:  CALL   1208
0466E:  MOVLB  1
04670:  DECFSZ xB1,F
04672:  BRA    4664
....................     
....................     read_data = 
....................     (0x00005000, sizeof(bichig));
04674:  CLRF   x84
04676:  MOVLW  19
04678:  MOVWF  x83
....................     delay_ms(1000);
0467A:  MOVLW  04
0467C:  MOVWF  xB1
0467E:  MOVLW  FA
04680:  MOVWF  xCD
04682:  MOVLB  0
04684:  CALL   1208
04688:  MOVLB  1
0468A:  DECFSZ xB1,F
0468C:  BRA    467E
....................     for (int i = 0; i < sizeof(bichig); i++) {
0468E:  CLRF   xAF
04690:  MOVF   xAF,W
04692:  SUBLW  18
04694:  BNC   46BE
....................         fprintf(EXT, "%c", read_data[i]);
04696:  MOVF   xAF,W
04698:  ADDWF  x83,W
0469A:  MOVWF  FE9
0469C:  MOVLW  00
0469E:  ADDWFC x84,W
046A0:  MOVWF  FEA
046A2:  MOVFF  FEF,2F3
046A6:  MOVLB  0
046A8:  CALL   1232
....................         delay_ms(2);
046AC:  MOVLW  02
046AE:  MOVLB  1
046B0:  MOVWF  xCD
046B2:  MOVLB  0
046B4:  CALL   1208
046B8:  MOVLB  1
046BA:  INCF   xAF,F
046BC:  BRA    4690
....................     }
....................     fprintf(EXT, "\n"); 
046BE:  MOVLW  0A
046C0:  MOVLB  2
046C2:  MOVWF  xF3
046C4:  MOVLB  0
046C6:  CALL   1232
.................... 
....................     // Write and read from COM flash memory
....................     fprintf(EXT, "Starting to write data in COM flash memory\n");
046CA:  MOVLW  C4
046CC:  MOVWF  FF6
046CE:  MOVLW  11
046D0:  MOVWF  FF7
046D2:  MOVLW  00
046D4:  MOVWF  FF8
046D6:  CALL   1278
....................     WRITE_DATA_NBYTES_COM(0x00005000, bichigcom, sizeof(bichigcom));
046DA:  MOVLB  1
046DC:  CLRF   xB4
046DE:  CLRF   xB3
046E0:  MOVLW  50
046E2:  MOVWF  xB2
046E4:  CLRF   xB1
046E6:  MOVLW  01
046E8:  MOVWF  xB6
046EA:  MOVLW  52
046EC:  MOVWF  xB5
046EE:  MOVLW  18
046F0:  MOVWF  xB7
046F2:  MOVLB  0
046F4:  GOTO   1BFE
....................     delay_ms(1000);
046F8:  MOVLW  04
046FA:  MOVLB  1
046FC:  MOVWF  xB1
046FE:  MOVLW  FA
04700:  MOVWF  xCD
04702:  MOVLB  0
04704:  CALL   1208
04708:  MOVLB  1
0470A:  DECFSZ xB1,F
0470C:  BRA    46FE
....................     
....................     read_data_com = READ_DATA_NBYTES_COM(0x00005000, sizeof(bichigcom));
0470E:  CLRF   xB4
04710:  CLRF   xB3
04712:  MOVLW  50
04714:  MOVWF  xB2
04716:  CLRF   xB1
04718:  MOVLW  18
0471A:  MOVWF  xB5
0471C:  MOVLB  0
0471E:  GOTO   1D82
04722:  MOVFF  02,1AE
04726:  MOVFF  01,1AD
....................     delay_ms(1000);
0472A:  MOVLW  04
0472C:  MOVLB  1
0472E:  MOVWF  xB1
04730:  MOVLW  FA
04732:  MOVWF  xCD
04734:  MOVLB  0
04736:  CALL   1208
0473A:  MOVLB  1
0473C:  DECFSZ xB1,F
0473E:  BRA    4730
....................     for (int i = 0; i < sizeof(bichigcom); i++) {
04740:  CLRF   xB0
04742:  MOVF   xB0,W
04744:  SUBLW  17
04746:  BNC   4770
....................         fprintf(EXT, "%c", read_data_com[i]);
04748:  MOVF   xB0,W
0474A:  ADDWF  xAD,W
0474C:  MOVWF  FE9
0474E:  MOVLW  00
04750:  ADDWFC xAE,W
04752:  MOVWF  FEA
04754:  MOVFF  FEF,2F3
04758:  MOVLB  0
0475A:  CALL   1232
....................         delay_ms(2);
0475E:  MOVLW  02
04760:  MOVLB  1
04762:  MOVWF  xCD
04764:  MOVLB  0
04766:  CALL   1208
0476A:  MOVLB  1
0476C:  INCF   xB0,F
0476E:  BRA    4742
....................     }
....................     fprintf(EXT, "\n"); 
04770:  MOVLW  0A
04772:  MOVLB  2
04774:  MOVWF  xF3
04776:  MOVLB  0
04778:  CALL   1232
....................     
.................... //    // Write and read from ADCS flash memory
.................... //    fprintf(EXT, "Starting to write data in ADCS flash memory\n");
.................... //    WRITE_DATA_NBYTES_ADCS(0x00005000, bichigadcs, sizeof(bichigadcs));
.................... //    delay_ms(1000);
.................... //    
.................... //    read_data_adcs = READ_DATA_NBYTES_ADCS(0x00005000, sizeof(bichigadcs));
.................... //    delay_ms(1000);
.................... //    for (int i = 0; i < sizeof(bichigadcs); i++) {
.................... //        fprintf(EXT, "%c", read_data_adcs[i]);
.................... //        delay_ms(2);
.................... //    }
.................... //    fprintf(EXT, "\n"); // comment this line because it's not necessary for the adcs mission testing 
....................     fprintf(EXT, "MAIN TEST IS FINISHED!\n");
0477C:  MOVLW  F0
0477E:  MOVWF  FF6
04780:  MOVLW  11
04782:  MOVWF  FF7
04784:  MOVLW  00
04786:  MOVWF  FF8
04788:  CALL   1278
.................... 
....................     //------------------------send_and_write_adcs_mission--------------------------
.................... //    adcs_mission();
....................     //------------------------MAIN_MENU-------------------------------
....................     while (TRUE) {
....................         if (kbhit(EXT)) {
0478C:  BTFSC  F82.7
0478E:  BRA    4792
....................             main_menu();
04790:  BRA    42EA
....................         }
04792:  BRA    478C
....................     }
.................... }
04794:  BRA    4794

Configuration Fuses:
   Word  1: F600   NOSTVREN NOXINST DEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT_ DSWDT DSWDTOSC_INT

   Some fuses have been forced to be compatible with the ICD debugger.
