CCS PCH C Compiler, Version 5.112, 5967               11-Jan-26 19:33

               Filename:   C:\Users\ganga\Documents\------TEMUULEL------\TEST_REPORT\Enginering model\CODE\VSbased development\OBC\main.lst

               ROM used:   19258 bytes (15%)
                           Largest free fragment is 65520
               RAM used:   449 (13%) at main() level
                           779 (22%) worst case
               Stack used: 4 locations
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   482C
.................... #include <main.h>
.................... /* 
....................  * File:   main.h
....................  * Author: Ganji
....................  *
....................  * Created on October 22, 2024, 3:31 PM
....................  */
.................... 
....................  #ifndef MAIN_H
....................  #define	MAIN_H
....................  
....................  #ifdef	__cplusplus
....................  extern "C" {
....................  #endif
.................... 
....................  #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
00006:  DATA 57,52
00008:  DATA 49,54
0000A:  DATA 45,20
0000C:  DATA 41,44
0000E:  DATA 44,52
00010:  DATA 45,53
00012:  DATA 53,3A
00014:  DATA 20,30
00016:  DATA 78,25
00018:  DATA 30,38
0001A:  DATA 6C,78
0001C:  DATA 0A,00
0001E:  DATA 0A,25
00020:  DATA 64,20
00022:  DATA 42,59
00024:  DATA 54,45
00026:  DATA 53,20
00028:  DATA 57,52
0002A:  DATA 49,54
0002C:  DATA 54,45
0002E:  DATA 4E,20
00030:  DATA 49,4E
00032:  DATA 20,4D
00034:  DATA 41,49
00036:  DATA 4E,21
00038:  DATA 0A,00
0003A:  DATA 57,52
0003C:  DATA 49,54
0003E:  DATA 45,20
00040:  DATA 41,44
00042:  DATA 44,52
00044:  DATA 45,53
00046:  DATA 53,20
00048:  DATA 49,4E
0004A:  DATA 20,43
0004C:  DATA 4F,4D
0004E:  DATA 3A,20
00050:  DATA 30,78
00052:  DATA 25,30
00054:  DATA 38,6C
00056:  DATA 78,0A
00058:  DATA 00,00
0005A:  DATA 0A,25
0005C:  DATA 64,20
0005E:  DATA 42,59
00060:  DATA 54,45
00062:  DATA 53,20
00064:  DATA 57,52
00066:  DATA 49,54
00068:  DATA 54,45
0006A:  DATA 4E,20
0006C:  DATA 49,4E
0006E:  DATA 20,43
00070:  DATA 4F,4D
00072:  DATA 21,0A
00074:  DATA 00,00
00076:  DATA 57,52
00078:  DATA 49,54
0007A:  DATA 45,20
0007C:  DATA 41,44
0007E:  DATA 44,52
00080:  DATA 45,53
00082:  DATA 53,20
00084:  DATA 49,4E
00086:  DATA 20,41
00088:  DATA 44,43
0008A:  DATA 53,3A
0008C:  DATA 20,30
0008E:  DATA 78,25
00090:  DATA 30,38
00092:  DATA 6C,78
00094:  DATA 0A,00
00096:  DATA 0A,25
00098:  DATA 64,20
0009A:  DATA 42,59
0009C:  DATA 54,45
0009E:  DATA 53,20
000A0:  DATA 57,52
000A2:  DATA 49,54
000A4:  DATA 54,45
000A6:  DATA 4E,20
000A8:  DATA 49,4E
000AA:  DATA 20,41
000AC:  DATA 44,43
000AE:  DATA 53,21
000B0:  DATA 0A,00
000B2:  DATA 50,4F
000B4:  DATA 57,45
000B6:  DATA 52,20
000B8:  DATA 4F,4E
000BA:  DATA 21,0A
000BC:  DATA 00,00
000BE:  DATA 44,69
000C0:  DATA 67,69
000C2:  DATA 74,61
000C4:  DATA 6C,20
000C6:  DATA 70,69
000C8:  DATA 6E,20
000CA:  DATA 6F,75
000CC:  DATA 74,20
000CE:  DATA 63,6F
000D0:  DATA 6E,66
000D2:  DATA 69,67
000D4:  DATA 75,72
000D6:  DATA 65,64
000D8:  DATA 20,0A
000DA:  DATA 00,00
000DC:  DATA 0D,25
000DE:  DATA 30,32
000E0:  DATA 75,2F
000E2:  DATA 25,30
000E4:  DATA 32,75
000E6:  DATA 2F,32
000E8:  DATA 30,25
000EA:  DATA 30,32
000EC:  DATA 75,20
000EE:  DATA 25,30
000F0:  DATA 32,75
000F2:  DATA 3A,25
000F4:  DATA 30,32
000F6:  DATA 75,3A
000F8:  DATA 25,30
000FA:  DATA 32,75
000FC:  DATA 00,00
000FE:  DATA 52,54
00100:  DATA 43,43
00102:  DATA 20,73
00104:  DATA 65,74
00106:  DATA 75,70
00108:  DATA 20,66
0010A:  DATA 69,6E
0010C:  DATA 69,73
0010E:  DATA 68,65
00110:  DATA 64,21
00112:  DATA 0A,00
00114:  DATA 52,54
00116:  DATA 43,43
00118:  DATA 20,73
0011A:  DATA 65,74
0011C:  DATA 75,70
0011E:  DATA 20,66
00120:  DATA 69,6E
00122:  DATA 69,73
00124:  DATA 68,65
00126:  DATA 64,21
00128:  DATA 0A,00
0012A:  DATA 45,72
0012C:  DATA 61,73
0012E:  DATA 69,6E
00130:  DATA 67,20
00132:  DATA 41,44
00134:  DATA 43,53
00136:  DATA 20,63
00138:  DATA 6F,6D
0013A:  DATA 6D,61
0013C:  DATA 6E,64
0013E:  DATA 20,73
00140:  DATA 65,63
00142:  DATA 74,6F
00144:  DATA 72,2E
00146:  DATA 2E,2E
00148:  DATA 0A,00
0014A:  DATA 53,65
0014C:  DATA 6E,64
0014E:  DATA 69,6E
00150:  DATA 67,20
00152:  DATA 63,6F
00154:  DATA 6D,6D
00156:  DATA 61,6E
00158:  DATA 64,3A
0015A:  DATA 20,30
0015C:  DATA 78,33
0015E:  DATA 33,20
00160:  DATA 30,78
00162:  DATA 30,35
00164:  DATA 20,30
00166:  DATA 78,30
00168:  DATA 31,0A
0016A:  DATA 00,00
0016C:  DATA 56,65
0016E:  DATA 72,69
00170:  DATA 66,69
00172:  DATA 65,64
00174:  DATA 20,43
00176:  DATA 6F,6D
00178:  DATA 6D,61
0017A:  DATA 6E,64
0017C:  DATA 3A,20
0017E:  DATA 25,30
00180:  DATA 32,78
00182:  DATA 20,25
00184:  DATA 30,32
00186:  DATA 78,20
00188:  DATA 25,30
0018A:  DATA 32,78
0018C:  DATA 0A,00
0018E:  DATA 41,44
00190:  DATA 43,53
00192:  DATA 20,42
00194:  DATA 75,73
00196:  DATA 79,3A
00198:  DATA 20,25
0019A:  DATA 64,73
0019C:  DATA 20,2F
0019E:  DATA 20,32
001A0:  DATA 31,30
001A2:  DATA 73,0A
001A4:  DATA 00,00
001A6:  DATA 52,65
001A8:  DATA 61,64
001AA:  DATA 69,6E
001AC:  DATA 67,20
001AE:  DATA 73,74
001B0:  DATA 61,74
001B2:  DATA 75,73
001B4:  DATA 20,66
001B6:  DATA 72,6F
001B8:  DATA 6D,20
001BA:  DATA 30,78
001BC:  DATA 30,30
001BE:  DATA 30,32
001C0:  DATA 30,30
001C2:  DATA 30,30
001C4:  DATA 2E,2E
001C6:  DATA 2E,0A
001C8:  DATA 00,00
001CA:  DATA 46,41
001CC:  DATA 49,4C
001CE:  DATA 45,44
001D0:  DATA 3A,20
001D2:  DATA 41,44
001D4:  DATA 43,53
001D6:  DATA 20,72
001D8:  DATA 65,74
001DA:  DATA 75,72
001DC:  DATA 6E,65
001DE:  DATA 64,20
001E0:  DATA 69,6E
001E2:  DATA 76,61
001E4:  DATA 6C,69
001E6:  DATA 64,20
001E8:  DATA 73,74
001EA:  DATA 61,74
001EC:  DATA 75,73
001EE:  DATA 3A,20
001F0:  DATA 30,78
001F2:  DATA 25,30
001F4:  DATA 32,58
001F6:  DATA 0A,00
001F8:  DATA 53,55
001FA:  DATA 43,43
001FC:  DATA 45,53
001FE:  DATA 53,3A
00200:  DATA 20,25
00202:  DATA 75,20
00204:  DATA 6D,65
00206:  DATA 61,73
00208:  DATA 75,72
0020A:  DATA 65,6D
0020C:  DATA 65,6E
0020E:  DATA 74,73
00210:  DATA 20,66
00212:  DATA 6F,75
00214:  DATA 6E,64
00216:  DATA 2E,20
00218:  DATA 4C,61
0021A:  DATA 73,74
0021C:  DATA 20,41
0021E:  DATA 64,64
00220:  DATA 72,3A
00222:  DATA 20,30
00224:  DATA 78,25
00226:  DATA 30,38
00228:  DATA 6C,78
0022A:  DATA 0A,00
0022C:  DATA 44,61
0022E:  DATA 74,61
00230:  DATA 20,53
00232:  DATA 74,61
00234:  DATA 72,74
00236:  DATA 3A,20
00238:  DATA 30,78
0023A:  DATA 25,30
0023C:  DATA 38,6C
0023E:  DATA 78,0A
00240:  DATA 00,00
00242:  DATA 44,61
00244:  DATA 74,61
00246:  DATA 20,5B
00248:  DATA 25,75
0024A:  DATA 5D,20
0024C:  DATA 40,20
0024E:  DATA 30,78
00250:  DATA 25,30
00252:  DATA 38,6C
00254:  DATA 78,3A
00256:  DATA 20,00
00258:  DATA 52,65
0025A:  DATA 61,64
0025C:  DATA 69,6E
0025E:  DATA 67,20
00260:  DATA 73,74
00262:  DATA 61,74
00264:  DATA 75,73
00266:  DATA 20,66
00268:  DATA 72,6F
0026A:  DATA 6D,20
0026C:  DATA 30,78
0026E:  DATA 30,30
00270:  DATA 30,32
00272:  DATA 30,30
00274:  DATA 30,30
00276:  DATA 2E,2E
00278:  DATA 2E,0A
0027A:  DATA 00,00
0027C:  DATA 46,41
0027E:  DATA 49,4C
00280:  DATA 45,44
00282:  DATA 3A,20
00284:  DATA 41,44
00286:  DATA 43,53
00288:  DATA 20,72
0028A:  DATA 65,74
0028C:  DATA 75,72
0028E:  DATA 6E,65
00290:  DATA 64,20
00292:  DATA 69,6E
00294:  DATA 76,61
00296:  DATA 6C,69
00298:  DATA 64,20
0029A:  DATA 73,74
0029C:  DATA 61,74
0029E:  DATA 75,73
002A0:  DATA 3A,20
002A2:  DATA 30,78
002A4:  DATA 25,30
002A6:  DATA 32,58
002A8:  DATA 0A,00
002AA:  DATA 53,55
002AC:  DATA 43,43
002AE:  DATA 45,53
002B0:  DATA 53,3A
002B2:  DATA 20,25
002B4:  DATA 75,20
002B6:  DATA 6D,65
002B8:  DATA 61,73
002BA:  DATA 75,72
002BC:  DATA 65,6D
002BE:  DATA 65,6E
002C0:  DATA 74,73
002C2:  DATA 20,66
002C4:  DATA 6F,75
002C6:  DATA 6E,64
002C8:  DATA 2E,20
002CA:  DATA 4C,61
002CC:  DATA 73,74
002CE:  DATA 20,41
002D0:  DATA 64,64
002D2:  DATA 72,3A
002D4:  DATA 20,30
002D6:  DATA 78,25
002D8:  DATA 30,38
002DA:  DATA 6C,78
002DC:  DATA 0A,00
002DE:  DATA 44,61
002E0:  DATA 74,61
002E2:  DATA 20,53
002E4:  DATA 74,61
002E6:  DATA 72,74
002E8:  DATA 3A,20
002EA:  DATA 30,78
002EC:  DATA 25,30
002EE:  DATA 38,6C
002F0:  DATA 78,0A
002F2:  DATA 00,00
002F4:  DATA 54,69
002F6:  DATA 6D,65
002F8:  DATA 6F,75
002FA:  DATA 74,3A
002FC:  DATA 20,45
002FE:  DATA 50,53
00300:  DATA 20,48
00302:  DATA 65,61
00304:  DATA 64,65
00306:  DATA 72,20
00308:  DATA 6E,6F
0030A:  DATA 74,20
0030C:  DATA 66,6F
0030E:  DATA 75,6E
00310:  DATA 64,21
00312:  DATA 0A,00
00314:  DATA 4F,4E
00316:  DATA 00,00
00318:  DATA 4F,46
0031A:  DATA 46,00
0031C:  DATA 4F,4E
0031E:  DATA 00,00
00320:  DATA 4F,46
00322:  DATA 46,00
00324:  DATA 0A,2D
00326:  DATA 2D,2D
00328:  DATA 20,43
0032A:  DATA 41,4D
0032C:  DATA 20,4D
0032E:  DATA 49,53
00330:  DATA 53,49
00332:  DATA 4F,4E
00334:  DATA 20,53
00336:  DATA 54,41
00338:  DATA 52,54
0033A:  DATA 20,2D
0033C:  DATA 2D,2D
0033E:  DATA 0A,00
00340:  DATA 43,6F
00342:  DATA 6D,6D
00344:  DATA 61,6E
00346:  DATA 64,20
00348:  DATA 53,65
0034A:  DATA 6E,74
0034C:  DATA 3A,20
0034E:  DATA 63,25
00350:  DATA 75,20
00352:  DATA 28,43
00354:  DATA 61,70
00356:  DATA 74,75
00358:  DATA 72,65
0035A:  DATA 29,0A
0035C:  DATA 00,00
0035E:  DATA 43,6F
00360:  DATA 6D,6D
00362:  DATA 61,6E
00364:  DATA 64,20
00366:  DATA 53,65
00368:  DATA 6E,74
0036A:  DATA 3A,20
0036C:  DATA 76,25
0036E:  DATA 75,20
00370:  DATA 28,43
00372:  DATA 61,70
00374:  DATA 74,75
00376:  DATA 72,65
00378:  DATA 29,0A
0037A:  DATA 00,00
0037C:  DATA 57,61
0037E:  DATA 69,74
00380:  DATA 69,6E
00382:  DATA 67,20
00384:  DATA 66,6F
00386:  DATA 72,20
00388:  DATA 53,61
0038A:  DATA 76,65
0038C:  DATA 20,43
0038E:  DATA 6F,6E
00390:  DATA 66,69
00392:  DATA 72,6D
00394:  DATA 61,74
00396:  DATA 69,6F
00398:  DATA 6E,2E
0039A:  DATA 2E,2E
0039C:  DATA 0A,00
0039E:  DATA 45,52
003A0:  DATA 52,4F
003A2:  DATA 52,3A
003A4:  DATA 20,43
003A6:  DATA 61,6D
003A8:  DATA 65,72
003AA:  DATA 61,20
003AC:  DATA 74,69
003AE:  DATA 6D,65
003B0:  DATA 64,20
003B2:  DATA 6F,75
003B4:  DATA 74,20
003B6:  DATA 6F,72
003B8:  DATA 20,66
003BA:  DATA 61,69
003BC:  DATA 6C,65
003BE:  DATA 64,20
003C0:  DATA 74,6F
003C2:  DATA 20,73
003C4:  DATA 61,76
003C6:  DATA 65,21
003C8:  DATA 0A,00
003CA:  DATA 0A,43
003CC:  DATA 6F,6E
003CE:  DATA 66,69
003D0:  DATA 72,6D
003D2:  DATA 61,74
003D4:  DATA 69,6F
003D6:  DATA 6E,20
003D8:  DATA 52,65
003DA:  DATA 63,65
003DC:  DATA 69,76
003DE:  DATA 65,64
003E0:  DATA 21,20
003E2:  DATA 52,65
003E4:  DATA 71,75
003E6:  DATA 65,73
003E8:  DATA 74,69
003EA:  DATA 6E,67
003EC:  DATA 20,44
003EE:  DATA 6F,77
003F0:  DATA 6E,6C
003F2:  DATA 6F,61
003F4:  DATA 64,2E
003F6:  DATA 2E,2E
003F8:  DATA 0A,00
003FA:  DATA 0A,2D
003FC:  DATA 2D,2D
003FE:  DATA 20,43
00400:  DATA 41,4D
00402:  DATA 20,4D
00404:  DATA 49,53
00406:  DATA 53,49
00408:  DATA 4F,4E
0040A:  DATA 20,45
0040C:  DATA 4E,44
0040E:  DATA 45,44
00410:  DATA 20,28
00412:  DATA 42,79
00414:  DATA 74,65
00416:  DATA 73,3A
00418:  DATA 20,25
0041A:  DATA 6C,75
0041C:  DATA 29,20
0041E:  DATA 2D,2D
00420:  DATA 2D,0A
00422:  DATA 00,00
00424:  DATA 53,68
00426:  DATA 75,74
00428:  DATA 64,6F
0042A:  DATA 77,6E
0042C:  DATA 20,63
0042E:  DATA 6F,75
00430:  DATA 6E,74
00432:  DATA 20,73
00434:  DATA 74,61
00436:  DATA 72,74
00438:  DATA 65,64
0043A:  DATA 0A,00
0043C:  DATA 52,65
0043E:  DATA 61,64
00440:  DATA 20,73
00442:  DATA 68,75
00444:  DATA 74,64
00446:  DATA 6F,77
00448:  DATA 6E,20
0044A:  DATA 63,6F
0044C:  DATA 75,6E
0044E:  DATA 74,3A
00450:  DATA 20,25
00452:  DATA 75,0A
00454:  DATA 00,00
00456:  DATA 49,6E
00458:  DATA 63,72
0045A:  DATA 65,6D
0045C:  DATA 65,6E
0045E:  DATA 74,65
00460:  DATA 64,20
00462:  DATA 73,68
00464:  DATA 75,74
00466:  DATA 64,6F
00468:  DATA 77,6E
0046A:  DATA 20,63
0046C:  DATA 6F,75
0046E:  DATA 6E,74
00470:  DATA 3A,20
00472:  DATA 25,75
00474:  DATA 0A,00
00476:  DATA 4E,6F
00478:  DATA 77,20
0047A:  DATA 73,68
0047C:  DATA 75,74
0047E:  DATA 64,6F
00480:  DATA 77,6E
00482:  DATA 20,63
00484:  DATA 6F,75
00486:  DATA 6E,74
00488:  DATA 20,69
0048A:  DATA 73,20
0048C:  DATA 3A,20
0048E:  DATA 25,75
00490:  DATA 0A,0A
00492:  DATA 00,00
00494:  DATA 0A,45
00496:  DATA 6E,74
00498:  DATA 65,72
0049A:  DATA 20,41
0049C:  DATA 64,64
0049E:  DATA 72,65
004A0:  DATA 73,73
004A2:  DATA 20,28
004A4:  DATA 68,65
004A6:  DATA 78,2C
004A8:  DATA 20,30
004AA:  DATA 78,31
004AC:  DATA 32,33
004AE:  DATA 34,29
004B0:  DATA 3A,20
004B2:  DATA 30,78
004B4:  DATA 00,00
004B6:  DATA 0A,45
004B8:  DATA 6E,74
004BA:  DATA 65,72
004BC:  DATA 20,6E
004BE:  DATA 75,6D
004C0:  DATA 62,65
004C2:  DATA 72,20
004C4:  DATA 6F,66
004C6:  DATA 20,62
004C8:  DATA 79,74
004CA:  DATA 65,73
004CC:  DATA 20,74
004CE:  DATA 6F,20
004D0:  DATA 77,72
004D2:  DATA 69,74
004D4:  DATA 65,20
004D6:  DATA 28,6D
004D8:  DATA 61,78
004DA:  DATA 20,32
004DC:  DATA 35,36
004DE:  DATA 29,3A
004E0:  DATA 20,00
004E2:  DATA 45,6E
004E4:  DATA 74,65
004E6:  DATA 72,20
004E8:  DATA 25,64
004EA:  DATA 20,62
004EC:  DATA 79,74
004EE:  DATA 65,73
004F0:  DATA 20,6F
004F2:  DATA 66,20
004F4:  DATA 64,61
004F6:  DATA 74,61
004F8:  DATA 20,28
004FA:  DATA 69,6E
004FC:  DATA 20,68
004FE:  DATA 65,78
00500:  DATA 29,3A
00502:  DATA 0A,00
00504:  DATA 42,79
00506:  DATA 74,65
00508:  DATA 20,25
0050A:  DATA 64,3A
0050C:  DATA 20,30
0050E:  DATA 78,00
00510:  DATA 0A,44
00512:  DATA 61,74
00514:  DATA 61,20
00516:  DATA 73,75
00518:  DATA 63,63
0051A:  DATA 65,73
0051C:  DATA 73,66
0051E:  DATA 75,6C
00520:  DATA 6C,79
00522:  DATA 20,77
00524:  DATA 72,69
00526:  DATA 74,74
00528:  DATA 65,6E
0052A:  DATA 2E,0A
0052C:  DATA 00,00
0052E:  DATA 4D,41
00530:  DATA 49,4E
00532:  DATA 20,66
00534:  DATA 6C,61
00536:  DATA 73,68
00538:  DATA 20,6D
0053A:  DATA 65,6D
0053C:  DATA 6F,72
0053E:  DATA 79,20
00540:  DATA 63,68
00542:  DATA 6F,73
00544:  DATA 65,6E
00546:  DATA 0A,00
00548:  DATA 70,72
0054A:  DATA 65,73
0054C:  DATA 73,20
0054E:  DATA 61,3A
00550:  DATA 20,52
00552:  DATA 65,61
00554:  DATA 64,20
00556:  DATA 49,44
00558:  DATA 20,6F
0055A:  DATA 66,20
0055C:  DATA 74,68
0055E:  DATA 65,20
00560:  DATA 63,68
00562:  DATA 69,70
00564:  DATA 0A,00
00566:  DATA 70,72
00568:  DATA 65,73
0056A:  DATA 73,20
0056C:  DATA 62,3A
0056E:  DATA 20,57
00570:  DATA 72,69
00572:  DATA 74,65
00574:  DATA 20,64
00576:  DATA 61,74
00578:  DATA 61,20
0057A:  DATA 73,65
0057C:  DATA 74,20
0057E:  DATA 69,6E
00580:  DATA 20,73
00582:  DATA 70,65
00584:  DATA 63,69
00586:  DATA 66,69
00588:  DATA 65,64
0058A:  DATA 20,61
0058C:  DATA 64,64
0058E:  DATA 72,65
00590:  DATA 73,73
00592:  DATA 0A,00
00594:  DATA 70,72
00596:  DATA 65,73
00598:  DATA 73,20
0059A:  DATA 63,3A
0059C:  DATA 20,52
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 64,61
005A4:  DATA 74,61
005A6:  DATA 20,73
005A8:  DATA 65,74
005AA:  DATA 20,69
005AC:  DATA 6E,20
005AE:  DATA 73,70
005B0:  DATA 65,63
005B2:  DATA 69,66
005B4:  DATA 69,65
005B6:  DATA 64,20
005B8:  DATA 61,64
005BA:  DATA 64,72
005BC:  DATA 65,73
005BE:  DATA 73,0A
005C0:  DATA 00,00
005C2:  DATA 70,72
005C4:  DATA 65,73
005C6:  DATA 73,20
005C8:  DATA 78,3A
005CA:  DATA 20,52
005CC:  DATA 65,74
005CE:  DATA 75,72
005D0:  DATA 6E,20
005D2:  DATA 74,6F
005D4:  DATA 20,4D
005D6:  DATA 41,49
005D8:  DATA 4E,20
005DA:  DATA 4D,45
005DC:  DATA 4E,55
005DE:  DATA 0A,00
005E0:  DATA 53,74
005E2:  DATA 61,72
005E4:  DATA 74,65
005E6:  DATA 64,20
005E8:  DATA 72,65
005EA:  DATA 61,64
005EC:  DATA 69,6E
005EE:  DATA 67,20
005F0:  DATA 63,68
005F2:  DATA 69,70
005F4:  DATA 20,49
005F6:  DATA 44,20
005F8:  DATA 6F,66
005FA:  DATA 20,4D
005FC:  DATA 41,49
005FE:  DATA 4E,20
00600:  DATA 66,6C
00602:  DATA 61,73
00604:  DATA 68,20
00606:  DATA 6D,65
00608:  DATA 6D,6F
0060A:  DATA 72,79
0060C:  DATA 0A,00
0060E:  DATA 52,65
00610:  DATA 61,64
00612:  DATA 20,64
00614:  DATA 61,74
00616:  DATA 61,20
00618:  DATA 73,65
0061A:  DATA 74,20
0061C:  DATA 69,6E
0061E:  DATA 20,73
00620:  DATA 70,65
00622:  DATA 63,69
00624:  DATA 66,69
00626:  DATA 65,64
00628:  DATA 20,61
0062A:  DATA 64,64
0062C:  DATA 72,65
0062E:  DATA 73,73
00630:  DATA 0A,00
00632:  DATA 45,6E
00634:  DATA 74,65
00636:  DATA 72,20
00638:  DATA 79,6F
0063A:  DATA 75,72
0063C:  DATA 20,73
0063E:  DATA 70,65
00640:  DATA 63,69
00642:  DATA 66,69
00644:  DATA 65,64
00646:  DATA 20,61
00648:  DATA 64,64
0064A:  DATA 72,65
0064C:  DATA 73,73
0064E:  DATA 20,61
00650:  DATA 6E,64
00652:  DATA 20,6C
00654:  DATA 65,6E
00656:  DATA 67,74
00658:  DATA 68,20
0065A:  DATA 28,65
0065C:  DATA 2E,67
0065E:  DATA 2E,2C
00660:  DATA 20,30
00662:  DATA 78,31
00664:  DATA 32,33
00666:  DATA 34,20
00668:  DATA 31,30
0066A:  DATA 29,3A
0066C:  DATA 20,00
0066E:  DATA 41,64
00670:  DATA 64,72
00672:  DATA 65,73
00674:  DATA 73,3A
00676:  DATA 20,30
00678:  DATA 78,25
0067A:  DATA 30,39
0067C:  DATA 78,2C
0067E:  DATA 20,4C
00680:  DATA 65,6E
00682:  DATA 67,74
00684:  DATA 68,3A
00686:  DATA 20,25
00688:  DATA 64,0A
0068A:  DATA 00,00
0068C:  DATA 49,6E
0068E:  DATA 76,61
00690:  DATA 6C,69
00692:  DATA 64,20
00694:  DATA 69,6E
00696:  DATA 70,75
00698:  DATA 74,2E
0069A:  DATA 20,50
0069C:  DATA 6C,65
0069E:  DATA 61,73
006A0:  DATA 65,20
006A2:  DATA 65,6E
006A4:  DATA 74,65
006A6:  DATA 72,20
006A8:  DATA 61,20
006AA:  DATA 76,61
006AC:  DATA 6C,69
006AE:  DATA 64,20
006B0:  DATA 61,64
006B2:  DATA 64,72
006B4:  DATA 65,73
006B6:  DATA 73,20
006B8:  DATA 61,6E
006BA:  DATA 64,20
006BC:  DATA 6C,65
006BE:  DATA 6E,67
006C0:  DATA 74,68
006C2:  DATA 2E,0A
006C4:  DATA 00,00
006C6:  DATA 49,6E
006C8:  DATA 76,61
006CA:  DATA 6C,69
006CC:  DATA 64,20
006CE:  DATA 4D,41
006D0:  DATA 49,4E
006D2:  DATA 20,66
006D4:  DATA 6C,61
006D6:  DATA 73,68
006D8:  DATA 20,6D
006DA:  DATA 65,6D
006DC:  DATA 6F,72
006DE:  DATA 79,20
006E0:  DATA 6F,70
006E2:  DATA 74,69
006E4:  DATA 6F,6E
006E6:  DATA 2E,20
006E8:  DATA 50,6C
006EA:  DATA 65,61
006EC:  DATA 73,65
006EE:  DATA 20,74
006F0:  DATA 72,79
006F2:  DATA 20,61
006F4:  DATA 67,61
006F6:  DATA 69,6E
006F8:  DATA 2E,0A
006FA:  DATA 00,00
006FC:  DATA 70,72
006FE:  DATA 65,73
00700:  DATA 73,65
00702:  DATA 64,20
00704:  DATA 6F,70
00706:  DATA 74,69
00708:  DATA 6F,6E
0070A:  DATA 20,64
0070C:  DATA 3A,20
0070E:  DATA 43,68
00710:  DATA 65,63
00712:  DATA 6B,20
00714:  DATA 46,6C
00716:  DATA 61,73
00718:  DATA 68,20
0071A:  DATA 4D,65
0071C:  DATA 6D,6F
0071E:  DATA 72,69
00720:  DATA 65,73
00722:  DATA 0A,0A
00724:  DATA 00,00
00726:  DATA 50,6C
00728:  DATA 65,61
0072A:  DATA 73,65
0072C:  DATA 20,63
0072E:  DATA 68,6F
00730:  DATA 6F,73
00732:  DATA 65,20
00734:  DATA 77,68
00736:  DATA 69,63
00738:  DATA 68,20
0073A:  DATA 66,6C
0073C:  DATA 61,73
0073E:  DATA 68,20
00740:  DATA 6D,65
00742:  DATA 6D,6F
00744:  DATA 72,79
00746:  DATA 20,74
00748:  DATA 6F,20
0074A:  DATA 77,6F
0074C:  DATA 72,6B
0074E:  DATA 20,6F
00750:  DATA 6E,20
00752:  DATA 28,61
00754:  DATA 2C,20
00756:  DATA 62,2C
00758:  DATA 20,63
0075A:  DATA 2C,20
0075C:  DATA 64,2C
0075E:  DATA 20,65
00760:  DATA 29,3A
00762:  DATA 0A,00
00764:  DATA 70,72
00766:  DATA 65,73
00768:  DATA 73,20
0076A:  DATA 61,3A
0076C:  DATA 20,4D
0076E:  DATA 41,49
00770:  DATA 4E,20
00772:  DATA 66,6C
00774:  DATA 61,73
00776:  DATA 68,20
00778:  DATA 6D,65
0077A:  DATA 6D,6F
0077C:  DATA 72,79
0077E:  DATA 0A,00
00780:  DATA 70,72
00782:  DATA 65,73
00784:  DATA 73,20
00786:  DATA 62,3A
00788:  DATA 20,43
0078A:  DATA 4F,4D
0078C:  DATA 20,73
0078E:  DATA 68,61
00790:  DATA 72,65
00792:  DATA 64,20
00794:  DATA 66,6C
00796:  DATA 61,73
00798:  DATA 68,20
0079A:  DATA 6D,65
0079C:  DATA 6D,6F
0079E:  DATA 72,79
007A0:  DATA 0A,00
007A2:  DATA 70,72
007A4:  DATA 65,73
007A6:  DATA 73,20
007A8:  DATA 63,3A
007AA:  DATA 20,41
007AC:  DATA 44,43
007AE:  DATA 53,20
007B0:  DATA 73,68
007B2:  DATA 61,72
007B4:  DATA 65,64
007B6:  DATA 20,66
007B8:  DATA 6C,61
007BA:  DATA 73,68
007BC:  DATA 20,6D
007BE:  DATA 65,6D
007C0:  DATA 6F,72
007C2:  DATA 79,0A
007C4:  DATA 00,00
007C6:  DATA 70,72
007C8:  DATA 65,73
007CA:  DATA 73,20
007CC:  DATA 64,3A
007CE:  DATA 20,4F
007D0:  DATA 56,43
007D2:  DATA 41,4D
007D4:  DATA 20,73
007D6:  DATA 68,61
007D8:  DATA 72,65
007DA:  DATA 64,20
007DC:  DATA 66,6C
007DE:  DATA 61,73
007E0:  DATA 68,20
007E2:  DATA 6D,65
007E4:  DATA 6D,6F
007E6:  DATA 72,79
007E8:  DATA 0A,00
007EA:  DATA 70,72
007EC:  DATA 65,73
007EE:  DATA 73,20
007F0:  DATA 65,3A
007F2:  DATA 20,4D
007F4:  DATA 56,43
007F6:  DATA 41,4D
007F8:  DATA 20,73
007FA:  DATA 68,61
007FC:  DATA 72,65
007FE:  DATA 64,20
00800:  DATA 66,6C
00802:  DATA 61,73
00804:  DATA 68,20
00806:  DATA 6D,65
00808:  DATA 6D,6F
0080A:  DATA 72,79
0080C:  DATA 0A,00
0080E:  DATA 70,72
00810:  DATA 65,73
00812:  DATA 73,20
00814:  DATA 78,3A
00816:  DATA 20,52
00818:  DATA 65,74
0081A:  DATA 75,72
0081C:  DATA 6E,20
0081E:  DATA 74,6F
00820:  DATA 20,4D
00822:  DATA 41,49
00824:  DATA 4E,20
00826:  DATA 4D,45
00828:  DATA 4E,55
0082A:  DATA 0A,00
0082C:  DATA 4D,41
0082E:  DATA 49,4E
00830:  DATA 20,73
00832:  DATA 68,61
00834:  DATA 72,65
00836:  DATA 64,20
00838:  DATA 66,6C
0083A:  DATA 61,73
0083C:  DATA 68,20
0083E:  DATA 6D,65
00840:  DATA 6D,6F
00842:  DATA 72,79
00844:  DATA 20,63
00846:  DATA 68,6F
00848:  DATA 73,65
0084A:  DATA 6E,0A
0084C:  DATA 00,00
0084E:  DATA 43,4F
00850:  DATA 4D,20
00852:  DATA 73,68
00854:  DATA 61,72
00856:  DATA 65,64
00858:  DATA 20,66
0085A:  DATA 6C,61
0085C:  DATA 73,68
0085E:  DATA 20,6D
00860:  DATA 65,6D
00862:  DATA 6F,72
00864:  DATA 79,20
00866:  DATA 63,68
00868:  DATA 6F,73
0086A:  DATA 65,6E
0086C:  DATA 0A,00
0086E:  DATA 41,44
00870:  DATA 43,53
00872:  DATA 20,73
00874:  DATA 68,61
00876:  DATA 72,65
00878:  DATA 64,20
0087A:  DATA 66,6C
0087C:  DATA 61,73
0087E:  DATA 68,20
00880:  DATA 6D,65
00882:  DATA 6D,6F
00884:  DATA 72,79
00886:  DATA 20,63
00888:  DATA 68,6F
0088A:  DATA 73,65
0088C:  DATA 6E,0A
0088E:  DATA 00,00
00890:  DATA 4F,56
00892:  DATA 43,41
00894:  DATA 4D,20
00896:  DATA 73,68
00898:  DATA 61,72
0089A:  DATA 65,64
0089C:  DATA 20,66
0089E:  DATA 6C,61
008A0:  DATA 73,68
008A2:  DATA 20,6D
008A4:  DATA 65,6D
008A6:  DATA 6F,72
008A8:  DATA 79,20
008AA:  DATA 63,68
008AC:  DATA 6F,73
008AE:  DATA 65,6E
008B0:  DATA 0A,00
008B2:  DATA 4D,56
008B4:  DATA 43,41
008B6:  DATA 4D,20
008B8:  DATA 73,68
008BA:  DATA 61,72
008BC:  DATA 65,64
008BE:  DATA 20,66
008C0:  DATA 6C,61
008C2:  DATA 73,68
008C4:  DATA 20,6D
008C6:  DATA 65,6D
008C8:  DATA 6F,72
008CA:  DATA 79,20
008CC:  DATA 63,68
008CE:  DATA 6F,73
008D0:  DATA 65,6E
008D2:  DATA 0A,00
008D4:  DATA 49,6E
008D6:  DATA 76,61
008D8:  DATA 6C,69
008DA:  DATA 64,20
008DC:  DATA 66,6C
008DE:  DATA 61,73
008E0:  DATA 68,20
008E2:  DATA 6D,65
008E4:  DATA 6D,6F
008E6:  DATA 72,79
008E8:  DATA 20,6F
008EA:  DATA 70,74
008EC:  DATA 69,6F
008EE:  DATA 6E,2E
008F0:  DATA 20,50
008F2:  DATA 6C,65
008F4:  DATA 61,73
008F6:  DATA 65,20
008F8:  DATA 74,72
008FA:  DATA 79,20
008FC:  DATA 61,67
008FE:  DATA 61,69
00900:  DATA 6E,2E
00902:  DATA 0A,00
00904:  DATA 53,65
00906:  DATA 74,74
00908:  DATA 69,6E
0090A:  DATA 67,73
0090C:  DATA 20,6F
0090E:  DATA 66,20
00910:  DATA 52,54
00912:  DATA 43,20
00914:  DATA 63,68
00916:  DATA 6F,73
00918:  DATA 65,6E
0091A:  DATA 0A,00
0091C:  DATA 20,20
0091E:  DATA 20,20
00920:  DATA 70,72
00922:  DATA 65,73
00924:  DATA 73,20
00926:  DATA 61,3A
00928:  DATA 20,74
0092A:  DATA 6F,20
0092C:  DATA 72,65
0092E:  DATA 73,65
00930:  DATA 74,20
00932:  DATA 74,68
00934:  DATA 65,20
00936:  DATA 52,54
00938:  DATA 43,20
0093A:  DATA 2F,61
0093C:  DATA 6C,6C
0093E:  DATA 20,63
00940:  DATA 75,72
00942:  DATA 72,65
00944:  DATA 6E,74
00946:  DATA 20,74
00948:  DATA 69,6D
0094A:  DATA 65,20
0094C:  DATA 77,69
0094E:  DATA 6C,6C
00950:  DATA 20,62
00952:  DATA 65,20
00954:  DATA 73,65
00956:  DATA 74,20
00958:  DATA 7A,65
0095A:  DATA 72,6F
0095C:  DATA 2F,0A
0095E:  DATA 00,00
00960:  DATA 20,20
00962:  DATA 20,20
00964:  DATA 70,72
00966:  DATA 65,73
00968:  DATA 73,20
0096A:  DATA 62,3A
0096C:  DATA 20,64
0096E:  DATA 69,73
00970:  DATA 70,6C
00972:  DATA 61,79
00974:  DATA 20,63
00976:  DATA 75,72
00978:  DATA 72,65
0097A:  DATA 6E,74
0097C:  DATA 20,74
0097E:  DATA 69,6D
00980:  DATA 65,0A
00982:  DATA 00,00
00984:  DATA 20,20
00986:  DATA 20,20
00988:  DATA 70,72
0098A:  DATA 65,73
0098C:  DATA 73,20
0098E:  DATA 63,3A
00990:  DATA 20,64
00992:  DATA 69,73
00994:  DATA 70,6C
00996:  DATA 61,79
00998:  DATA 20,63
0099A:  DATA 75,72
0099C:  DATA 72,65
0099E:  DATA 6E,74
009A0:  DATA 20,74
009A2:  DATA 69,6D
009A4:  DATA 65,20
009A6:  DATA 6E,6F
009A8:  DATA 6E,73
009AA:  DATA 74,6F
009AC:  DATA 70,0A
009AE:  DATA 00,00
009B0:  DATA 4E,6F
009B2:  DATA 77,20
009B4:  DATA 74,69
009B6:  DATA 6D,65
009B8:  DATA 20,69
009BA:  DATA 73,0A
009BC:  DATA 00,00
009BE:  DATA 0D,25
009C0:  DATA 30,32
009C2:  DATA 75,2F
009C4:  DATA 25,30
009C6:  DATA 32,75
009C8:  DATA 2F,32
009CA:  DATA 30,25
009CC:  DATA 30,32
009CE:  DATA 75,20
009D0:  DATA 25,30
009D2:  DATA 32,75
009D4:  DATA 3A,25
009D6:  DATA 30,32
009D8:  DATA 75,3A
009DA:  DATA 25,30
009DC:  DATA 32,75
009DE:  DATA 00,00
009E0:  DATA 54,69
009E2:  DATA 6D,65
009E4:  DATA 20,63
009E6:  DATA 68,61
009E8:  DATA 6E,67
009EA:  DATA 69,6E
009EC:  DATA 67,20
009EE:  DATA 66,75
009F0:  DATA 6E,63
009F2:  DATA 74,69
009F4:  DATA 6F,6E
009F6:  DATA 20,61
009F8:  DATA 63,74
009FA:  DATA 69,76
009FC:  DATA 61,74
009FE:  DATA 65,64
00A00:  DATA 0A,00
00A02:  DATA 54,69
00A04:  DATA 6D,65
00A06:  DATA 20,73
00A08:  DATA 75,63
00A0A:  DATA 63,65
00A0C:  DATA 73,73
00A0E:  DATA 66,75
00A10:  DATA 6C,6C
00A12:  DATA 79,20
00A14:  DATA 63,68
00A16:  DATA 61,6E
00A18:  DATA 67,65
00A1A:  DATA 64,2E
00A1C:  DATA 20,43
00A1E:  DATA 75,72
00A20:  DATA 72,65
00A22:  DATA 6E,74
00A24:  DATA 20,74
00A26:  DATA 69,6D
00A28:  DATA 65,20
00A2A:  DATA 69,73
00A2C:  DATA 3A,0A
00A2E:  DATA 00,00
00A30:  DATA 0D,25
00A32:  DATA 30,32
00A34:  DATA 75,2F
00A36:  DATA 25,30
00A38:  DATA 32,75
00A3A:  DATA 2F,32
00A3C:  DATA 30,25
00A3E:  DATA 30,32
00A40:  DATA 75,20
00A42:  DATA 25,30
00A44:  DATA 32,75
00A46:  DATA 3A,25
00A48:  DATA 30,32
00A4A:  DATA 75,3A
00A4C:  DATA 25,30
00A4E:  DATA 32,75
00A50:  DATA 00,00
00A52:  DATA 0D,25
00A54:  DATA 30,32
00A56:  DATA 75,2F
00A58:  DATA 25,30
00A5A:  DATA 32,75
00A5C:  DATA 2F,32
00A5E:  DATA 30,25
00A60:  DATA 30,32
00A62:  DATA 75,20
00A64:  DATA 25,30
00A66:  DATA 32,75
00A68:  DATA 3A,25
00A6A:  DATA 30,32
00A6C:  DATA 75,3A
00A6E:  DATA 25,30
00A70:  DATA 32,75
00A72:  DATA 00,00
00A74:  DATA 4E,6F
00A76:  DATA 77,20
00A78:  DATA 74,69
00A7A:  DATA 6D,65
00A7C:  DATA 20,69
00A7E:  DATA 73,0A
00A80:  DATA 00,00
00A82:  DATA 0D,25
00A84:  DATA 30,32
00A86:  DATA 75,2F
00A88:  DATA 25,30
00A8A:  DATA 32,75
00A8C:  DATA 2F,32
00A8E:  DATA 30,25
00A90:  DATA 30,32
00A92:  DATA 75,20
00A94:  DATA 25,30
00A96:  DATA 32,75
00A98:  DATA 3A,25
00A9A:  DATA 30,32
00A9C:  DATA 75,3A
00A9E:  DATA 25,30
00AA0:  DATA 32,75
00AA2:  DATA 0A,00
00AA4:  DATA 49,6E
00AA6:  DATA 76,61
00AA8:  DATA 6C,69
00AAA:  DATA 64,20
00AAC:  DATA 49,4F
00AAE:  DATA 20,6F
00AB0:  DATA 70,74
00AB2:  DATA 69,6F
00AB4:  DATA 6E,2E
00AB6:  DATA 20,50
00AB8:  DATA 6C,65
00ABA:  DATA 61,73
00ABC:  DATA 65,20
00ABE:  DATA 74,72
00AC0:  DATA 79,20
00AC2:  DATA 61,67
00AC4:  DATA 61,69
00AC6:  DATA 6E,2E
00AC8:  DATA 0A,00
00ACA:  DATA 49,4F
00ACC:  DATA 20,63
00ACE:  DATA 6F,6E
00AD0:  DATA 74,72
00AD2:  DATA 6F,6C
00AD4:  DATA 20,63
00AD6:  DATA 68,6F
00AD8:  DATA 73,65
00ADA:  DATA 6E,0A
00ADC:  DATA 00,00
00ADE:  DATA 20,20
00AE0:  DATA 20,20
00AE2:  DATA 70,72
00AE4:  DATA 65,73
00AE6:  DATA 73,20
00AE8:  DATA 61,3A
00AEA:  DATA 20,54
00AEC:  DATA 6F,67
00AEE:  DATA 67,6C
00AF0:  DATA 65,20
00AF2:  DATA 45,4E
00AF4:  DATA 5F,53
00AF6:  DATA 55,50
00AF8:  DATA 5F,33
00AFA:  DATA 56,33
00AFC:  DATA 5F,31
00AFE:  DATA 20,2F
00B00:  DATA 69,73
00B02:  DATA 20,63
00B04:  DATA 75,72
00B06:  DATA 72,65
00B08:  DATA 6E,74
00B0A:  DATA 6C,79
00B0C:  DATA 2F,00
00B0E:  DATA 48,49
00B10:  DATA 47,48
00B12:  DATA 0A,00
00B14:  DATA 4C,4F
00B16:  DATA 57,0A
00B18:  DATA 00,00
00B1A:  DATA 49,6E
00B1C:  DATA 76,61
00B1E:  DATA 6C,69
00B20:  DATA 64,0A
00B22:  DATA 00,00
00B24:  DATA 20,20
00B26:  DATA 20,20
00B28:  DATA 70,72
00B2A:  DATA 65,73
00B2C:  DATA 73,20
00B2E:  DATA 62,3A
00B30:  DATA 20,54
00B32:  DATA 6F,67
00B34:  DATA 67,6C
00B36:  DATA 65,20
00B38:  DATA 45,4E
00B3A:  DATA 5F,53
00B3C:  DATA 55,50
00B3E:  DATA 5F,33
00B40:  DATA 56,33
00B42:  DATA 5F,32
00B44:  DATA 20,2F
00B46:  DATA 69,73
00B48:  DATA 20,63
00B4A:  DATA 75,72
00B4C:  DATA 72,65
00B4E:  DATA 6E,74
00B50:  DATA 6C,79
00B52:  DATA 2F,00
00B54:  DATA 48,49
00B56:  DATA 47,48
00B58:  DATA 0A,00
00B5A:  DATA 4C,4F
00B5C:  DATA 57,0A
00B5E:  DATA 00,00
00B60:  DATA 49,6E
00B62:  DATA 76,61
00B64:  DATA 6C,69
00B66:  DATA 64,0A
00B68:  DATA 00,00
00B6A:  DATA 20,20
00B6C:  DATA 20,20
00B6E:  DATA 70,72
00B70:  DATA 65,73
00B72:  DATA 73,20
00B74:  DATA 63,3A
00B76:  DATA 20,54
00B78:  DATA 6F,67
00B7A:  DATA 67,6C
00B7C:  DATA 65,20
00B7E:  DATA 45,4E
00B80:  DATA 5F,53
00B82:  DATA 55,50
00B84:  DATA 5F,33
00B86:  DATA 56,33
00B88:  DATA 5F,44
00B8A:  DATA 41,51
00B8C:  DATA 20,2F
00B8E:  DATA 69,73
00B90:  DATA 20,63
00B92:  DATA 75,72
00B94:  DATA 72,65
00B96:  DATA 6E,74
00B98:  DATA 6C,79
00B9A:  DATA 2F,00
00B9C:  DATA 48,49
00B9E:  DATA 47,48
00BA0:  DATA 0A,00
00BA2:  DATA 4C,4F
00BA4:  DATA 57,0A
00BA6:  DATA 00,00
00BA8:  DATA 49,6E
00BAA:  DATA 76,61
00BAC:  DATA 6C,69
00BAE:  DATA 64,0A
00BB0:  DATA 00,00
00BB2:  DATA 20,20
00BB4:  DATA 20,20
00BB6:  DATA 70,72
00BB8:  DATA 65,73
00BBA:  DATA 73,20
00BBC:  DATA 64,3A
00BBE:  DATA 20,54
00BC0:  DATA 6F,67
00BC2:  DATA 67,6C
00BC4:  DATA 65,20
00BC6:  DATA 45,4E
00BC8:  DATA 5F,53
00BCA:  DATA 55,50
00BCC:  DATA 5F,55
00BCE:  DATA 4E,52
00BD0:  DATA 45,47
00BD2:  DATA 20,2F
00BD4:  DATA 69,73
00BD6:  DATA 20,63
00BD8:  DATA 75,72
00BDA:  DATA 72,65
00BDC:  DATA 6E,74
00BDE:  DATA 6C,79
00BE0:  DATA 2F,00
00BE2:  DATA 48,49
00BE4:  DATA 47,48
00BE6:  DATA 0A,00
00BE8:  DATA 4C,4F
00BEA:  DATA 57,0A
00BEC:  DATA 00,00
00BEE:  DATA 49,6E
00BF0:  DATA 76,61
00BF2:  DATA 6C,69
00BF4:  DATA 64,0A
00BF6:  DATA 00,00
00BF8:  DATA 20,20
00BFA:  DATA 20,20
00BFC:  DATA 70,72
00BFE:  DATA 65,73
00C00:  DATA 73,20
00C02:  DATA 65,3A
00C04:  DATA 20,54
00C06:  DATA 6F,67
00C08:  DATA 67,6C
00C0A:  DATA 65,20
00C0C:  DATA 45,4E
00C0E:  DATA 5F,53
00C10:  DATA 55,50
00C12:  DATA 5F,35
00C14:  DATA 56,30
00C16:  DATA 20,2F
00C18:  DATA 69,73
00C1A:  DATA 20,63
00C1C:  DATA 75,72
00C1E:  DATA 72,65
00C20:  DATA 6E,74
00C22:  DATA 6C,79
00C24:  DATA 2F,00
00C26:  DATA 48,49
00C28:  DATA 47,48
00C2A:  DATA 0A,00
00C2C:  DATA 4C,4F
00C2E:  DATA 57,0A
00C30:  DATA 00,00
00C32:  DATA 49,6E
00C34:  DATA 76,61
00C36:  DATA 6C,69
00C38:  DATA 64,0A
00C3A:  DATA 00,00
00C3C:  DATA 20,20
00C3E:  DATA 20,20
00C40:  DATA 70,72
00C42:  DATA 65,73
00C44:  DATA 73,20
00C46:  DATA 66,3A
00C48:  DATA 20,54
00C4A:  DATA 6F,67
00C4C:  DATA 67,6C
00C4E:  DATA 65,20
00C50:  DATA 4B,49
00C52:  DATA 4C,4C
00C54:  DATA 5F,53
00C56:  DATA 57,49
00C58:  DATA 54,43
00C5A:  DATA 48,20
00C5C:  DATA 2F,69
00C5E:  DATA 73,20
00C60:  DATA 63,75
00C62:  DATA 72,72
00C64:  DATA 65,6E
00C66:  DATA 74,6C
00C68:  DATA 79,2F
00C6A:  DATA 00,00
00C6C:  DATA 48,49
00C6E:  DATA 47,48
00C70:  DATA 0A,00
00C72:  DATA 4C,4F
00C74:  DATA 57,0A
00C76:  DATA 00,00
00C78:  DATA 49,6E
00C7A:  DATA 76,61
00C7C:  DATA 6C,69
00C7E:  DATA 64,0A
00C80:  DATA 00,00
00C82:  DATA 20,20
00C84:  DATA 20,20
00C86:  DATA 70,72
00C88:  DATA 65,73
00C8A:  DATA 73,20
00C8C:  DATA 67,3A
00C8E:  DATA 20,54
00C90:  DATA 6F,67
00C92:  DATA 67,6C
00C94:  DATA 65,20
00C96:  DATA 4D,56
00C98:  DATA 43,41
00C9A:  DATA 4D,5F
00C9C:  DATA 50,57
00C9E:  DATA 52,20
00CA0:  DATA 2F,69
00CA2:  DATA 73,20
00CA4:  DATA 63,75
00CA6:  DATA 72,72
00CA8:  DATA 65,6E
00CAA:  DATA 74,6C
00CAC:  DATA 79,2F
00CAE:  DATA 00,00
00CB0:  DATA 48,49
00CB2:  DATA 47,48
00CB4:  DATA 0A,00
00CB6:  DATA 4C,4F
00CB8:  DATA 57,0A
00CBA:  DATA 00,00
00CBC:  DATA 49,6E
00CBE:  DATA 76,61
00CC0:  DATA 6C,69
00CC2:  DATA 64,0A
00CC4:  DATA 00,00
00CC6:  DATA 20,20
00CC8:  DATA 20,20
00CCA:  DATA 70,72
00CCC:  DATA 65,73
00CCE:  DATA 73,20
00CD0:  DATA 68,3A
00CD2:  DATA 20,54
00CD4:  DATA 6F,67
00CD6:  DATA 67,6C
00CD8:  DATA 65,20
00CDA:  DATA 4F,56
00CDC:  DATA 43,41
00CDE:  DATA 4D,5F
00CE0:  DATA 50,57
00CE2:  DATA 52,20
00CE4:  DATA 2F,69
00CE6:  DATA 73,20
00CE8:  DATA 63,75
00CEA:  DATA 72,72
00CEC:  DATA 65,6E
00CEE:  DATA 74,6C
00CF0:  DATA 79,2F
00CF2:  DATA 00,00
00CF4:  DATA 48,49
00CF6:  DATA 47,48
00CF8:  DATA 0A,00
00CFA:  DATA 4C,4F
00CFC:  DATA 57,0A
00CFE:  DATA 00,00
00D00:  DATA 49,6E
00D02:  DATA 76,61
00D04:  DATA 6C,69
00D06:  DATA 64,0A
00D08:  DATA 00,00
00D0A:  DATA 20,20
00D0C:  DATA 20,20
00D0E:  DATA 70,72
00D10:  DATA 65,73
00D12:  DATA 73,20
00D14:  DATA 69,3A
00D16:  DATA 20,54
00D18:  DATA 6F,67
00D1A:  DATA 67,6C
00D1C:  DATA 65,20
00D1E:  DATA 41,44
00D20:  DATA 43,53
00D22:  DATA 5F,50
00D24:  DATA 57,52
00D26:  DATA 20,2F
00D28:  DATA 69,73
00D2A:  DATA 20,63
00D2C:  DATA 75,72
00D2E:  DATA 72,65
00D30:  DATA 6E,74
00D32:  DATA 6C,79
00D34:  DATA 2F,00
00D36:  DATA 48,49
00D38:  DATA 47,48
00D3A:  DATA 0A,00
00D3C:  DATA 4C,4F
00D3E:  DATA 57,0A
00D40:  DATA 00,00
00D42:  DATA 49,6E
00D44:  DATA 76,61
00D46:  DATA 6C,69
00D48:  DATA 64,0A
00D4A:  DATA 00,00
00D4C:  DATA 20,20
00D4E:  DATA 20,20
00D50:  DATA 70,72
00D52:  DATA 65,73
00D54:  DATA 73,20
00D56:  DATA 6A,3A
00D58:  DATA 20,54
00D5A:  DATA 6F,67
00D5C:  DATA 67,6C
00D5E:  DATA 65,20
00D60:  DATA 61,6C
00D62:  DATA 6C,20
00D64:  DATA 50,69
00D66:  DATA 6E,73
00D68:  DATA 00,00
00D6A:  DATA 49,6E
00D6C:  DATA 76,61
00D6E:  DATA 6C,69
00D70:  DATA 64,20
00D72:  DATA 49,4F
00D74:  DATA 20,6F
00D76:  DATA 70,74
00D78:  DATA 69,6F
00D7A:  DATA 6E,2E
00D7C:  DATA 20,50
00D7E:  DATA 6C,65
00D80:  DATA 61,73
00D82:  DATA 65,20
00D84:  DATA 74,72
00D86:  DATA 79,20
00D88:  DATA 61,67
00D8A:  DATA 61,69
00D8C:  DATA 6E,2E
00D8E:  DATA 0A,00
00D90:  DATA 20,20
00D92:  DATA 20,20
00D94:  DATA 70,72
00D96:  DATA 65,73
00D98:  DATA 73,20
00D9A:  DATA 61,3A
00D9C:  DATA 20,41
00D9E:  DATA 44,43
00DA0:  DATA 53,20
00DA2:  DATA 6D,69
00DA4:  DATA 73,73
00DA6:  DATA 69,6F
00DA8:  DATA 6E,20
00DAA:  DATA 6D,6F
00DAC:  DATA 64,65
00DAE:  DATA 0A,00
00DB0:  DATA 20,20
00DB2:  DATA 20,20
00DB4:  DATA 70,72
00DB6:  DATA 65,73
00DB8:  DATA 73,20
00DBA:  DATA 62,3A
00DBC:  DATA 20,45
00DBE:  DATA 50,53
00DC0:  DATA 20,6D
00DC2:  DATA 69,73
00DC4:  DATA 73,69
00DC6:  DATA 6F,6E
00DC8:  DATA 20,6D
00DCA:  DATA 6F,64
00DCC:  DATA 65,0A
00DCE:  DATA 00,00
00DD0:  DATA 20,20
00DD2:  DATA 20,20
00DD4:  DATA 70,72
00DD6:  DATA 65,73
00DD8:  DATA 73,20
00DDA:  DATA 63,3A
00DDC:  DATA 20,43
00DDE:  DATA 68,65
00DE0:  DATA 63,6B
00DE2:  DATA 20,46
00DE4:  DATA 6C,61
00DE6:  DATA 73,68
00DE8:  DATA 20,4D
00DEA:  DATA 65,6D
00DEC:  DATA 6F,72
00DEE:  DATA 69,65
00DF0:  DATA 73,0A
00DF2:  DATA 00,00
00DF4:  DATA 41,44
00DF6:  DATA 43,53
00DF8:  DATA 20,6D
00DFA:  DATA 69,73
00DFC:  DATA 73,69
00DFE:  DATA 6F,6E
00E00:  DATA 20,6D
00E02:  DATA 6F,64
00E04:  DATA 65,0A
00E06:  DATA 00,00
00E08:  DATA 45,50
00E0A:  DATA 53,20
00E0C:  DATA 6D,69
00E0E:  DATA 73,73
00E10:  DATA 69,6F
00E12:  DATA 6E,20
00E14:  DATA 6D,6F
00E16:  DATA 64,65
00E18:  DATA 0A,00
00E1A:  DATA 49,6E
00E1C:  DATA 76,61
00E1E:  DATA 6C,69
00E20:  DATA 64,20
00E22:  DATA 49,4F
00E24:  DATA 20,6F
00E26:  DATA 70,74
00E28:  DATA 69,6F
00E2A:  DATA 6E,2E
00E2C:  DATA 20,50
00E2E:  DATA 6C,65
00E30:  DATA 61,73
00E32:  DATA 65,20
00E34:  DATA 74,72
00E36:  DATA 79,20
00E38:  DATA 61,67
00E3A:  DATA 61,69
00E3C:  DATA 6E,2E
00E3E:  DATA 0A,00
00E40:  DATA 20,5F
00E42:  DATA 5F,20
00E44:  DATA 20,5F
00E46:  DATA 5F,20
00E48:  DATA 5F,5F
00E4A:  DATA 5F,5F
00E4C:  DATA 5F,20
00E4E:  DATA 5F,20
00E50:  DATA 20,20
00E52:  DATA 5F,20
00E54:  DATA 5F,20
00E56:  DATA 20,20
00E58:  DATA 5F,20
00E5A:  DATA 20,20
00E5C:  DATA 5F,5F
00E5E:  DATA 5F,5F
00E60:  DATA 5F,20
00E62:  DATA 20,20
00E64:  DATA 20,20
00E66:  DATA 20,20
00E68:  DATA 20,20
00E6A:  DATA 20,20
00E6C:  DATA 20,20
00E6E:  DATA 20,20
00E70:  DATA 20,20
00E72:  DATA 5F,20
00E74:  DATA 20,20
00E76:  DATA 5F,20
00E78:  DATA 20,20
00E7A:  DATA 20,20
00E7C:  DATA 20,20
00E7E:  DATA 20,20
00E80:  DATA 20,20
00E82:  DATA 20,20
00E84:  DATA 0A,00
00E86:  DATA 7C,20
00E88:  DATA 20,5C
00E8A:  DATA 2F,20
00E8C:  DATA 20,7C
00E8E:  DATA 20,5F
00E90:  DATA 5F,5F
00E92:  DATA 5F,7C
00E94:  DATA 20,5C
00E96:  DATA 20,7C
00E98:  DATA 20,7C
00E9A:  DATA 20,7C
00E9C:  DATA 20,7C
00E9E:  DATA 20,7C
00EA0:  DATA 20,7C
00EA2:  DATA 20,20
00EA4:  DATA 5F,5F
00EA6:  DATA 5F,7C
00EA8:  DATA 20,20
00EAA:  DATA 20,5F
00EAC:  DATA 20,5F
00EAE:  DATA 20,5F
00EB0:  DATA 5F,20
00EB2:  DATA 20,20
00EB4:  DATA 5F,5F
00EB6:  DATA 5F,7C
00EB8:  DATA 20,7C
00EBA:  DATA 5F,28
00EBC:  DATA 5F,29
00EBE:  DATA 20,5F
00EC0:  DATA 5F,5F
00EC2:  DATA 20,20
00EC4:  DATA 5F,20
00EC6:  DATA 5F,5F
00EC8:  DATA 20,20
00ECA:  DATA 0A,00
00ECC:  DATA 7C,20
00ECE:  DATA 7C,5C
00ED0:  DATA 2F,7C
00ED2:  DATA 20,7C
00ED4:  DATA 20,20
00ED6:  DATA 5F,7C
00ED8:  DATA 20,7C
00EDA:  DATA 20,20
00EDC:  DATA 5C,7C
00EDE:  DATA 20,7C
00EE0:  DATA 20,7C
00EE2:  DATA 20,7C
00EE4:  DATA 20,7C
00EE6:  DATA 20,7C
00EE8:  DATA 20,7C
00EEA:  DATA 5F,20
00EEC:  DATA 7C,20
00EEE:  DATA 7C,20
00EF0:  DATA 7C,20
00EF2:  DATA 7C,20
00EF4:  DATA 27,5F
00EF6:  DATA 20,5C
00EF8:  DATA 20,2F
00EFA:  DATA 20,5F
00EFC:  DATA 5F,7C
00EFE:  DATA 20,5F
00F00:  DATA 5F,7C
00F02:  DATA 20,7C
00F04:  DATA 2F,20
00F06:  DATA 5F,20
00F08:  DATA 5C,7C
00F0A:  DATA 20,27
00F0C:  DATA 5F,20
00F0E:  DATA 5C,20
00F10:  DATA 0A,00
00F12:  DATA 7C,20
00F14:  DATA 7C,20
00F16:  DATA 20,7C
00F18:  DATA 20,7C
00F1A:  DATA 20,7C
00F1C:  DATA 5F,5F
00F1E:  DATA 5F,7C
00F20:  DATA 20,7C
00F22:  DATA 5C,20
00F24:  DATA 20,7C
00F26:  DATA 20,7C
00F28:  DATA 5F,7C
00F2A:  DATA 20,7C
00F2C:  DATA 20,7C
00F2E:  DATA 20,20
00F30:  DATA 5F,7C
00F32:  DATA 7C,20
00F34:  DATA 7C,5F
00F36:  DATA 7C,20
00F38:  DATA 7C,20
00F3A:  DATA 7C,20
00F3C:  DATA 7C,20
00F3E:  DATA 7C,20
00F40:  DATA 28,5F
00F42:  DATA 5F,7C
00F44:  DATA 20,7C
00F46:  DATA 5F,7C
00F48:  DATA 20,7C
00F4A:  DATA 20,28
00F4C:  DATA 5F,29
00F4E:  DATA 20,7C
00F50:  DATA 20,7C
00F52:  DATA 20,7C
00F54:  DATA 20,7C
00F56:  DATA 0A,00
00F58:  DATA 7C,5F
00F5A:  DATA 7C,20
00F5C:  DATA 5F,7C
00F5E:  DATA 5F,7C
00F60:  DATA 5F,5F
00F62:  DATA 5F,5F
00F64:  DATA 5F,7C
00F66:  DATA 5F,7C
00F68:  DATA 20,5C
00F6A:  DATA 5F,7C
00F6C:  DATA 5C,5F
00F6E:  DATA 5F,5F
00F70:  DATA 2F,20
00F72:  DATA 20,7C
00F74:  DATA 5F,7C
00F76:  DATA 5F,20
00F78:  DATA 20,5C
00F7A:  DATA 5F,5F
00F7C:  DATA 2C,5F
00F7E:  DATA 7C,5F
00F80:  DATA 7C,20
00F82:  DATA 7C,5F
00F84:  DATA 7C,5C
00F86:  DATA 5F,5F
00F88:  DATA 5F,7C
00F8A:  DATA 5C,5F
00F8C:  DATA 5F,7C
00F8E:  DATA 5F,7C
00F90:  DATA 5C,5F
00F92:  DATA 5F,5F
00F94:  DATA 2F,7C
00F96:  DATA 5F,7C
00F98:  DATA 20,7C
00F9A:  DATA 5F,7C
00F9C:  DATA 0A,00
00F9E:  DATA 20,20
00FA0:  DATA 20,2F
00FA2:  DATA 20,5C
00FA4:  DATA 20,20
00FA6:  DATA 20,5F
00FA8:  DATA 5F,5F
00FAA:  DATA 7C,20
00FAC:  DATA 7C,5F
00FAE:  DATA 28,5F
00FB0:  DATA 29,5F
00FB2:  DATA 20,20
00FB4:  DATA 20,5F
00FB6:  DATA 5F,5F
00FB8:  DATA 5F,20
00FBA:  DATA 5F,7C
00FBC:  DATA 20,7C
00FBE:  DATA 5F,20
00FC0:  DATA 5F,5F
00FC2:  DATA 5F,20
00FC4:  DATA 20,5F
00FC6:  DATA 5F,7C
00FC8:  DATA 20,7C
00FCA:  DATA 20,7C
00FCC:  DATA 20,20
00FCE:  DATA 20,20
00FD0:  DATA 20,20
00FD2:  DATA 20,20
00FD4:  DATA 20,20
00FD6:  DATA 20,20
00FD8:  DATA 20,20
00FDA:  DATA 20,20
00FDC:  DATA 20,20
00FDE:  DATA 20,20
00FE0:  DATA 20,20
00FE2:  DATA 0A,00
00FE4:  DATA 20,20
00FE6:  DATA 2F,20
00FE8:  DATA 5F,20
00FEA:  DATA 5C,20
00FEC:  DATA 2F,20
00FEE:  DATA 5F,5F
00FF0:  DATA 7C,20
00FF2:  DATA 5F,5F
00FF4:  DATA 7C,20
00FF6:  DATA 5C,20
00FF8:  DATA 5C,20
00FFA:  DATA 2F,20
00FFC:  DATA 2F,20
00FFE:  DATA 5F,60
01000:  DATA 20,7C
01002:  DATA 20,5F
01004:  DATA 5F,2F
01006:  DATA 20,5F
01008:  DATA 20,5C
0100A:  DATA 2F,20
0100C:  DATA 5F,60
0100E:  DATA 20,7C
01010:  DATA 20,7C
01012:  DATA 20,20
01014:  DATA 20,20
01016:  DATA 20,20
01018:  DATA 20,20
0101A:  DATA 20,20
0101C:  DATA 20,20
0101E:  DATA 20,20
01020:  DATA 20,20
01022:  DATA 20,20
01024:  DATA 20,20
01026:  DATA 20,20
01028:  DATA 0A,00
0102A:  DATA 20,2F
0102C:  DATA 20,5F
0102E:  DATA 5F,5F
01030:  DATA 20,5C
01032:  DATA 20,28
01034:  DATA 5F,5F
01036:  DATA 7C,20
01038:  DATA 7C,5F
0103A:  DATA 7C,20
0103C:  DATA 7C,5C
0103E:  DATA 20,56
01040:  DATA 20,2F
01042:  DATA 20,28
01044:  DATA 5F,7C
01046:  DATA 20,7C
01048:  DATA 20,7C
0104A:  DATA 7C,20
0104C:  DATA 20,5F
0104E:  DATA 5F,2F
01050:  DATA 20,28
01052:  DATA 5F,7C
01054:  DATA 20,7C
01056:  DATA 5F,7C
01058:  DATA 20,20
0105A:  DATA 20,20
0105C:  DATA 20,20
0105E:  DATA 20,20
01060:  DATA 20,20
01062:  DATA 20,20
01064:  DATA 20,20
01066:  DATA 20,20
01068:  DATA 20,20
0106A:  DATA 20,20
0106C:  DATA 20,20
0106E:  DATA 0A,00
01070:  DATA 2F,5F
01072:  DATA 2F,20
01074:  DATA 20,20
01076:  DATA 5C,5F
01078:  DATA 5C,5F
0107A:  DATA 5F,5F
0107C:  DATA 7C,5C
0107E:  DATA 5F,5F
01080:  DATA 7C,5F
01082:  DATA 7C,20
01084:  DATA 5C,5F
01086:  DATA 2F,20
01088:  DATA 5C,5F
0108A:  DATA 5F,2C
0108C:  DATA 5F,7C
0108E:  DATA 5C,5F
01090:  DATA 5F,5C
01092:  DATA 5F,5F
01094:  DATA 5F,7C
01096:  DATA 5C,5F
01098:  DATA 5F,2C
0109A:  DATA 5F,28
0109C:  DATA 5F,29
0109E:  DATA 20,20
010A0:  DATA 20,20
010A2:  DATA 20,20
010A4:  DATA 20,20
010A6:  DATA 20,20
010A8:  DATA 20,20
010AA:  DATA 20,20
010AC:  DATA 20,20
010AE:  DATA 20,20
010B0:  DATA 20,20
010B2:  DATA 20,20
010B4:  DATA 0A,00
010B6:  DATA 0A,2D
010B8:  DATA 2D,2D
010BA:  DATA 2D,2D
010BC:  DATA 2D,2D
010BE:  DATA 2D,2D
010C0:  DATA 2D,2D
010C2:  DATA 2D,2D
010C4:  DATA 2D,2D
010C6:  DATA 2D,2D
010C8:  DATA 4D,61
010CA:  DATA 69,6E
010CC:  DATA 20,4D
010CE:  DATA 65,6E
010D0:  DATA 75,2D
010D2:  DATA 2D,2D
010D4:  DATA 2D,2D
010D6:  DATA 2D,2D
010D8:  DATA 2D,2D
010DA:  DATA 2D,2D
010DC:  DATA 2D,2D
010DE:  DATA 2D,2D
010E0:  DATA 2D,2D
010E2:  DATA 0A,00
010E4:  DATA 20,20
010E6:  DATA 20,20
010E8:  DATA 70,72
010EA:  DATA 65,73
010EC:  DATA 73,20
010EE:  DATA 62,3A
010F0:  DATA 20,45
010F2:  DATA 50,53
010F4:  DATA 20,50
010F6:  DATA 6F,77
010F8:  DATA 65,72
010FA:  DATA 20,6F
010FC:  DATA 75,74
010FE:  DATA 70,75
01100:  DATA 74,20
01102:  DATA 63,6F
01104:  DATA 6E,74
01106:  DATA 72,6F
01108:  DATA 6C,0A
0110A:  DATA 00,00
0110C:  DATA 20,20
0110E:  DATA 20,20
01110:  DATA 70,72
01112:  DATA 65,73
01114:  DATA 73,20
01116:  DATA 63,3A
01118:  DATA 20,48
0111A:  DATA 6F,75
0111C:  DATA 73,65
0111E:  DATA 20,6B
01120:  DATA 65,65
01122:  DATA 70,69
01124:  DATA 6E,67
01126:  DATA 20,64
01128:  DATA 61,74
0112A:  DATA 61,20
0112C:  DATA 63,6F
0112E:  DATA 6C,6C
01130:  DATA 65,63
01132:  DATA 74,69
01134:  DATA 6F,6E
01136:  DATA 0A,00
01138:  DATA 20,20
0113A:  DATA 20,20
0113C:  DATA 70,72
0113E:  DATA 65,73
01140:  DATA 73,20
01142:  DATA 64,3A
01144:  DATA 20,43
01146:  DATA 68,65
01148:  DATA 63,6B
0114A:  DATA 20,46
0114C:  DATA 6C,61
0114E:  DATA 73,68
01150:  DATA 20,4D
01152:  DATA 65,6D
01154:  DATA 6F,72
01156:  DATA 69,65
01158:  DATA 73,0A
0115A:  DATA 00,00
0115C:  DATA 20,20
0115E:  DATA 20,20
01160:  DATA 70,72
01162:  DATA 65,73
01164:  DATA 73,20
01166:  DATA 66,3A
01168:  DATA 20,53
0116A:  DATA 65,74
0116C:  DATA 74,69
0116E:  DATA 6E,67
01170:  DATA 73,20
01172:  DATA 6F,66
01174:  DATA 20,52
01176:  DATA 54,43
01178:  DATA 0A,00
0117A:  DATA 20,20
0117C:  DATA 20,20
0117E:  DATA 70,72
01180:  DATA 65,73
01182:  DATA 73,20
01184:  DATA 6B,3A
01186:  DATA 20,55
01188:  DATA 41,52
0118A:  DATA 54,20
0118C:  DATA 54,45
0118E:  DATA 53,54
01190:  DATA 20,6F
01192:  DATA 66,20
01194:  DATA 45,50
01196:  DATA 53,0A
01198:  DATA 00,00
0119A:  DATA 20,20
0119C:  DATA 20,20
0119E:  DATA 70,72
011A0:  DATA 65,73
011A2:  DATA 73,20
011A4:  DATA 6C,3A
011A6:  DATA 20,74
011A8:  DATA 65,73
011AA:  DATA 74,6D
011AC:  DATA 6F,64
011AE:  DATA 65,20
011B0:  DATA 0A,00
011B2:  DATA 20,20
011B4:  DATA 20,20
011B6:  DATA 70,72
011B8:  DATA 65,73
011BA:  DATA 73,20
011BC:  DATA 78,3A
011BE:  DATA 20,45
011C0:  DATA 78,69
011C2:  DATA 74,20
011C4:  DATA 4D,61
011C6:  DATA 69,6E
011C8:  DATA 20,4D
011CA:  DATA 65,6E
011CC:  DATA 75,0A
011CE:  DATA 00,00
011D0:  DATA 20,20
011D2:  DATA 20,20
011D4:  DATA 44,4F
011D6:  DATA 20,4E
011D8:  DATA 4F,54
011DA:  DATA 20,55
011DC:  DATA 53,45
011DE:  DATA 20,43
011E0:  DATA 41,50
011E2:  DATA 49,54
011E4:  DATA 41,4C
011E6:  DATA 20,43
011E8:  DATA 48,41
011EA:  DATA 52,41
011EC:  DATA 43,54
011EE:  DATA 45,52
011F0:  DATA 53,20
011F2:  DATA 54,4F
011F4:  DATA 20,57
011F6:  DATA 52,49
011F8:  DATA 54,45
011FA:  DATA 21,0A
011FC:  DATA 0A,00
011FE:  DATA 55,41
01200:  DATA 52,54
01202:  DATA 20,54
01204:  DATA 45,53
01206:  DATA 54,20
01208:  DATA 49,6E
0120A:  DATA 69,74
0120C:  DATA 69,61
0120E:  DATA 6C,69
01210:  DATA 7A,65
01212:  DATA 64,2E
01214:  DATA 0A,00
01216:  DATA 54,65
01218:  DATA 73,74
0121A:  DATA 6D,6F
0121C:  DATA 64,65
0121E:  DATA 20,69
01220:  DATA 6E,69
01222:  DATA 74,69
01224:  DATA 61,6C
01226:  DATA 69,7A
01228:  DATA 65,64
0122A:  DATA 0A,00
0122C:  DATA 49,6E
0122E:  DATA 76,61
01230:  DATA 6C,69
01232:  DATA 64,20
01234:  DATA 6F,70
01236:  DATA 74,69
01238:  DATA 6F,6E
0123A:  DATA 2E,20
0123C:  DATA 50,6C
0123E:  DATA 65,61
01240:  DATA 73,65
01242:  DATA 20,74
01244:  DATA 72,79
01246:  DATA 20,61
01248:  DATA 67,61
0124A:  DATA 69,6E
0124C:  DATA 2E,0A
0124E:  DATA 00,00
01250:  DATA 52,65
01252:  DATA 61,64
01254:  DATA 69,6E
01256:  DATA 67,20
01258:  DATA 63,68
0125A:  DATA 69,70
0125C:  DATA 20,49
0125E:  DATA 44,20
01260:  DATA 6F,66
01262:  DATA 20,6D
01264:  DATA 61,69
01266:  DATA 6E,0A
01268:  DATA 00,00
0126A:  DATA 52,65
0126C:  DATA 61,64
0126E:  DATA 69,6E
01270:  DATA 67,20
01272:  DATA 63,68
01274:  DATA 69,70
01276:  DATA 20,49
01278:  DATA 44,20
0127A:  DATA 6F,66
0127C:  DATA 20,43
0127E:  DATA 4F,4D
01280:  DATA 0A,00
01282:  DATA 52,65
01284:  DATA 61,64
01286:  DATA 69,6E
01288:  DATA 67,20
0128A:  DATA 63,68
0128C:  DATA 69,70
0128E:  DATA 20,49
01290:  DATA 44,20
01292:  DATA 6F,66
01294:  DATA 20,41
01296:  DATA 44,43
01298:  DATA 53,0A
0129A:  DATA 00,00
0129C:  DATA 44,6F
0129E:  DATA 6E,65
012A0:  DATA 20,72
012A2:  DATA 65,61
012A4:  DATA 64,69
012A6:  DATA 6E,67
012A8:  DATA 20,63
012AA:  DATA 68,69
012AC:  DATA 70,20
012AE:  DATA 49,44
012B0:  DATA 0A,00
012B2:  DATA 53,74
012B4:  DATA 61,72
012B6:  DATA 74,69
012B8:  DATA 6E,67
012BA:  DATA 20,74
012BC:  DATA 6F,20
012BE:  DATA 77,72
012C0:  DATA 69,74
012C2:  DATA 65,20
012C4:  DATA 64,61
012C6:  DATA 74,61
012C8:  DATA 20,69
012CA:  DATA 6E,20
012CC:  DATA 4D,41
012CE:  DATA 49,4E
012D0:  DATA 20,66
012D2:  DATA 6C,61
012D4:  DATA 73,68
012D6:  DATA 20,6D
012D8:  DATA 65,6D
012DA:  DATA 6F,72
012DC:  DATA 79,0A
012DE:  DATA 00,00
012E0:  DATA 53,74
012E2:  DATA 61,72
012E4:  DATA 74,69
012E6:  DATA 6E,67
012E8:  DATA 20,74
012EA:  DATA 6F,20
012EC:  DATA 77,72
012EE:  DATA 69,74
012F0:  DATA 65,20
012F2:  DATA 64,61
012F4:  DATA 74,61
012F6:  DATA 20,69
012F8:  DATA 6E,20
012FA:  DATA 43,4F
012FC:  DATA 4D,20
012FE:  DATA 66,6C
01300:  DATA 61,73
01302:  DATA 68,20
01304:  DATA 6D,65
01306:  DATA 6D,6F
01308:  DATA 72,79
0130A:  DATA 0A,00
0130C:  DATA 4D,41
0130E:  DATA 49,4E
01310:  DATA 20,54
01312:  DATA 45,53
01314:  DATA 54,20
01316:  DATA 49,53
01318:  DATA 20,46
0131A:  DATA 49,4E
0131C:  DATA 49,53
0131E:  DATA 48,45
01320:  DATA 44,21
01322:  DATA 0A,00
*
01392:  TBLRD*+
01394:  MOVF   FF5,F
01396:  BZ    13B8
01398:  MOVFF  FF6,2F0
0139C:  MOVFF  FF7,2F1
013A0:  MOVFF  FF8,2F2
013A4:  MOVFF  FF5,302
013A8:  RCALL  134E
013AA:  MOVFF  2F0,FF6
013AE:  MOVFF  2F1,FF7
013B2:  MOVFF  2F2,FF8
013B6:  BRA    1392
013B8:  RETURN 0
*
0142C:  MOVWF  00
0142E:  SWAPF  00,W
01430:  ADDWF  00,W
01432:  ANDLW  0F
01434:  BTFSC  FD8.1
01436:  ADDLW  16
01438:  DAW   
0143A:  BTFSC  00.4
0143C:  ADDLW  15
0143E:  BTFSC  00.5
01440:  ADDLW  30
01442:  BTFSC  00.6
01444:  ADDLW  60
01446:  BTFSC  00.7
01448:  ADDLW  20
0144A:  DAW   
0144C:  RETURN 0
0144E:  RETURN 0
01450:  MOVWF  00
01452:  SWAPF  00,W
01454:  ANDLW  0F
01456:  MULLW  0A
01458:  MOVF   00,W
0145A:  ANDLW  0F
0145C:  ADDWF  FF3,W
0145E:  RETURN 0
01460:  RETURN 0
01462:  MOVLB  3
01464:  MOVF   x03,W
01466:  CLRF   01
01468:  SUBWF  x02,W
0146A:  BC    1472
0146C:  MOVFF  302,00
01470:  BRA    148A
01472:  CLRF   00
01474:  MOVLW  08
01476:  MOVWF  x04
01478:  RLCF   x02,F
0147A:  RLCF   00,F
0147C:  MOVF   x03,W
0147E:  SUBWF  00,W
01480:  BTFSC  FD8.0
01482:  MOVWF  00
01484:  RLCF   01,F
01486:  DECFSZ x04,F
01488:  BRA    1478
0148A:  MOVLB  0
0148C:  RETURN 0
0148E:  MOVF   01,W
01490:  MOVFF  1DE,302
01494:  MOVLW  64
01496:  MOVLB  3
01498:  MOVWF  x03
0149A:  MOVLB  0
0149C:  RCALL  1462
0149E:  MOVFF  00,1DE
014A2:  MOVF   01,W
014A4:  MOVLW  30
014A6:  BNZ   14B8
014A8:  MOVLB  1
014AA:  BTFSS  xDF.1
014AC:  BRA    14CA
014AE:  BTFSC  xDF.3
014B0:  BRA    14CA
014B2:  BTFSC  xDF.4
014B4:  MOVLW  20
014B6:  BRA    14C0
014B8:  MOVLB  1
014BA:  BCF    xDF.3
014BC:  BCF    xDF.4
014BE:  BSF    xDF.0
014C0:  ADDWF  01,F
014C2:  MOVFF  01,302
014C6:  MOVLB  0
014C8:  RCALL  134E
014CA:  MOVFF  1DE,302
014CE:  MOVLW  0A
014D0:  MOVLB  3
014D2:  MOVWF  x03
014D4:  MOVLB  0
014D6:  RCALL  1462
014D8:  MOVFF  00,1DE
014DC:  MOVF   01,W
014DE:  MOVLW  30
014E0:  BNZ   14F2
014E2:  MOVLB  1
014E4:  BTFSC  xDF.3
014E6:  BRA    14FC
014E8:  BTFSS  xDF.0
014EA:  BRA    14FC
014EC:  BTFSC  xDF.4
014EE:  MOVLW  20
014F0:  MOVLB  0
014F2:  ADDWF  01,F
014F4:  MOVFF  01,302
014F8:  RCALL  134E
014FA:  MOVLB  1
014FC:  MOVLW  30
014FE:  ADDWF  xDE,F
01500:  MOVFF  1DE,302
01504:  MOVLB  0
01506:  RCALL  134E
01508:  RETURN 0
0150A:  TBLRD*+
0150C:  MOVFF  FF6,2FD
01510:  MOVFF  FF7,2FE
01514:  MOVFF  FF8,2FF
01518:  MOVFF  FF5,302
0151C:  RCALL  134E
0151E:  MOVFF  2FD,FF6
01522:  MOVFF  2FE,FF7
01526:  MOVFF  2FF,FF8
0152A:  MOVLB  2
0152C:  DECFSZ xFC,F
0152E:  BRA    1532
01530:  BRA    1536
01532:  MOVLB  0
01534:  BRA    150A
01536:  MOVLB  0
01538:  RETURN 0
*
017DC:  MOVLB  2
017DE:  BTFSC  xFD.7
017E0:  BRA    1804
017E2:  MOVLW  0F
017E4:  MOVWF  00
017E6:  SWAPF  xFC,W
017E8:  ANDWF  00,F
017EA:  MOVLW  0A
017EC:  SUBWF  00,W
017EE:  BC    17F6
017F0:  MOVLW  30
017F2:  ADDWF  00,F
017F4:  BRA    17FA
017F6:  MOVF   xFD,W
017F8:  ADDWF  00,F
017FA:  MOVFF  00,302
017FE:  MOVLB  0
01800:  RCALL  134E
01802:  MOVLB  2
01804:  MOVLW  0F
01806:  ANDWF  xFC,F
01808:  MOVLW  0A
0180A:  SUBWF  xFC,W
0180C:  BC    1812
0180E:  MOVLW  30
01810:  BRA    1816
01812:  BCF    xFD.7
01814:  MOVF   xFD,W
01816:  ADDWF  xFC,F
01818:  MOVFF  2FC,302
0181C:  MOVLB  0
0181E:  RCALL  134E
01820:  RETURN 0
*
01840:  MOVLW  20
01842:  MOVLB  2
01844:  BTFSS  xFD.4
01846:  MOVLW  30
01848:  MOVWF  xFE
0184A:  MOVFF  2FC,00
0184E:  BTFSS  00.7
01850:  BRA    1862
01852:  COMF   00,F
01854:  INCF   00,F
01856:  MOVFF  00,2FC
0185A:  MOVLW  2D
0185C:  MOVWF  xFE
0185E:  BSF    xFD.7
01860:  BSF    xFD.0
01862:  MOVF   01,W
01864:  MOVFF  2FC,302
01868:  MOVLW  64
0186A:  MOVLB  3
0186C:  MOVWF  x03
0186E:  MOVLB  0
01870:  RCALL  1462
01872:  MOVFF  00,2FC
01876:  MOVLW  30
01878:  ADDWF  01,W
0187A:  MOVLB  2
0187C:  MOVWF  xFF
0187E:  MOVFF  2FC,302
01882:  MOVLW  0A
01884:  MOVLB  3
01886:  MOVWF  x03
01888:  MOVLB  0
0188A:  RCALL  1462
0188C:  MOVLW  30
0188E:  ADDWF  00,W
01890:  MOVLB  3
01892:  MOVWF  x01
01894:  MOVLW  30
01896:  ADDWF  01,W
01898:  MOVWF  x00
0189A:  MOVFF  2FE,00
0189E:  MOVLW  30
018A0:  MOVLB  2
018A2:  SUBWF  xFF,W
018A4:  BZ    18AE
018A6:  BSF    xFD.1
018A8:  BTFSC  xFD.7
018AA:  BSF    xFD.2
018AC:  BRA    18E6
018AE:  MOVFF  2FE,2FF
018B2:  MOVLW  20
018B4:  MOVWF  xFE
018B6:  MOVLW  30
018B8:  MOVLB  3
018BA:  SUBWF  x00,W
018BC:  BZ    18CA
018BE:  MOVLB  2
018C0:  BSF    xFD.0
018C2:  BTFSC  xFD.7
018C4:  BSF    xFD.1
018C6:  BRA    18E6
018C8:  MOVLB  3
018CA:  BTFSC  FD8.2
018CC:  BRA    18D4
018CE:  MOVLB  2
018D0:  BSF    xFD.0
018D2:  MOVLB  3
018D4:  BTFSC  FD8.2
018D6:  BRA    18DC
018D8:  MOVLB  2
018DA:  BRA    18E6
018DC:  MOVFF  2FF,300
018E0:  MOVLW  20
018E2:  MOVLB  2
018E4:  MOVWF  xFF
018E6:  BTFSC  xFD.2
018E8:  BRA    18F4
018EA:  BTFSC  xFD.1
018EC:  BRA    18FC
018EE:  BTFSC  xFD.0
018F0:  BRA    1904
018F2:  BRA    190C
018F4:  MOVFF  2FE,302
018F8:  MOVLB  0
018FA:  RCALL  134E
018FC:  MOVFF  2FF,302
01900:  MOVLB  0
01902:  RCALL  134E
01904:  MOVFF  300,302
01908:  MOVLB  0
0190A:  RCALL  134E
0190C:  MOVFF  301,302
01910:  MOVLB  0
01912:  RCALL  134E
01914:  RETURN 0
*
02026:  MOVF   01,W
02028:  MOVFF  1CB,302
0202C:  MOVLW  64
0202E:  MOVLB  3
02030:  MOVWF  x03
02032:  MOVLB  0
02034:  CALL   1462
02038:  MOVFF  00,1CB
0203C:  MOVF   01,W
0203E:  MOVLW  30
02040:  BNZ   2052
02042:  MOVLB  1
02044:  BTFSS  xCC.1
02046:  BRA    2064
02048:  BTFSC  xCC.3
0204A:  BRA    2064
0204C:  BTFSC  xCC.4
0204E:  MOVLW  20
02050:  BRA    205A
02052:  MOVLB  1
02054:  BCF    xCC.3
02056:  BCF    xCC.4
02058:  BSF    xCC.0
0205A:  ADDWF  01,F
0205C:  MOVFF  01,1CD
02060:  MOVLB  0
02062:  RCALL  1FE2
02064:  MOVFF  1CB,302
02068:  MOVLW  0A
0206A:  MOVLB  3
0206C:  MOVWF  x03
0206E:  MOVLB  0
02070:  CALL   1462
02074:  MOVFF  00,1CB
02078:  MOVF   01,W
0207A:  MOVLW  30
0207C:  BNZ   208E
0207E:  MOVLB  1
02080:  BTFSC  xCC.3
02082:  BRA    2098
02084:  BTFSS  xCC.0
02086:  BRA    2098
02088:  BTFSC  xCC.4
0208A:  MOVLW  20
0208C:  MOVLB  0
0208E:  ADDWF  01,F
02090:  MOVFF  01,1CD
02094:  RCALL  1FE2
02096:  MOVLB  1
02098:  MOVLW  30
0209A:  ADDWF  xCB,F
0209C:  MOVFF  1CB,1CD
020A0:  MOVLB  0
020A2:  RCALL  1FE2
020A4:  RETURN 0
*
0217A:  BTFSC  FD8.1
0217C:  BRA    2186
0217E:  MOVLW  01
02180:  MOVWF  FEA
02182:  MOVLW  DF
02184:  MOVWF  FE9
02186:  CLRF   00
02188:  CLRF   01
0218A:  CLRF   02
0218C:  CLRF   03
0218E:  MOVLB  1
02190:  CLRF   xDF
02192:  CLRF   xE0
02194:  CLRF   xE1
02196:  CLRF   xE2
02198:  MOVF   xDE,W
0219A:  IORWF  xDD,W
0219C:  IORWF  xDC,W
0219E:  IORWF  xDB,W
021A0:  BZ    21FA
021A2:  MOVLW  20
021A4:  MOVWF  xE3
021A6:  BCF    FD8.0
021A8:  RLCF   xD7,F
021AA:  RLCF   xD8,F
021AC:  RLCF   xD9,F
021AE:  RLCF   xDA,F
021B0:  RLCF   xDF,F
021B2:  RLCF   xE0,F
021B4:  RLCF   xE1,F
021B6:  RLCF   xE2,F
021B8:  MOVF   xDE,W
021BA:  SUBWF  xE2,W
021BC:  BNZ   21CE
021BE:  MOVF   xDD,W
021C0:  SUBWF  xE1,W
021C2:  BNZ   21CE
021C4:  MOVF   xDC,W
021C6:  SUBWF  xE0,W
021C8:  BNZ   21CE
021CA:  MOVF   xDB,W
021CC:  SUBWF  xDF,W
021CE:  BNC   21EE
021D0:  MOVF   xDB,W
021D2:  SUBWF  xDF,F
021D4:  MOVF   xDC,W
021D6:  BTFSS  FD8.0
021D8:  INCFSZ xDC,W
021DA:  SUBWF  xE0,F
021DC:  MOVF   xDD,W
021DE:  BTFSS  FD8.0
021E0:  INCFSZ xDD,W
021E2:  SUBWF  xE1,F
021E4:  MOVF   xDE,W
021E6:  BTFSS  FD8.0
021E8:  INCFSZ xDE,W
021EA:  SUBWF  xE2,F
021EC:  BSF    FD8.0
021EE:  RLCF   00,F
021F0:  RLCF   01,F
021F2:  RLCF   02,F
021F4:  RLCF   03,F
021F6:  DECFSZ xE3,F
021F8:  BRA    21A6
021FA:  MOVFF  1DF,FEF
021FE:  MOVFF  1E0,FEC
02202:  MOVFF  1E1,FEC
02206:  MOVFF  1E2,FEC
0220A:  MOVLB  0
0220C:  RETURN 0
0220E:  MOVF   FE9,W
02210:  MOVLB  1
02212:  MOVWF  xCF
02214:  MOVLW  3B
02216:  MOVWF  xD6
02218:  MOVLW  9A
0221A:  MOVWF  xD5
0221C:  MOVLW  CA
0221E:  MOVWF  xD4
02220:  CLRF   xD3
02222:  MOVLW  0A
02224:  MOVWF  xD1
02226:  BSF    FD8.1
02228:  MOVLW  01
0222A:  MOVWF  FEA
0222C:  MOVLW  CB
0222E:  MOVWF  FE9
02230:  MOVFF  1CE,1DA
02234:  MOVFF  1CD,1D9
02238:  MOVFF  1CC,1D8
0223C:  MOVFF  1CB,1D7
02240:  MOVFF  1D6,1DE
02244:  MOVFF  1D5,1DD
02248:  MOVFF  1D4,1DC
0224C:  MOVFF  1D3,1DB
02250:  MOVLB  0
02252:  RCALL  217A
02254:  MOVF   01,W
02256:  MOVF   00,F
02258:  BNZ   2280
0225A:  MOVLB  1
0225C:  MOVF   xD1,W
0225E:  XORLW  01
02260:  BTFSS  FD8.2
02262:  BRA    2268
02264:  MOVLB  0
02266:  BRA    2280
02268:  MOVF   xCF,W
0226A:  BZ    2284
0226C:  ANDLW  0F
0226E:  SUBWF  xD1,W
02270:  BZ    2274
02272:  BC    2294
02274:  BTFSC  xCF.7
02276:  BRA    2294
02278:  BTFSC  xCF.6
0227A:  BRA    2284
0227C:  MOVLW  20
0227E:  BRA    2286
02280:  MOVLB  1
02282:  CLRF   xCF
02284:  MOVLW  30
02286:  ADDWF  00,F
02288:  MOVFF  00,302
0228C:  MOVLB  0
0228E:  CALL   134E
02292:  MOVLB  1
02294:  BCF    FD8.1
02296:  MOVFF  1D6,1DA
0229A:  MOVFF  1D5,1D9
0229E:  MOVFF  1D4,1D8
022A2:  MOVFF  1D3,1D7
022A6:  CLRF   xDE
022A8:  CLRF   xDD
022AA:  CLRF   xDC
022AC:  MOVLW  0A
022AE:  MOVWF  xDB
022B0:  MOVLB  0
022B2:  RCALL  217A
022B4:  MOVFF  03,1D6
022B8:  MOVFF  02,1D5
022BC:  MOVFF  01,1D4
022C0:  MOVFF  00,1D3
022C4:  MOVLB  1
022C6:  DECFSZ xD1,F
022C8:  BRA    2226
022CA:  MOVLB  0
022CC:  GOTO   24BA (RETURN)
*
029FA:  MOVLB  3
029FC:  CLRF   x05
029FE:  CLRF   x06
02A00:  MOVLW  01
02A02:  MOVWF  x07
02A04:  CLRF   FDA
02A06:  CLRF   FD9
02A08:  MOVLW  02
02A0A:  MOVWF  x0A
02A0C:  MOVLW  FD
02A0E:  MOVWF  x09
02A10:  MOVLW  03
02A12:  MOVWF  FEA
02A14:  MOVLW  01
02A16:  MOVWF  FE9
02A18:  MOVFF  30A,FE2
02A1C:  MOVFF  309,FE1
02A20:  MOVFF  307,308
02A24:  BCF    FD8.0
02A26:  MOVF   FE5,W
02A28:  MULWF  FEE
02A2A:  MOVF   FF3,W
02A2C:  ADDWFC x05,F
02A2E:  MOVF   FF4,W
02A30:  ADDWFC x06,F
02A32:  DECFSZ x08,F
02A34:  BRA    2A24
02A36:  MOVFF  305,FDE
02A3A:  MOVFF  306,305
02A3E:  CLRF   x06
02A40:  BTFSC  FD8.0
02A42:  INCF   x06,F
02A44:  INCF   x09,F
02A46:  BTFSC  FD8.2
02A48:  INCF   x0A,F
02A4A:  INCF   x07,F
02A4C:  MOVF   x07,W
02A4E:  SUBLW  05
02A50:  BNZ   2A10
02A52:  MOVLB  0
02A54:  RETURN 0
02A56:  MOVF   03,W
02A58:  SUBLW  20
02A5A:  BZ    2A6C
02A5C:  MOVF   03,W
02A5E:  SUBLW  08
02A60:  BC    2A68
02A62:  MOVF   03,W
02A64:  SUBLW  0D
02A66:  BC    2A6C
02A68:  CLRF   01
02A6A:  BRA    2A70
02A6C:  MOVLW  01
02A6E:  MOVWF  01
02A70:  RETURN 0
02A72:  MOVLB  2
02A74:  CLRF   xF7
02A76:  CLRF   xFB
02A78:  CLRF   xFA
02A7A:  CLRF   xF9
02A7C:  CLRF   xF8
02A7E:  BTFSS  xF5.7
02A80:  BRA    2A88
02A82:  MOVF   xF4,F
02A84:  BTFSC  FD8.2
02A86:  BRA    2B60
02A88:  MOVLB  0
02A8A:  RCALL  24DA
02A8C:  MOVFF  01,2F6
02A90:  MOVLB  2
02A92:  MOVF   xF6,F
02A94:  BTFSC  FD8.2
02A96:  BRA    2B60
02A98:  INCF   xF7,F
02A9A:  MOVF   xF6,W
02A9C:  SUBLW  20
02A9E:  BC    2B2C
02AA0:  MOVF   xF6,W
02AA2:  SUBLW  58
02AA4:  BZ    2B4A
02AA6:  MOVF   xF6,W
02AA8:  SUBLW  78
02AAA:  BZ    2B4A
02AAC:  MOVF   xF6,W
02AAE:  SUBLW  2F
02AB0:  BC    2B5C
02AB2:  MOVLW  30
02AB4:  SUBWF  xF6,F
02AB6:  MOVF   xF6,W
02AB8:  SUBLW  09
02ABA:  BC    2ADC
02ABC:  MOVLW  07
02ABE:  SUBWF  xF6,F
02AC0:  MOVF   xF6,W
02AC2:  SUBLW  09
02AC4:  BC    2B5C
02AC6:  MOVF   xF6,W
02AC8:  SUBLW  0F
02ACA:  BC    2ADC
02ACC:  MOVLW  20
02ACE:  SUBWF  xF6,F
02AD0:  MOVF   xF6,W
02AD2:  SUBLW  09
02AD4:  BC    2B5C
02AD6:  MOVF   xF6,W
02AD8:  SUBLW  0F
02ADA:  BNC   2B5C
02ADC:  MOVFF  2FB,300
02AE0:  MOVFF  2FA,2FF
02AE4:  MOVFF  2F9,2FE
02AE8:  MOVFF  2F8,2FD
02AEC:  MOVLB  3
02AEE:  CLRF   x04
02AF0:  CLRF   x03
02AF2:  CLRF   x02
02AF4:  MOVLW  10
02AF6:  MOVWF  x01
02AF8:  MOVLB  0
02AFA:  RCALL  29FA
02AFC:  MOVLB  2
02AFE:  MOVF   xF6,W
02B00:  ADDWF  00,W
02B02:  MOVWF  xF8
02B04:  MOVLW  00
02B06:  ADDWFC 01,W
02B08:  MOVWF  xF9
02B0A:  MOVLW  00
02B0C:  ADDWFC 02,W
02B0E:  MOVWF  xFA
02B10:  MOVLW  00
02B12:  ADDWFC 03,W
02B14:  MOVWF  xFB
02B16:  BTFSC  xF5.7
02B18:  DECF   xF4,F
02B1A:  BTFSC  xF5.0
02B1C:  BRA    2B26
02B1E:  MOVF   xF6,F
02B20:  BNZ   2B26
02B22:  BSF    xF5.1
02B24:  BRA    2A7E
02B26:  BCF    xF5.1
02B28:  BSF    xF5.0
02B2A:  BRA    2A7E
02B2C:  MOVFF  2F6,03
02B30:  MOVLB  0
02B32:  RCALL  2A56
02B34:  MOVF   01,F
02B36:  BTFSS  FD8.2
02B38:  BRA    2B3E
02B3A:  MOVLB  2
02B3C:  BRA    2B5C
02B3E:  MOVLB  2
02B40:  BTFSC  xF5.0
02B42:  BRA    2B60
02B44:  BTFSC  xF5.1
02B46:  BRA    2B60
02B48:  BRA    2A7E
02B4A:  BTFSC  xF5.0
02B4C:  BRA    2B5C
02B4E:  BTFSS  xF5.1
02B50:  BRA    2B5C
02B52:  BTFSC  xF5.7
02B54:  INCF   xF4,F
02B56:  BCF    xF5.1
02B58:  BSF    xF5.0
02B5A:  BRA    2A7E
02B5C:  CLRF   xF7
02B5E:  BRA    2B7C
02B60:  BTFSC  xF5.6
02B62:  BRA    2B7C
02B64:  MOVFF  2F3,FEA
02B68:  MOVFF  2F2,FE9
02B6C:  MOVFF  2F8,FEF
02B70:  MOVFF  2F9,FEC
02B74:  MOVFF  2FA,FEC
02B78:  MOVFF  2FB,FEC
02B7C:  MOVFF  2F7,01
02B80:  MOVLB  0
02B82:  RETURN 0
02B84:  MOVLB  2
02B86:  CLRF   xF9
02B88:  CLRF   xFA
02B8A:  BTFSS  xF7.7
02B8C:  BRA    2B92
02B8E:  MOVF   xF6,F
02B90:  BZ    2C3C
02B92:  MOVLB  0
02B94:  RCALL  24DA
02B96:  MOVFF  01,2F8
02B9A:  MOVLB  2
02B9C:  MOVF   xF8,F
02B9E:  BZ    2C3C
02BA0:  INCF   xF9,F
02BA2:  MOVF   xF8,W
02BA4:  SUBLW  20
02BA6:  BC    2C08
02BA8:  MOVF   xF8,W
02BAA:  SUBLW  58
02BAC:  BZ    2C26
02BAE:  MOVF   xF8,W
02BB0:  SUBLW  78
02BB2:  BZ    2C26
02BB4:  MOVF   xF8,W
02BB6:  SUBLW  2F
02BB8:  BC    2C38
02BBA:  MOVLW  30
02BBC:  SUBWF  xF8,F
02BBE:  MOVF   xF8,W
02BC0:  SUBLW  09
02BC2:  BC    2BE4
02BC4:  MOVLW  07
02BC6:  SUBWF  xF8,F
02BC8:  MOVF   xF8,W
02BCA:  SUBLW  09
02BCC:  BC    2C38
02BCE:  MOVF   xF8,W
02BD0:  SUBLW  0F
02BD2:  BC    2BE4
02BD4:  MOVLW  20
02BD6:  SUBWF  xF8,F
02BD8:  MOVF   xF8,W
02BDA:  SUBLW  09
02BDC:  BC    2C38
02BDE:  MOVF   xF8,W
02BE0:  SUBLW  0F
02BE2:  BNC   2C38
02BE4:  MOVF   xFA,W
02BE6:  MULLW  10
02BE8:  MOVFF  FF3,01
02BEC:  MOVF   xF8,W
02BEE:  ADDWF  01,W
02BF0:  MOVWF  xFA
02BF2:  BTFSC  xF7.7
02BF4:  DECF   xF6,F
02BF6:  BTFSC  xF7.0
02BF8:  BRA    2C02
02BFA:  MOVF   xF8,F
02BFC:  BNZ   2C02
02BFE:  BSF    xF7.1
02C00:  BRA    2B8A
02C02:  BCF    xF7.1
02C04:  BSF    xF7.0
02C06:  BRA    2B8A
02C08:  MOVFF  2F8,03
02C0C:  MOVLB  0
02C0E:  RCALL  2A56
02C10:  MOVF   01,F
02C12:  BTFSS  FD8.2
02C14:  BRA    2C1A
02C16:  MOVLB  2
02C18:  BRA    2C38
02C1A:  MOVLB  2
02C1C:  BTFSC  xF7.0
02C1E:  BRA    2C3C
02C20:  BTFSC  xF7.1
02C22:  BRA    2C3C
02C24:  BRA    2B8A
02C26:  BTFSC  xF7.0
02C28:  BRA    2C38
02C2A:  BTFSS  xF7.1
02C2C:  BRA    2C38
02C2E:  BTFSC  xF7.7
02C30:  INCF   xF6,F
02C32:  BCF    xF7.1
02C34:  BSF    xF7.0
02C36:  BRA    2B8A
02C38:  CLRF   xF9
02C3A:  BRA    2C4C
02C3C:  BTFSC  xF7.6
02C3E:  BRA    2C4C
02C40:  MOVFF  2F5,FEA
02C44:  MOVFF  2F4,FE9
02C48:  MOVFF  2FA,FEF
02C4C:  MOVFF  2F9,01
02C50:  MOVLB  0
02C52:  RETURN 0
*
02DCE:  CLRF   00
02DD0:  CLRF   01
02DD2:  MOVLB  1
02DD4:  MOVF   xF4,W
02DD6:  BCF    FD8.0
02DD8:  BTFSC  xF5.0
02DDA:  ADDWF  00,F
02DDC:  RRCF   00,F
02DDE:  RRCF   01,F
02DE0:  BTFSC  xF5.1
02DE2:  ADDWF  00,F
02DE4:  RRCF   00,F
02DE6:  RRCF   01,F
02DE8:  BTFSC  xF5.2
02DEA:  ADDWF  00,F
02DEC:  RRCF   00,F
02DEE:  RRCF   01,F
02DF0:  BTFSC  xF5.3
02DF2:  ADDWF  00,F
02DF4:  RRCF   00,F
02DF6:  RRCF   01,F
02DF8:  BTFSC  xF5.4
02DFA:  ADDWF  00,F
02DFC:  RRCF   00,F
02DFE:  RRCF   01,F
02E00:  BTFSC  xF5.5
02E02:  ADDWF  00,F
02E04:  RRCF   00,F
02E06:  RRCF   01,F
02E08:  BTFSC  xF5.6
02E0A:  ADDWF  00,F
02E0C:  RRCF   00,F
02E0E:  RRCF   01,F
02E10:  BTFSC  xF5.7
02E12:  ADDWF  00,F
02E14:  RRCF   00,F
02E16:  RRCF   01,F
02E18:  MOVLB  0
02E1A:  GOTO   2E72 (RETURN)
02E1E:  MOVLB  1
02E20:  CLRF   xF1
02E22:  CLRF   xF2
02E24:  BTFSS  xEC.7
02E26:  BRA    2E2C
02E28:  MOVF   xEB,F
02E2A:  BZ    2EE0
02E2C:  MOVLB  0
02E2E:  CALL   24DA
02E32:  MOVFF  01,1F0
02E36:  MOVLB  1
02E38:  MOVF   xF0,F
02E3A:  BZ    2EE0
02E3C:  INCF   xF1,F
02E3E:  MOVF   xF0,W
02E40:  SUBLW  20
02E42:  BC    2EA4
02E44:  MOVF   xF0,W
02E46:  SUBLW  2D
02E48:  BZ    2EC6
02E4A:  MOVF   xF0,W
02E4C:  SUBLW  2B
02E4E:  BZ    2ECA
02E50:  MOVF   xF0,W
02E52:  SUBLW  2F
02E54:  BC    2EDC
02E56:  MOVLW  30
02E58:  SUBWF  xF0,F
02E5A:  MOVF   xEF,W
02E5C:  SUBWF  xF0,W
02E5E:  BC    2EDC
02E60:  BTFSS  xEC.4
02E62:  BRA    2E66
02E64:  NEGF   xF0
02E66:  MOVFF  1F2,1F4
02E6A:  MOVFF  1EF,1F5
02E6E:  MOVLB  0
02E70:  BRA    2DCE
02E72:  MOVF   01,W
02E74:  MOVFF  01,1F2
02E78:  MOVLB  1
02E7A:  MOVF   xF0,W
02E7C:  ADDWF  xF2,F
02E7E:  BTFSC  xEC.7
02E80:  DECF   xEB,F
02E82:  MOVF   xEF,W
02E84:  SUBLW  08
02E86:  BNZ   2E9E
02E88:  BTFSC  xEC.0
02E8A:  BRA    2E96
02E8C:  MOVF   xF0,F
02E8E:  BNZ   2E9E
02E90:  BSF    xEC.1
02E92:  BSF    xEC.0
02E94:  BRA    2E24
02E96:  BTFSS  xEC.1
02E98:  BRA    2E9E
02E9A:  BTFSC  xEC.7
02E9C:  INCF   xEB,F
02E9E:  BSF    xEC.0
02EA0:  BCF    xEC.1
02EA2:  BRA    2E24
02EA4:  MOVFF  1F0,03
02EA8:  MOVLB  0
02EAA:  RCALL  2A56
02EAC:  MOVF   01,F
02EAE:  BTFSS  FD8.2
02EB0:  BRA    2EB6
02EB2:  MOVLB  1
02EB4:  BRA    2EDC
02EB6:  MOVLB  1
02EB8:  BTFSC  xEC.0
02EBA:  BRA    2EE0
02EBC:  BTFSC  xEC.1
02EBE:  BRA    2EE0
02EC0:  BTFSC  xEC.2
02EC2:  BRA    2EDC
02EC4:  BRA    2E24
02EC6:  BSF    xEC.4
02EC8:  BRA    2ECC
02ECA:  BCF    xEC.4
02ECC:  BTFSC  xEC.0
02ECE:  BRA    2EDC
02ED0:  BTFSC  xEC.1
02ED2:  BRA    2EDC
02ED4:  BTFSC  xEC.2
02ED6:  BRA    2EDC
02ED8:  BSF    xEC.2
02EDA:  BRA    2E24
02EDC:  CLRF   xF1
02EDE:  BRA    2EF0
02EE0:  BTFSC  xEC.6
02EE2:  BRA    2EF0
02EE4:  MOVFF  1EE,FEA
02EE8:  MOVFF  1ED,FE9
02EEC:  MOVFF  1F2,FEF
02EF0:  MOVFF  1F1,01
02EF4:  MOVLB  0
02EF6:  GOTO   2FE4 (RETURN)
*
0369E:  MOVF   FEF,F
036A0:  BZ    36C2
036A2:  MOVFF  FEA,1EA
036A6:  MOVFF  FE9,1E9
036AA:  MOVFF  FEF,302
036AE:  CALL   134E
036B2:  MOVFF  1EA,FEA
036B6:  MOVFF  1E9,FE9
036BA:  INCF   FE9,F
036BC:  BTFSC  FD8.2
036BE:  INCF   FEA,F
036C0:  BRA    369E
036C2:  RETURN 0
*
039A2:  MOVLW  8E
039A4:  MOVWF  00
039A6:  MOVFF  1E5,01
039AA:  MOVFF  1E4,02
039AE:  CLRF   03
039B0:  MOVF   01,F
039B2:  BNZ   39C6
039B4:  MOVFF  02,01
039B8:  CLRF   02
039BA:  MOVLW  08
039BC:  SUBWF  00,F
039BE:  MOVF   01,F
039C0:  BNZ   39C6
039C2:  CLRF   00
039C4:  BRA    39D6
039C6:  BCF    FD8.0
039C8:  BTFSC  01.7
039CA:  BRA    39D4
039CC:  RLCF   02,F
039CE:  RLCF   01,F
039D0:  DECF   00,F
039D2:  BRA    39C6
039D4:  BCF    01.7
039D6:  RETURN 0
039D8:  MOVLB  1
039DA:  MOVF   xE8,W
039DC:  BTFSC  FD8.2
039DE:  BRA    3AC2
039E0:  MOVWF  00
039E2:  MOVF   xEC,W
039E4:  BTFSC  FD8.2
039E6:  BRA    3AC2
039E8:  ADDWF  00,F
039EA:  BNC   39F4
039EC:  MOVLW  81
039EE:  ADDWF  00,F
039F0:  BC    3AC2
039F2:  BRA    39FC
039F4:  MOVLW  7F
039F6:  SUBWF  00,F
039F8:  BNC   3AC2
039FA:  BZ    3AC2
039FC:  MOVFF  1E9,1F0
03A00:  MOVF   xED,W
03A02:  XORWF  xF0,F
03A04:  BSF    xE9.7
03A06:  BSF    xED.7
03A08:  MOVF   xEB,W
03A0A:  MULWF  xEF
03A0C:  MOVFF  FF4,1F2
03A10:  MOVF   xEA,W
03A12:  MULWF  xEE
03A14:  MOVFF  FF4,03
03A18:  MOVFF  FF3,1F1
03A1C:  MULWF  xEF
03A1E:  MOVF   FF3,W
03A20:  ADDWF  xF2,F
03A22:  MOVF   FF4,W
03A24:  ADDWFC xF1,F
03A26:  MOVLW  00
03A28:  ADDWFC 03,F
03A2A:  MOVF   xEB,W
03A2C:  MULWF  xEE
03A2E:  MOVF   FF3,W
03A30:  ADDWF  xF2,F
03A32:  MOVF   FF4,W
03A34:  ADDWFC xF1,F
03A36:  MOVLW  00
03A38:  CLRF   02
03A3A:  ADDWFC 03,F
03A3C:  ADDWFC 02,F
03A3E:  MOVF   xE9,W
03A40:  MULWF  xEF
03A42:  MOVF   FF3,W
03A44:  ADDWF  xF1,F
03A46:  MOVF   FF4,W
03A48:  ADDWFC 03,F
03A4A:  MOVLW  00
03A4C:  ADDWFC 02,F
03A4E:  MOVF   xE9,W
03A50:  MULWF  xEE
03A52:  MOVF   FF3,W
03A54:  ADDWF  03,F
03A56:  MOVF   FF4,W
03A58:  ADDWFC 02,F
03A5A:  MOVLW  00
03A5C:  CLRF   01
03A5E:  ADDWFC 01,F
03A60:  MOVF   xEB,W
03A62:  MULWF  xED
03A64:  MOVF   FF3,W
03A66:  ADDWF  xF1,F
03A68:  MOVF   FF4,W
03A6A:  ADDWFC 03,F
03A6C:  MOVLW  00
03A6E:  ADDWFC 02,F
03A70:  ADDWFC 01,F
03A72:  MOVF   xEA,W
03A74:  MULWF  xED
03A76:  MOVF   FF3,W
03A78:  ADDWF  03,F
03A7A:  MOVF   FF4,W
03A7C:  ADDWFC 02,F
03A7E:  MOVLW  00
03A80:  ADDWFC 01,F
03A82:  MOVF   xE9,W
03A84:  MULWF  xED
03A86:  MOVF   FF3,W
03A88:  ADDWF  02,F
03A8A:  MOVF   FF4,W
03A8C:  ADDWFC 01,F
03A8E:  INCF   00,F
03A90:  BTFSC  01.7
03A92:  BRA    3A9E
03A94:  RLCF   xF1,F
03A96:  RLCF   03,F
03A98:  RLCF   02,F
03A9A:  RLCF   01,F
03A9C:  DECF   00,F
03A9E:  MOVLW  00
03AA0:  BTFSS  xF1.7
03AA2:  BRA    3AB8
03AA4:  INCF   03,F
03AA6:  ADDWFC 02,F
03AA8:  ADDWFC 01,F
03AAA:  MOVF   01,W
03AAC:  BNZ   3AB8
03AAE:  MOVF   02,W
03AB0:  BNZ   3AB8
03AB2:  MOVF   03,W
03AB4:  BNZ   3AB8
03AB6:  INCF   00,F
03AB8:  BTFSC  xF0.7
03ABA:  BSF    01.7
03ABC:  BTFSS  xF0.7
03ABE:  BCF    01.7
03AC0:  BRA    3ACA
03AC2:  CLRF   00
03AC4:  CLRF   01
03AC6:  CLRF   02
03AC8:  CLRF   03
03ACA:  MOVLB  0
03ACC:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
....................  #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... // #device ADC=16
.................... // #device ICD=TRUE
.................... // #include <main_functions.h>
....................  #FUSES NOWDT NOBROWNOUT NOPROTECT NOIESO 
....................  #use delay(clock=16M, crystal)
*
01324:  MOVLW  01
01326:  MOVWF  FEA
01328:  MOVLW  E5
0132A:  MOVWF  FE9
0132C:  MOVF   FEF,W
0132E:  BZ    134C
01330:  MOVLW  05
01332:  MOVWF  01
01334:  CLRF   00
01336:  DECFSZ 00,F
01338:  BRA    1336
0133A:  DECFSZ 01,F
0133C:  BRA    1334
0133E:  MOVLW  2E
01340:  MOVWF  00
01342:  DECFSZ 00,F
01344:  BRA    1342
01346:  BRA    1348
01348:  DECFSZ FEF,F
0134A:  BRA    1330
0134C:  RETURN 0
....................   
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  #use rs232(baud=9600, parity=N, xmit=PIN_E5, rcv=PIN_E4, bits=8, stream=EPS) //EPS DATA ACQUISITION
*
036C4:  BCF    F96.5
036C6:  BCF    F8D.5
036C8:  MOVLW  08
036CA:  MOVWF  01
036CC:  BRA    36CE
036CE:  NOP   
036D0:  BSF    01.7
036D2:  BRA    36F4
036D4:  BCF    01.7
036D6:  MOVLB  1
036D8:  RRCF   xEA,F
036DA:  MOVLB  0
036DC:  BTFSC  FD8.0
036DE:  BSF    F8D.5
036E0:  BTFSS  FD8.0
036E2:  BCF    F8D.5
036E4:  BSF    01.6
036E6:  BRA    36F4
036E8:  BCF    01.6
036EA:  DECFSZ 01,F
036EC:  BRA    36D6
036EE:  BRA    36F0
036F0:  NOP   
036F2:  BSF    F8D.5
036F4:  MOVLW  84
036F6:  MOVWF  FE9
036F8:  DECFSZ FE9,F
036FA:  BRA    36F8
036FC:  BRA    36FE
036FE:  NOP   
03700:  BTFSC  01.7
03702:  BRA    36D4
03704:  BTFSC  01.6
03706:  BRA    36E8
03708:  GOTO   3766 (RETURN)
0370C:  BSF    F96.4
0370E:  BTFSC  F84.4
03710:  BRA    370E
03712:  MOVLW  08
03714:  MOVWF  00
03716:  MOVLB  1
03718:  CLRF   xEE
0371A:  BSF    00.7
0371C:  BRA    373A
0371E:  BCF    00.7
03720:  BRA    373A
03722:  BCF    FD8.0
03724:  BTFSC  F84.4
03726:  BSF    FD8.0
03728:  RRCF   xEE,F
0372A:  BSF    00.6
0372C:  BRA    373A
0372E:  BCF    00.6
03730:  DECFSZ 00,F
03732:  BRA    3722
03734:  MOVFF  1EE,01
03738:  BRA    3752
0373A:  MOVLW  84
0373C:  BTFSC  00.7
0373E:  MOVLW  24
03740:  MOVWF  01
03742:  DECFSZ 01,F
03744:  BRA    3742
03746:  BRA    3748
03748:  BTFSC  00.7
0374A:  BRA    371E
0374C:  BTFSC  00.6
0374E:  BRA    372E
03750:  BRA    3722
03752:  MOVLB  0
03754:  RETURN 0
....................  #use rs232(baud=115200, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, stream=EXT) //MAIN RAB Rear access board 
*
0134E:  BCF    F94.6
01350:  BCF    F8B.6
01352:  MOVLW  08
01354:  MOVWF  01
01356:  BRA    1358
01358:  NOP   
0135A:  BSF    01.7
0135C:  BRA    137E
0135E:  BCF    01.7
01360:  MOVLB  3
01362:  RRCF   x02,F
01364:  MOVLB  0
01366:  BTFSC  FD8.0
01368:  BSF    F8B.6
0136A:  BTFSS  FD8.0
0136C:  BCF    F8B.6
0136E:  BSF    01.6
01370:  BRA    137E
01372:  BCF    01.6
01374:  DECFSZ 01,F
01376:  BRA    1360
01378:  BRA    137A
0137A:  NOP   
0137C:  BSF    F8B.6
0137E:  MOVLW  05
01380:  MOVWF  FE9
01382:  DECFSZ FE9,F
01384:  BRA    1382
01386:  BRA    1388
01388:  BTFSC  01.7
0138A:  BRA    135E
0138C:  BTFSC  01.6
0138E:  BRA    1372
01390:  RETURN 0
*
024DA:  BSF    F94.7
024DC:  BTFSC  F82.7
024DE:  BRA    24DC
024E0:  MOVLW  08
024E2:  MOVWF  00
024E4:  MOVLB  2
024E6:  CLRF   xFD
024E8:  BSF    00.7
024EA:  BRA    250C
024EC:  BCF    00.7
024EE:  BRA    250C
024F0:  MOVFF  2FD,02
024F4:  BCF    FD8.0
024F6:  BTFSC  F82.7
024F8:  BSF    FD8.0
024FA:  RRCF   02,F
024FC:  BSF    00.6
024FE:  BRA    250C
02500:  BCF    00.6
02502:  DECFSZ 00,F
02504:  BRA    24F4
02506:  MOVFF  02,01
0250A:  BRA    2524
0250C:  MOVLW  05
0250E:  BTFSC  00.7
02510:  MOVLW  01
02512:  MOVWF  01
02514:  DECFSZ 01,F
02516:  BRA    2514
02518:  NOP   
0251A:  BTFSC  00.7
0251C:  BRA    24EC
0251E:  BTFSC  00.6
02520:  BRA    2500
02522:  BRA    24F4
02524:  MOVLB  0
02526:  RETURN 0
....................  #use rs232(baud=115200, parity=N, xmit=PIN_D2, rcv=PIN_D3, bits=8, stream=COM, FORCE_SW) //MAIN COM Communication, send CW data 
....................  #use rs232(baud=115200, parity=N, xmit=PIN_F6, rcv=PIN_F7, bits=8, stream=CAM, FORCE_SW) //MAIN CAM Communication that will sent camara data ov5642 
*
01FE2:  BCF    F97.6
01FE4:  BCF    F8E.6
01FE6:  MOVLW  08
01FE8:  MOVWF  01
01FEA:  BRA    1FEC
01FEC:  NOP   
01FEE:  BSF    01.7
01FF0:  BRA    2012
01FF2:  BCF    01.7
01FF4:  MOVLB  1
01FF6:  RRCF   xCD,F
01FF8:  MOVLB  0
01FFA:  BTFSC  FD8.0
01FFC:  BSF    F8E.6
01FFE:  BTFSS  FD8.0
02000:  BCF    F8E.6
02002:  BSF    01.6
02004:  BRA    2012
02006:  BCF    01.6
02008:  DECFSZ 01,F
0200A:  BRA    1FF4
0200C:  BRA    200E
0200E:  NOP   
02010:  BSF    F8E.6
02012:  MOVLW  05
02014:  MOVWF  FE9
02016:  DECFSZ FE9,F
02018:  BRA    2016
0201A:  BRA    201C
0201C:  BTFSC  01.7
0201E:  BRA    1FF2
02020:  BTFSC  01.6
02022:  BRA    2006
02024:  RETURN 0
*
020A6:  BSF    F97.7
020A8:  BTFSC  F85.7
020AA:  BRA    20A8
020AC:  MOVLW  08
020AE:  MOVWF  00
020B0:  MOVLB  1
020B2:  CLRF   xD3
020B4:  BSF    00.7
020B6:  BRA    20D8
020B8:  BCF    00.7
020BA:  BRA    20D8
020BC:  MOVFF  1D3,02
020C0:  BCF    FD8.0
020C2:  BTFSC  F85.7
020C4:  BSF    FD8.0
020C6:  RRCF   02,F
020C8:  BSF    00.6
020CA:  BRA    20D8
020CC:  BCF    00.6
020CE:  DECFSZ 00,F
020D0:  BRA    20C0
020D2:  MOVFF  02,01
020D6:  BRA    20F0
020D8:  MOVLW  05
020DA:  BTFSC  00.7
020DC:  MOVLW  01
020DE:  MOVWF  01
020E0:  DECFSZ 01,F
020E2:  BRA    20E0
020E4:  NOP   
020E6:  BTFSC  00.7
020E8:  BRA    20B8
020EA:  BTFSC  00.6
020EC:  BRA    20CC
020EE:  BRA    20C0
020F0:  MOVLB  0
020F2:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=10000, BITS=8, STREAM=MAIN_FM, MODE=0) //MAIN flash memory port
*
01690:  MOVLB  2
01692:  MOVF   xFE,W
01694:  SUBLW  08
01696:  BZ    16A8
01698:  MOVLB  3
0169A:  MOVWF  x00
0169C:  MOVLB  2
0169E:  RLCF   xFD,F
016A0:  MOVLB  3
016A2:  DECFSZ x00,F
016A4:  BRA    169C
016A6:  MOVLB  2
016A8:  BSF    F96.0
016AA:  BCF    F96.6
016AC:  BCF    F96.1
016AE:  BCF    F8D.1
016B0:  MOVFF  2FE,300
016B4:  BTFSS  xFD.7
016B6:  BCF    F8D.6
016B8:  BTFSC  xFD.7
016BA:  BSF    F8D.6
016BC:  RLCF   xFD,F
016BE:  BSF    F8D.1
016C0:  MOVLW  41
016C2:  MOVLB  3
016C4:  MOVWF  x01
016C6:  DECFSZ x01,F
016C8:  BRA    16C6
016CA:  RLCF   01,F
016CC:  BTFSS  F84.0
016CE:  BCF    01.0
016D0:  BTFSC  F84.0
016D2:  BSF    01.0
016D4:  BCF    F8D.1
016D6:  MOVLW  40
016D8:  MOVWF  x01
016DA:  DECFSZ x01,F
016DC:  BRA    16DA
016DE:  DECFSZ x00,F
016E0:  BRA    16E4
016E2:  BRA    16E8
016E4:  MOVLB  2
016E6:  BRA    16B4
016E8:  MOVLB  0
016EA:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=10000, BITS=8, STREAM=COM_FM, MODE=0) //COM shared flash memory port
*
01B8A:  MOVLB  2
01B8C:  MOVF   xCD,W
01B8E:  SUBLW  08
01B90:  BZ    1B9A
01B92:  MOVWF  xCF
01B94:  RLCF   xCC,F
01B96:  DECFSZ xCF,F
01B98:  BRA    1B94
01B9A:  BSF    F93.5
01B9C:  BCF    F93.4
01B9E:  BCF    F93.2
01BA0:  BCF    F8A.2
01BA2:  MOVFF  2CD,2CF
01BA6:  BTFSS  xCC.7
01BA8:  BCF    F8A.4
01BAA:  BTFSC  xCC.7
01BAC:  BSF    F8A.4
01BAE:  RLCF   xCC,F
01BB0:  BSF    F8A.2
01BB2:  MOVLW  41
01BB4:  MOVWF  xD0
01BB6:  DECFSZ xD0,F
01BB8:  BRA    1BB6
01BBA:  RLCF   01,F
01BBC:  BTFSS  F81.5
01BBE:  BCF    01.0
01BC0:  BTFSC  F81.5
01BC2:  BSF    01.0
01BC4:  BCF    F8A.2
01BC6:  MOVLW  40
01BC8:  MOVWF  xD0
01BCA:  DECFSZ xD0,F
01BCC:  BRA    1BCA
01BCE:  DECFSZ xCF,F
01BD0:  BRA    1BA6
01BD2:  MOVLB  0
01BD4:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=10000, BITS=8, STREAM=MISSION_FM, MODE=0) //ADCS shared flash memory port, Camera module (ovcam,mvcam) only can access via mux selcent
*
01C64:  MOVLB  1
01C66:  MOVF   xEB,W
01C68:  SUBLW  08
01C6A:  BZ    1C74
01C6C:  MOVWF  xED
01C6E:  RLCF   xEA,F
01C70:  DECFSZ xED,F
01C72:  BRA    1C6E
01C74:  BSF    F92.0
01C76:  BCF    F92.1
01C78:  BCF    F92.3
01C7A:  BCF    F89.3
01C7C:  MOVFF  1EB,1ED
01C80:  BTFSS  xEA.7
01C82:  BCF    F89.1
01C84:  BTFSC  xEA.7
01C86:  BSF    F89.1
01C88:  RLCF   xEA,F
01C8A:  BSF    F89.3
01C8C:  MOVLW  41
01C8E:  MOVWF  xEE
01C90:  DECFSZ xEE,F
01C92:  BRA    1C90
01C94:  RLCF   01,F
01C96:  BTFSS  F80.0
01C98:  BCF    01.0
01C9A:  BTFSC  F80.0
01C9C:  BSF    01.0
01C9E:  BCF    F89.3
01CA0:  MOVLW  40
01CA2:  MOVWF  xEE
01CA4:  DECFSZ xEE,F
01CA6:  BRA    1CA4
01CA8:  DECFSZ xED,F
01CAA:  BRA    1C80
01CAC:  MOVLB  0
01CAE:  RETURN 0
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //SPI Stream alter name 
.................... //  #define SPIPORT MAIN_FM
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................      
.................... 
.................... 
....................  //Flash memory chip select pins and mux control 
....................  #define CS_PIN_1 PIN_E2 //OBC_FLASH_SELECT
....................  #define CS_PIN_COM PIN_B3 //COM_CHIP_SELECT
....................  #define CS_PIN_MISSION PIN_A2 //ADCS_CHIP_SELECT
....................  #define MX_PIN_OVCAM PIN_G2 //OVCAM_MUX_SELECT
....................  #define MX_PIN_MVCAM PIN_G3 //MVCAM_MUX_SELECT
....................  #define MX_PIN_ADCS PIN_A5 //ADCS_MUX_SELECT
....................  #define MX_PIN_COM PIN_C4 //COM_MUX_SELECT
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //mt25q flash memory command assigment
....................  #define READ_ID              0x9F
....................  #define READ_STATUS_REG      0x05 
....................  #define READ_DATA_BYTES      0x13  //0x03 for byte
....................  #define ENABLE_WRITE         0x06
....................  #define WRITE_PAGE           0x12  //0x02 for 3byte 
....................  #define ERASE_SECTOR         0xDC  //0xD8 for 3byte
....................  #define ERASE_4KB_SUBSECTOR  0x21
....................  #define ERASE_32KB_SUBSECTOR 0x5C
....................  #define DIE_ERASE            0xC4
....................  #define FAST_READ            0x0B
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //memory maping     
....................  #define SHUTDOWN_COUNT_ADDRESS 0x00100011
....................  
....................  //digtal control pins 
....................  #define EN_SUP_3V3_1 PIN_B0
....................  #define EN_SUP_3V3_2 PIN_G1
....................  #define EN_SUP_3V3_DAQ PIN_D0
....................  #define EN_SUP_UNREG PIN_B1
....................  #define EN_SUP_5V0 PIN_D1
....................  #define KILL_SWITCH PIN_A4
....................  #define MVCAM_PWR PIN_G0
....................  #define OVCAM_PWR PIN_D7
....................  #define ADCS_PWR PIN_D6
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //FLAG variable
....................     //  int8 EPS_UART = 0;
....................     //  int8 COM_UART = 0;
....................     //  int8 EXT_UART = 0; 
....................     //  unsigned int8 in_bffr_main[16] = {};
....................     //  int8 COM_DATA= 0;
....................  
....................  //    int8 ADCS_HK_ADDRESS = 0x00010000;
....................  //    int8 ADCS_HK_ADDRESS_COUNTER = 0x00000000;
....................  //    int8 SHUT_DOWN_COUNT_ADD = 0x00010000;
....................  //    int8 ADCS_COMMAND = 0x02;
....................  //    unsigned char *READ_HK_ADCS[16];
....................      
....................  
....................  //SerialDataReceive(){
....................  //   int num = 0;
....................  //   for(num = 0 ;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = fgetc(EXT);
....................  //   }     
....................  //   return;
....................  //}
....................  //void Delete_Buffer() //delete com command buffer
....................  //{
....................  //   int num = 0;
....................  //   for(num = 0;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = 0x00;
....................  //   }
....................  //   COM_DATA = 0;
....................  //   return;
....................  //}
....................  //
....................  //void Transfer_Buffer(int PORT_NUM) //get buffer data one by one
....................  //                                   //1:EPS 2:EXT 3:COM 4:CAM
....................  //{
....................  //   int num = 0;
....................  //   switch(PORT_NUM)
....................  //   {
....................  //      case 1:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EPS);
....................  //         }
....................  //         break;
....................  //      case 2:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EXT);
....................  //         }
....................  //         break;
....................  //      case 3:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],COM);
....................  //         }
....................  //         break;
....................  //      case 4:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],CAM);
....................  //         }
....................  //         break;
....................  //   }
....................  //   return;
....................  //}
....................  //
....................  //void process_uart() {
....................  //    if (kbhit(EXT)) {  // Check if data is available
....................  //        SerialDataReceive();  // Load 16 bytes into the buffer
....................  //        fprintf(EXT, "Received Data: ");
....................  //        Transfer_Buffer(1);  // Transfer to PC for verification
....................  //        Delete_Buffer();  // Clear the buffer for the next message
....................  //    }
....................  //}
....................  
....................  void WRITE_ENABLE_OF(){
....................   output_low(CS_PIN_1);
*
01822:  BCF    F96.2
01824:  BCF    F8D.2
....................   spi_xfer(MAIN_FM,ENABLE_WRITE);                //Send 0x06
01826:  MOVLW  06
01828:  MOVLB  2
0182A:  MOVWF  xFD
0182C:  MOVLW  08
0182E:  MOVWF  xFE
01830:  MOVLW  01
01832:  MOVWF  xFF
01834:  MOVLB  0
01836:  RCALL  1690
....................   output_high(CS_PIN_1);  
01838:  BCF    F96.2
0183A:  BSF    F8D.2
....................   return;
0183C:  GOTO   1990 (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_COM(){
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
*
01D3A:  BCF    F93.3
01D3C:  BCF    F8A.3
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01D3E:  BCF    F94.4
01D40:  BCF    F8B.4
....................      spi_xfer(COM_FM,ENABLE_WRITE);                //Send 0x06
01D42:  MOVLW  06
01D44:  MOVLB  2
01D46:  MOVWF  xCC
01D48:  MOVLW  08
01D4A:  MOVWF  xCD
01D4C:  MOVLW  01
01D4E:  MOVWF  xCE
01D50:  MOVLB  0
01D52:  RCALL  1B8A
....................      output_high(CS_PIN_COM);
01D54:  BCF    F93.3
01D56:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01D58:  BCF    F94.4
01D5A:  BSF    F8B.4
....................   return;
01D5C:  GOTO   1DDA (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_ADCS(){
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
*
03DE8:  BCF    F92.5
03DEA:  BCF    F89.5
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
03DEC:  BCF    F92.2
03DEE:  BCF    F89.2
....................      spi_xfer(MISSION_FM,ENABLE_WRITE);                //Send 0x06
03DF0:  MOVLW  06
03DF2:  MOVLB  1
03DF4:  MOVWF  xEA
03DF6:  MOVLW  08
03DF8:  MOVWF  xEB
03DFA:  MOVLW  01
03DFC:  MOVWF  xEC
03DFE:  MOVLB  0
03E00:  CALL   1C64
....................      output_high(CS_PIN_MISSION);  
03E04:  BCF    F92.2
03E06:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
03E08:  BCF    F92.5
03E0A:  BSF    F89.5
....................   return;
03E0C:  RETURN 0
....................  }
....................  void WRITE_ENABLE_IHS(){
....................     // lower MX to connect to flash device
....................     output_low(MX_PIN_MVCAM);
....................     // LowerCS pin to activate the flash device
....................     output_low(CS_PIN_MISSION);
....................     spi_xfer(MISSION_FM,ENABLE_WRITE);                //Send 0x06
....................     output_high(CS_PIN_MISSION);
....................     output_high(MX_PIN_MVCAM);
....................   return;
....................  }
.................... 
....................  void WRITE_ENABLE_GENERIC(int STREAM, int CS_PIN, int MX_PIN) {
....................     // Lower MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_low(MX_PIN);
....................     }
.................... 
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN);
.................... 
....................     if(STREAM == 1) {
....................         spi_xfer(MAIN_FM, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 2) {
....................         spi_xfer(COM_FM, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 3) {
....................         spi_xfer(MISSION_FM, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } 
....................     // Raise CS to deselect the SPI device
....................     output_high(CS_PIN);
.................... 
....................     // Raise MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_high(MX_PIN);
....................     }
.................... }
....................  
....................  void SECTOR_ERASE_OF_ADCS(unsigned int32 sector_address) {
....................     unsigned int8 address[4];
....................     // Byte extraction for a 32-bit address
....................     address[0] = (unsigned int8)((sector_address >> 24) & 0xFF);
03E0E:  MOVLB  1
03E10:  MOVFF  1E0,1E1
03E14:  CLRF   03
....................     address[1] = (unsigned int8)((sector_address >> 16) & 0xFF);
03E16:  MOVFF  1DF,1E2
03E1A:  CLRF   03
....................     address[2] = (unsigned int8)((sector_address >> 8) & 0xFF);
03E1C:  MOVFF  1DE,1E3
03E20:  CLRF   03
....................     address[3] = (unsigned int8)(sector_address & 0xFF);
03E22:  MOVFF  1DD,1E4
03E26:  CLRF   03
.................... 
....................     // Enable write operation
....................     WRITE_ENABLE_OF_ADCS();
03E28:  MOVLB  0
03E2A:  RCALL  3DE8
.................... 
....................     // Lower MX to connect to flash device
....................     output_low(MX_PIN_ADCS);
03E2C:  BCF    F92.5
03E2E:  BCF    F89.5
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN_MISSION);
03E30:  BCF    F92.2
03E32:  BCF    F89.2
....................     delay_us(2);  // Small delay for stabilization
03E34:  MOVLW  02
03E36:  MOVWF  00
03E38:  DECFSZ 00,F
03E3A:  BRA    3E38
03E3C:  NOP   
.................... 
....................     // Send ERASE command and address
....................     spi_xfer(MISSION_FM, ERASE_SECTOR);
03E3E:  MOVLW  DC
03E40:  MOVLB  1
03E42:  MOVWF  xEA
03E44:  MOVLW  08
03E46:  MOVWF  xEB
03E48:  MOVLW  01
03E4A:  MOVWF  xEC
03E4C:  MOVLB  0
03E4E:  CALL   1C64
....................     spi_xfer(MISSION_FM, address[0]);
03E52:  MOVFF  1E1,1EA
03E56:  MOVLW  08
03E58:  MOVLB  1
03E5A:  MOVWF  xEB
03E5C:  MOVLW  01
03E5E:  MOVWF  xEC
03E60:  MOVLB  0
03E62:  CALL   1C64
....................     spi_xfer(MISSION_FM, address[1]);
03E66:  MOVFF  1E2,1EA
03E6A:  MOVLW  08
03E6C:  MOVLB  1
03E6E:  MOVWF  xEB
03E70:  MOVLW  01
03E72:  MOVWF  xEC
03E74:  MOVLB  0
03E76:  CALL   1C64
....................     spi_xfer(MISSION_FM, address[2]);
03E7A:  MOVFF  1E3,1EA
03E7E:  MOVLW  08
03E80:  MOVLB  1
03E82:  MOVWF  xEB
03E84:  MOVLW  01
03E86:  MOVWF  xEC
03E88:  MOVLB  0
03E8A:  CALL   1C64
....................     spi_xfer(MISSION_FM, address[3]);
03E8E:  MOVFF  1E4,1EA
03E92:  MOVLW  08
03E94:  MOVLB  1
03E96:  MOVWF  xEB
03E98:  MOVLW  01
03E9A:  MOVWF  xEC
03E9C:  MOVLB  0
03E9E:  CALL   1C64
.................... 
....................     // Deselect SPI device and MUX
....................     output_high(CS_PIN_MISSION);
03EA2:  BCF    F92.2
03EA4:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);
03EA6:  BCF    F92.5
03EA8:  BSF    F89.5
.................... 
....................     // Wait for the erase operation to complete
....................     delay_ms(10);
03EAA:  MOVLW  0A
03EAC:  MOVLB  1
03EAE:  MOVWF  xE5
03EB0:  MOVLB  0
03EB2:  CALL   1324
03EB6:  GOTO   4144 (RETURN)
.................... }
....................  
....................  void WRITE_DATA_NBYTES(unsigned int32 ADDRESS, unsigned int8* data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
01916:  MOVLW  06
01918:  MOVWF  FF6
0191A:  MOVLW  00
0191C:  MOVWF  FF7
0191E:  MOVLW  00
01920:  MOVWF  FF8
01922:  MOVLW  11
01924:  MOVLB  2
01926:  MOVWF  xFC
01928:  MOVLB  0
0192A:  RCALL  150A
0192C:  MOVFF  2F3,2FC
01930:  MOVLW  57
01932:  MOVLB  2
01934:  MOVWF  xFD
01936:  MOVLB  0
01938:  RCALL  17DC
0193A:  MOVFF  2F2,2FC
0193E:  MOVLW  57
01940:  MOVLB  2
01942:  MOVWF  xFD
01944:  MOVLB  0
01946:  RCALL  17DC
01948:  MOVFF  2F1,2FC
0194C:  MOVLW  57
0194E:  MOVLB  2
01950:  MOVWF  xFD
01952:  MOVLB  0
01954:  RCALL  17DC
01956:  MOVFF  2F0,2FC
0195A:  MOVLW  57
0195C:  MOVLB  2
0195E:  MOVWF  xFD
01960:  MOVLB  0
01962:  RCALL  17DC
01964:  MOVLW  0A
01966:  MOVLB  3
01968:  MOVWF  x02
0196A:  MOVLB  0
0196C:  RCALL  134E
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
0196E:  MOVLB  2
01970:  MOVFF  2F3,2F7
01974:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01976:  MOVLB  2
01978:  MOVFF  2F2,2F8
0197C:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
0197E:  MOVLB  2
01980:  MOVFF  2F1,2F9
01984:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
01986:  MOVFF  2F0,2FA
0198A:  CLRF   03
....................      WRITE_ENABLE_OF();  // Enable write operation
0198C:  MOVLB  0
0198E:  BRA    1822
....................  
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_1);
01990:  BCF    F96.2
01992:  BCF    F8D.2
....................      delay_us(2);  // Small delay for stabilization
01994:  MOVLW  02
01996:  MOVWF  00
01998:  DECFSZ 00,F
0199A:  BRA    1998
0199C:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(MAIN_FM, WRITE_PAGE);
0199E:  MOVLW  12
019A0:  MOVLB  2
019A2:  MOVWF  xFD
019A4:  MOVLW  08
019A6:  MOVWF  xFE
019A8:  MOVLW  01
019AA:  MOVWF  xFF
019AC:  MOVLB  0
019AE:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[0]);
019B0:  MOVFF  2F7,2FD
019B4:  MOVLW  08
019B6:  MOVLB  2
019B8:  MOVWF  xFE
019BA:  MOVLW  01
019BC:  MOVWF  xFF
019BE:  MOVLB  0
019C0:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[1]);
019C2:  MOVFF  2F8,2FD
019C6:  MOVLW  08
019C8:  MOVLB  2
019CA:  MOVWF  xFE
019CC:  MOVLW  01
019CE:  MOVWF  xFF
019D0:  MOVLB  0
019D2:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[2]);
019D4:  MOVFF  2F9,2FD
019D8:  MOVLW  08
019DA:  MOVLB  2
019DC:  MOVWF  xFE
019DE:  MOVLW  01
019E0:  MOVWF  xFF
019E2:  MOVLB  0
019E4:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[3]);
019E6:  MOVFF  2FA,2FD
019EA:  MOVLW  08
019EC:  MOVLB  2
019EE:  MOVWF  xFE
019F0:  MOVLW  01
019F2:  MOVWF  xFF
019F4:  MOVLB  0
019F6:  RCALL  1690
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
019F8:  MOVLB  2
019FA:  CLRF   xFB
019FC:  MOVF   xF6,W
019FE:  SUBWF  xFB,W
01A00:  BC    1A52
....................          spi_xfer(MAIN_FM, data[i]);  // Send data byte
01A02:  MOVF   xFB,W
01A04:  ADDWF  xF4,W
01A06:  MOVWF  FE9
01A08:  MOVLW  00
01A0A:  ADDWFC xF5,W
01A0C:  MOVWF  FEA
01A0E:  MOVFF  FEF,2FD
01A12:  MOVLW  08
01A14:  MOVWF  xFE
01A16:  MOVLW  01
01A18:  MOVWF  xFF
01A1A:  MOVLB  0
01A1C:  RCALL  1690
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (optional)
01A1E:  MOVLB  2
01A20:  MOVF   xFB,W
01A22:  ADDWF  xF4,W
01A24:  MOVWF  FE9
01A26:  MOVLW  00
01A28:  ADDWFC xF5,W
01A2A:  MOVWF  FEA
01A2C:  MOVFF  FEF,2FC
01A30:  MOVLW  01
01A32:  MOVWF  xFD
01A34:  MOVLW  20
01A36:  MOVLB  3
01A38:  MOVWF  x02
01A3A:  MOVLB  0
01A3C:  RCALL  134E
01A3E:  MOVLB  2
01A40:  DECFSZ xFD,F
01A42:  BRA    1A34
01A44:  MOVFF  2FC,302
01A48:  MOVLB  0
01A4A:  RCALL  134E
01A4C:  MOVLB  2
01A4E:  INCF   xFB,F
01A50:  BRA    19FC
....................      }
....................  //    for (int i = 0; i < data_number; i++) {
....................  //        spi_xfer(MAIN_FM, data[i]);  // Send data byte
....................  //        fprintf(EXT,"%02d", data[i]);    // Print each byte as hex (optional)
....................  //    } for futhre use this is for displaying in hex format 
....................      
....................      output_high(CS_PIN_1);  // Deselect SPI device
01A52:  BCF    F96.2
01A54:  BSF    F8D.2
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN MAIN!\n", data_number);
01A56:  MOVLW  0A
01A58:  MOVLB  3
01A5A:  MOVWF  x02
01A5C:  MOVLB  0
01A5E:  RCALL  134E
01A60:  MOVFF  2F6,2FC
01A64:  MOVLW  18
01A66:  MOVLB  2
01A68:  MOVWF  xFD
01A6A:  MOVLB  0
01A6C:  RCALL  1840
01A6E:  MOVLW  21
01A70:  MOVWF  FF6
01A72:  MOVLW  00
01A74:  MOVWF  FF7
01A76:  MOVLW  00
01A78:  MOVWF  FF8
01A7A:  MOVLW  18
01A7C:  MOVLB  2
01A7E:  MOVWF  xFC
01A80:  MOVLB  0
01A82:  RCALL  150A
....................      return;
01A84:  RETURN 0
....................  }
....................  
....................  
....................  void WRITE_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN COM: 0x%08lx\n", ADDRESS);  // Print address as hex
*
01D60:  MOVLW  3A
01D62:  MOVWF  FF6
01D64:  MOVLW  00
01D66:  MOVWF  FF7
01D68:  MOVLW  00
01D6A:  MOVWF  FF8
01D6C:  MOVLW  18
01D6E:  MOVLB  2
01D70:  MOVWF  xFC
01D72:  MOVLB  0
01D74:  CALL   150A
01D78:  MOVFF  1C3,2FC
01D7C:  MOVLW  57
01D7E:  MOVLB  2
01D80:  MOVWF  xFD
01D82:  MOVLB  0
01D84:  RCALL  17DC
01D86:  MOVFF  1C2,2FC
01D8A:  MOVLW  57
01D8C:  MOVLB  2
01D8E:  MOVWF  xFD
01D90:  MOVLB  0
01D92:  RCALL  17DC
01D94:  MOVFF  1C1,2FC
01D98:  MOVLW  57
01D9A:  MOVLB  2
01D9C:  MOVWF  xFD
01D9E:  MOVLB  0
01DA0:  RCALL  17DC
01DA2:  MOVFF  1C0,2FC
01DA6:  MOVLW  57
01DA8:  MOVLB  2
01DAA:  MOVWF  xFD
01DAC:  MOVLB  0
01DAE:  RCALL  17DC
01DB0:  MOVLW  0A
01DB2:  MOVLB  3
01DB4:  MOVWF  x02
01DB6:  MOVLB  0
01DB8:  CALL   134E
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
01DBC:  MOVLB  1
01DBE:  MOVFF  1C3,1C7
01DC2:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01DC4:  MOVFF  1C2,1C8
01DC8:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01DCA:  MOVFF  1C1,1C9
01DCE:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
01DD0:  MOVFF  1C0,1CA
01DD4:  CLRF   03
....................      WRITE_ENABLE_OF_COM();  // Enable write operation
01DD6:  MOVLB  0
01DD8:  BRA    1D3A
....................  
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01DDA:  BCF    F94.4
01DDC:  BCF    F8B.4
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
01DDE:  BCF    F93.3
01DE0:  BCF    F8A.3
....................      delay_us(2);  // Small delay for stabilization
01DE2:  MOVLW  02
01DE4:  MOVWF  00
01DE6:  DECFSZ 00,F
01DE8:  BRA    1DE6
01DEA:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(COM_FM, WRITE_PAGE);
01DEC:  MOVLW  12
01DEE:  MOVLB  2
01DF0:  MOVWF  xCC
01DF2:  MOVLW  08
01DF4:  MOVWF  xCD
01DF6:  MOVLW  01
01DF8:  MOVWF  xCE
01DFA:  MOVLB  0
01DFC:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[0]);
01DFE:  MOVFF  1C7,2CC
01E02:  MOVLW  08
01E04:  MOVLB  2
01E06:  MOVWF  xCD
01E08:  MOVLW  01
01E0A:  MOVWF  xCE
01E0C:  MOVLB  0
01E0E:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[1]);
01E10:  MOVFF  1C8,2CC
01E14:  MOVLW  08
01E16:  MOVLB  2
01E18:  MOVWF  xCD
01E1A:  MOVLW  01
01E1C:  MOVWF  xCE
01E1E:  MOVLB  0
01E20:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[2]);
01E22:  MOVFF  1C9,2CC
01E26:  MOVLW  08
01E28:  MOVLB  2
01E2A:  MOVWF  xCD
01E2C:  MOVLW  01
01E2E:  MOVWF  xCE
01E30:  MOVLB  0
01E32:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[3]);
01E34:  MOVFF  1CA,2CC
01E38:  MOVLW  08
01E3A:  MOVLB  2
01E3C:  MOVWF  xCD
01E3E:  MOVLW  01
01E40:  MOVWF  xCE
01E42:  MOVLB  0
01E44:  RCALL  1B8A
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
01E46:  MOVLB  1
01E48:  CLRF   xCB
01E4A:  MOVF   xC6,W
01E4C:  SUBWF  xCB,W
01E4E:  BC    1EA6
....................          spi_xfer(COM_FM, data[i]);  // Send data byte
01E50:  MOVF   xCB,W
01E52:  ADDWF  xC4,W
01E54:  MOVWF  FE9
01E56:  MOVLW  00
01E58:  ADDWFC xC5,W
01E5A:  MOVWF  FEA
01E5C:  MOVFF  FEF,2CC
01E60:  MOVLW  08
01E62:  MOVLB  2
01E64:  MOVWF  xCD
01E66:  MOVLW  01
01E68:  MOVWF  xCE
01E6A:  MOVLB  0
01E6C:  RCALL  1B8A
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
01E6E:  MOVLB  1
01E70:  MOVF   xCB,W
01E72:  ADDWF  xC4,W
01E74:  MOVWF  FE9
01E76:  MOVLW  00
01E78:  ADDWFC xC5,W
01E7A:  MOVWF  FEA
01E7C:  MOVFF  FEF,1CC
01E80:  MOVLW  01
01E82:  MOVWF  xCD
01E84:  MOVLW  20
01E86:  MOVLB  3
01E88:  MOVWF  x02
01E8A:  MOVLB  0
01E8C:  CALL   134E
01E90:  MOVLB  1
01E92:  DECFSZ xCD,F
01E94:  BRA    1E84
01E96:  MOVFF  1CC,302
01E9A:  MOVLB  0
01E9C:  CALL   134E
01EA0:  MOVLB  1
01EA2:  INCF   xCB,F
01EA4:  BRA    1E4A
....................      }
....................      
....................      output_high(CS_PIN_COM);  // Deselect SPI devices
01EA6:  BCF    F93.3
01EA8:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  //Deselect MUX from flash
01EAA:  BCF    F94.4
01EAC:  BSF    F8B.4
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN COM!\n", data_number);
01EAE:  MOVLW  0A
01EB0:  MOVLB  3
01EB2:  MOVWF  x02
01EB4:  MOVLB  0
01EB6:  CALL   134E
01EBA:  MOVFF  1C6,2FC
01EBE:  MOVLW  18
01EC0:  MOVLB  2
01EC2:  MOVWF  xFD
01EC4:  MOVLB  0
01EC6:  RCALL  1840
01EC8:  MOVLW  5D
01ECA:  MOVWF  FF6
01ECC:  MOVLW  00
01ECE:  MOVWF  FF7
01ED0:  MOVLW  00
01ED2:  MOVWF  FF8
01ED4:  MOVLW  17
01ED6:  MOVLB  2
01ED8:  MOVWF  xFC
01EDA:  MOVLB  0
01EDC:  CALL   150A
01EE0:  GOTO   4A8C (RETURN)
....................  }
....................  
....................  void WRITE_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN ADCS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
03EBA:  MOVLW  76
03EBC:  MOVWF  FF6
03EBE:  MOVLW  00
03EC0:  MOVWF  FF7
03EC2:  MOVLW  00
03EC4:  MOVWF  FF8
03EC6:  MOVLW  19
03EC8:  MOVLB  2
03ECA:  MOVWF  xFC
03ECC:  MOVLB  0
03ECE:  CALL   150A
03ED2:  MOVFF  1E0,2FC
03ED6:  MOVLW  57
03ED8:  MOVLB  2
03EDA:  MOVWF  xFD
03EDC:  MOVLB  0
03EDE:  CALL   17DC
03EE2:  MOVFF  1DF,2FC
03EE6:  MOVLW  57
03EE8:  MOVLB  2
03EEA:  MOVWF  xFD
03EEC:  MOVLB  0
03EEE:  CALL   17DC
03EF2:  MOVFF  1DE,2FC
03EF6:  MOVLW  57
03EF8:  MOVLB  2
03EFA:  MOVWF  xFD
03EFC:  MOVLB  0
03EFE:  CALL   17DC
03F02:  MOVFF  1DD,2FC
03F06:  MOVLW  57
03F08:  MOVLB  2
03F0A:  MOVWF  xFD
03F0C:  MOVLB  0
03F0E:  CALL   17DC
03F12:  MOVLW  0A
03F14:  MOVLB  3
03F16:  MOVWF  x02
03F18:  MOVLB  0
03F1A:  CALL   134E
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
03F1E:  MOVLB  1
03F20:  MOVFF  1E0,1E4
03F24:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
03F26:  MOVFF  1DF,1E5
03F2A:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
03F2C:  MOVFF  1DE,1E6
03F30:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
03F32:  MOVFF  1DD,1E7
03F36:  CLRF   03
....................      WRITE_ENABLE_OF_ADCS();  // Enable write operation and MX and CS pins are included in here 
03F38:  MOVLB  0
03F3A:  RCALL  3DE8
....................  
....................      //Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
03F3C:  BCF    F92.5
03F3E:  BCF    F89.5
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
03F40:  BCF    F92.2
03F42:  BCF    F89.2
....................      delay_us(2);  // Small delay for stabilization
03F44:  MOVLW  02
03F46:  MOVWF  00
03F48:  DECFSZ 00,F
03F4A:  BRA    3F48
03F4C:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(MISSION_FM, WRITE_PAGE);
03F4E:  MOVLW  12
03F50:  MOVLB  1
03F52:  MOVWF  xEA
03F54:  MOVLW  08
03F56:  MOVWF  xEB
03F58:  MOVLW  01
03F5A:  MOVWF  xEC
03F5C:  MOVLB  0
03F5E:  CALL   1C64
....................      spi_xfer(MISSION_FM, adsress[0]);
03F62:  MOVFF  1E4,1EA
03F66:  MOVLW  08
03F68:  MOVLB  1
03F6A:  MOVWF  xEB
03F6C:  MOVLW  01
03F6E:  MOVWF  xEC
03F70:  MOVLB  0
03F72:  CALL   1C64
....................      spi_xfer(MISSION_FM, adsress[1]);
03F76:  MOVFF  1E5,1EA
03F7A:  MOVLW  08
03F7C:  MOVLB  1
03F7E:  MOVWF  xEB
03F80:  MOVLW  01
03F82:  MOVWF  xEC
03F84:  MOVLB  0
03F86:  CALL   1C64
....................      spi_xfer(MISSION_FM, adsress[2]);
03F8A:  MOVFF  1E6,1EA
03F8E:  MOVLW  08
03F90:  MOVLB  1
03F92:  MOVWF  xEB
03F94:  MOVLW  01
03F96:  MOVWF  xEC
03F98:  MOVLB  0
03F9A:  CALL   1C64
....................      spi_xfer(MISSION_FM, adsress[3]);
03F9E:  MOVFF  1E7,1EA
03FA2:  MOVLW  08
03FA4:  MOVLB  1
03FA6:  MOVWF  xEB
03FA8:  MOVLW  01
03FAA:  MOVWF  xEC
03FAC:  MOVLB  0
03FAE:  CALL   1C64
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
03FB2:  MOVLB  1
03FB4:  CLRF   xE8
03FB6:  MOVF   xE3,W
03FB8:  SUBWF  xE8,W
03FBA:  BC    4012
....................          spi_xfer(MISSION_FM, data[i]);  // Send data byte
03FBC:  MOVF   xE8,W
03FBE:  ADDWF  xE1,W
03FC0:  MOVWF  FE9
03FC2:  MOVLW  00
03FC4:  ADDWFC xE2,W
03FC6:  MOVWF  FEA
03FC8:  MOVFF  FEF,1EA
03FCC:  MOVLW  08
03FCE:  MOVWF  xEB
03FD0:  MOVLW  01
03FD2:  MOVWF  xEC
03FD4:  MOVLB  0
03FD6:  CALL   1C64
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
03FDA:  MOVLB  1
03FDC:  MOVF   xE8,W
03FDE:  ADDWF  xE1,W
03FE0:  MOVWF  FE9
03FE2:  MOVLW  00
03FE4:  ADDWFC xE2,W
03FE6:  MOVWF  FEA
03FE8:  MOVFF  FEF,1E9
03FEC:  MOVLW  01
03FEE:  MOVWF  xEA
03FF0:  MOVLW  20
03FF2:  MOVLB  3
03FF4:  MOVWF  x02
03FF6:  MOVLB  0
03FF8:  CALL   134E
03FFC:  MOVLB  1
03FFE:  DECFSZ xEA,F
04000:  BRA    3FF0
04002:  MOVFF  1E9,302
04006:  MOVLB  0
04008:  CALL   134E
0400C:  MOVLB  1
0400E:  INCF   xE8,F
04010:  BRA    3FB6
....................      }
....................      
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device5
04012:  BCF    F92.2
04014:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
04016:  BCF    F92.5
04018:  BSF    F89.5
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN ADCS!\n", data_number);
0401A:  MOVLW  0A
0401C:  MOVLB  3
0401E:  MOVWF  x02
04020:  MOVLB  0
04022:  CALL   134E
04026:  MOVFF  1E3,2FC
0402A:  MOVLW  18
0402C:  MOVLB  2
0402E:  MOVWF  xFD
04030:  MOVLB  0
04032:  CALL   1840
04036:  MOVLW  99
04038:  MOVWF  FF6
0403A:  MOVLW  00
0403C:  MOVWF  FF7
0403E:  MOVLW  00
04040:  MOVWF  FF8
04042:  MOVLW  18
04044:  MOVLB  2
04046:  MOVWF  xFC
04048:  MOVLB  0
0404A:  CALL   150A
0404E:  GOTO   417A (RETURN)
....................  }
....................   
....................  
....................  char* READ_DATA_NBYTES(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  
....................  
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
016EC:  MOVFF  1EC,00
016F0:  MOVLB  2
016F2:  MOVFF  00,1EE
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
016F6:  MOVFF  1EB,00
016FA:  MOVFF  1EC,2F5
016FE:  MOVFF  00,1EF
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01702:  MOVFF  1EA,00
01706:  MOVFF  1EB,2F5
0170A:  MOVFF  1EC,2F6
0170E:  MOVFF  00,1F0
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
01712:  MOVLB  1
01714:  MOVFF  1E9,1F1
01718:  CLRF   03
....................  
....................      output_low(CS_PIN_1);  // Select SPI device
0171A:  BCF    F96.2
0171C:  BCF    F8D.2
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(MAIN_FM, READ_DATA_BYTES);
0171E:  MOVLW  13
01720:  MOVLB  2
01722:  MOVWF  xFD
01724:  MOVLW  08
01726:  MOVWF  xFE
01728:  MOVLW  01
0172A:  MOVWF  xFF
0172C:  MOVLB  0
0172E:  RCALL  1690
....................      // Send address bytes
....................      spi_xfer(MAIN_FM, adsress[0]);
01730:  MOVFF  1EE,2FD
01734:  MOVLW  08
01736:  MOVLB  2
01738:  MOVWF  xFE
0173A:  MOVLW  01
0173C:  MOVWF  xFF
0173E:  MOVLB  0
01740:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[1]);
01742:  MOVFF  1EF,2FD
01746:  MOVLW  08
01748:  MOVLB  2
0174A:  MOVWF  xFE
0174C:  MOVLW  01
0174E:  MOVWF  xFF
01750:  MOVLB  0
01752:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[2]);
01754:  MOVFF  1F0,2FD
01758:  MOVLW  08
0175A:  MOVLB  2
0175C:  MOVWF  xFE
0175E:  MOVLW  01
01760:  MOVWF  xFF
01762:  MOVLB  0
01764:  RCALL  1690
....................      spi_xfer(MAIN_FM, adsress[3]);
01766:  MOVFF  1F1,2FD
0176A:  MOVLW  08
0176C:  MOVLB  2
0176E:  MOVWF  xFE
01770:  MOVLW  01
01772:  MOVWF  xFF
01774:  MOVLB  0
01776:  RCALL  1690
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {  // Avoid overflow
01778:  MOVLB  2
0177A:  CLRF   xF2
0177C:  MOVLB  1
0177E:  MOVF   xED,W
01780:  MOVLB  2
01782:  SUBWF  xF2,W
01784:  BC    17C4
....................          Data_return[i] = spi_xfer(MAIN_FM, 0x00);  // Send dummy byte to receive data
01786:  CLRF   03
01788:  MOVF   xF2,W
0178A:  ADDLW  F2
0178C:  MOVWF  FE9
0178E:  MOVLW  01
01790:  ADDWFC 03,W
01792:  MOVWF  FEA
01794:  CLRF   xFD
01796:  MOVLW  08
01798:  MOVWF  xFE
0179A:  MOVLW  01
0179C:  MOVWF  xFF
0179E:  MOVLB  0
017A0:  RCALL  1690
017A2:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);  // Print each byte as hex
017A6:  CLRF   03
017A8:  MOVLB  2
017AA:  MOVF   xF2,W
017AC:  ADDLW  F2
017AE:  MOVWF  FE9
017B0:  MOVLW  01
017B2:  ADDWFC 03,W
017B4:  MOVWF  FEA
017B6:  MOVFF  FEF,302
017BA:  MOVLB  0
017BC:  RCALL  134E
017BE:  MOVLB  2
017C0:  INCF   xF2,F
017C2:  BRA    177C
....................      }
....................  
....................      output_high(CS_PIN_1);  // Deselect SPI device after reading
017C4:  BCF    F96.2
017C6:  BSF    F8D.2
....................      fprintf(EXT, "\n");
017C8:  MOVLW  0A
017CA:  MOVLB  3
017CC:  MOVWF  x02
017CE:  MOVLB  0
017D0:  RCALL  134E
....................  
....................      return Data_return;
017D2:  MOVLW  F2
017D4:  MOVWF  01
017D6:  MOVLW  01
017D8:  MOVWF  02
017DA:  RETURN 0
....................  }
....................  
....................  
....................  
....................  char* READ_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  // 
....................      
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
01EE4:  MOVFF  1C3,00
01EE8:  MOVLB  2
01EEA:  MOVFF  00,1C5
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01EEE:  MOVFF  1C2,00
01EF2:  MOVFF  1C3,2CC
01EF6:  MOVFF  00,1C6
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01EFA:  MOVFF  1C1,00
01EFE:  MOVFF  1C2,2CC
01F02:  MOVFF  1C3,2CD
01F06:  MOVFF  00,1C7
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
01F0A:  MOVLB  1
01F0C:  MOVFF  1C0,1C8
01F10:  CLRF   03
....................  
....................      output_low(MX_PIN_COM);  // Lower MX to connect to flash device
01F12:  BCF    F94.4
01F14:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Select SPI device
01F16:  BCF    F93.3
01F18:  BCF    F8A.3
....................  
....................      // Send READ DATA COMMAND
....................      spi_xfer(COM_FM, READ_DATA_BYTES);
01F1A:  MOVLW  13
01F1C:  MOVLB  2
01F1E:  MOVWF  xCC
01F20:  MOVLW  08
01F22:  MOVWF  xCD
01F24:  MOVLW  01
01F26:  MOVWF  xCE
01F28:  MOVLB  0
01F2A:  RCALL  1B8A
....................      // Send address bytes
....................      spi_xfer(COM_FM, adsress[0]);
01F2C:  MOVFF  1C5,2CC
01F30:  MOVLW  08
01F32:  MOVLB  2
01F34:  MOVWF  xCD
01F36:  MOVLW  01
01F38:  MOVWF  xCE
01F3A:  MOVLB  0
01F3C:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[1]);
01F3E:  MOVFF  1C6,2CC
01F42:  MOVLW  08
01F44:  MOVLB  2
01F46:  MOVWF  xCD
01F48:  MOVLW  01
01F4A:  MOVWF  xCE
01F4C:  MOVLB  0
01F4E:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[2]);
01F50:  MOVFF  1C7,2CC
01F54:  MOVLW  08
01F56:  MOVLB  2
01F58:  MOVWF  xCD
01F5A:  MOVLW  01
01F5C:  MOVWF  xCE
01F5E:  MOVLB  0
01F60:  RCALL  1B8A
....................      spi_xfer(COM_FM, adsress[3]);
01F62:  MOVFF  1C8,2CC
01F66:  MOVLW  08
01F68:  MOVLB  2
01F6A:  MOVWF  xCD
01F6C:  MOVLW  01
01F6E:  MOVWF  xCE
01F70:  MOVLB  0
01F72:  RCALL  1B8A
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {
01F74:  MOVLB  2
01F76:  CLRF   xC9
01F78:  MOVLB  1
01F7A:  MOVF   xC4,W
01F7C:  MOVLB  2
01F7E:  SUBWF  xC9,W
01F80:  BC    1FC2
....................          Data_return[i] = spi_xfer(COM_FM, 0x00);  // Send dummy byte to receive data
01F82:  CLRF   03
01F84:  MOVF   xC9,W
01F86:  ADDLW  C9
01F88:  MOVWF  FE9
01F8A:  MOVLW  01
01F8C:  ADDWFC 03,W
01F8E:  MOVWF  FEA
01F90:  CLRF   xCC
01F92:  MOVLW  08
01F94:  MOVWF  xCD
01F96:  MOVLW  01
01F98:  MOVWF  xCE
01F9A:  MOVLB  0
01F9C:  RCALL  1B8A
01F9E:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);         // Print each byte
01FA2:  CLRF   03
01FA4:  MOVLB  2
01FA6:  MOVF   xC9,W
01FA8:  ADDLW  C9
01FAA:  MOVWF  FE9
01FAC:  MOVLW  01
01FAE:  ADDWFC 03,W
01FB0:  MOVWF  FEA
01FB2:  MOVFF  FEF,302
01FB6:  MOVLB  0
01FB8:  CALL   134E
01FBC:  MOVLB  2
01FBE:  INCF   xC9,F
01FC0:  BRA    1F78
....................      }
....................  
....................      output_high(CS_PIN_COM);  // Deselect SPI device
01FC2:  BCF    F93.3
01FC4:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  // Deselect MUX from flash
01FC6:  BCF    F94.4
01FC8:  BSF    F8B.4
....................      fprintf(EXT, "\n");
01FCA:  MOVLW  0A
01FCC:  MOVLB  3
01FCE:  MOVWF  x02
01FD0:  MOVLB  0
01FD2:  CALL   134E
....................  
....................      return Data_return;
01FD6:  MOVLW  C9
01FD8:  MOVWF  01
01FDA:  MOVLW  01
01FDC:  MOVWF  02
01FDE:  GOTO   4AB6 (RETURN)
....................  }
.................... 
.................... #define MAX_DATA_SIZE 256  // Define the maximum data size
.................... 
.................... unsigned int8 Data_return[MAX_DATA_SIZE];  // Static buffer to hold the data
.................... 
.................... unsigned int8* READ_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned short data_number) {
....................     unsigned int8 adsress[4];
.................... 
....................     // Ensure data_number does not exceed the maximum buffer size
....................     if (data_number > MAX_DATA_SIZE) {
....................         data_number = MAX_DATA_SIZE;
....................     }
.................... 
....................     // Byte extraction for a 32-bit address
....................     adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
04052:  MOVLB  1
04054:  MOVFF  1E0,1E2
04058:  CLRF   03
....................     adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
0405A:  MOVFF  1DF,1E3
0405E:  CLRF   03
....................     adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
04060:  MOVFF  1DE,1E4
04064:  CLRF   03
....................     adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
04066:  MOVFF  1DD,1E5
0406A:  CLRF   03
.................... 
....................     output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
0406C:  BCF    F92.5
0406E:  BCF    F89.5
....................     output_low(CS_PIN_MISSION);  // Select SPI device
04070:  BCF    F92.2
04072:  BCF    F89.2
.................... 
....................     // Send READ DATA COMMAND
....................     spi_xfer(MISSION_FM, READ_DATA_BYTES);
04074:  MOVLW  13
04076:  MOVWF  xEA
04078:  MOVLW  08
0407A:  MOVWF  xEB
0407C:  MOVLW  01
0407E:  MOVWF  xEC
04080:  MOVLB  0
04082:  CALL   1C64
....................     // Send address bytes
....................     spi_xfer(MISSION_FM, adsress[0]);
04086:  MOVFF  1E2,1EA
0408A:  MOVLW  08
0408C:  MOVLB  1
0408E:  MOVWF  xEB
04090:  MOVLW  01
04092:  MOVWF  xEC
04094:  MOVLB  0
04096:  CALL   1C64
....................     spi_xfer(MISSION_FM, adsress[1]);
0409A:  MOVFF  1E3,1EA
0409E:  MOVLW  08
040A0:  MOVLB  1
040A2:  MOVWF  xEB
040A4:  MOVLW  01
040A6:  MOVWF  xEC
040A8:  MOVLB  0
040AA:  CALL   1C64
....................     spi_xfer(MISSION_FM, adsress[2]);
040AE:  MOVFF  1E4,1EA
040B2:  MOVLW  08
040B4:  MOVLB  1
040B6:  MOVWF  xEB
040B8:  MOVLW  01
040BA:  MOVWF  xEC
040BC:  MOVLB  0
040BE:  CALL   1C64
....................     spi_xfer(MISSION_FM, adsress[3]);
040C2:  MOVFF  1E5,1EA
040C6:  MOVLW  08
040C8:  MOVLB  1
040CA:  MOVWF  xEB
040CC:  MOVLW  01
040CE:  MOVWF  xEC
040D0:  MOVLB  0
040D2:  CALL   1C64
.................... 
....................     // Read the requested number of bytes
....................     // for (int i = 0; i < data_number; i++) {
....................     //     Data_return[i] = spi_xfer(MISSION_FM, 0x00);  // Send dummy byte to receive data
....................     //     fprintf(EXT, "  0x%02x", Data_return[i]);  // Print each byte (optional)
....................     //     fprintf(EXT, "\n");
....................     // }
.................... 
....................     output_high(CS_PIN_MISSION);  // Deselect SPI device
040D6:  BCF    F92.2
040D8:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);  // Deselect MUX from flash
040DA:  BCF    F92.5
040DC:  BSF    F89.5
....................     fprintf(EXT, "\n");
040DE:  MOVLW  0A
040E0:  MOVLB  3
040E2:  MOVWF  x02
040E4:  MOVLB  0
040E6:  CALL   134E
.................... 
....................     return Data_return;
040EA:  MOVLW  06
040EC:  MOVWF  01
040EE:  MOVLW  00
040F0:  MOVWF  02
040F2:  RETURN 0
.................... }
....................  
....................  
....................  int8 READ_DATA_BYTES_ADCS(unsigned int32 ADDRESS) {
....................      unsigned int8 adsress[4];
....................      unsigned int8 Data_return;
....................     
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
....................  
....................      output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
....................      output_low(CS_PIN_MISSION);  // Select SPI device
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(MISSION_FM, READ_DATA_BYTES);
....................      // Send address bytes
....................      spi_xfer(MISSION_FM, adsress[0]);
....................      spi_xfer(MISSION_FM, adsress[1]);
....................      spi_xfer(MISSION_FM, adsress[2]);
....................      spi_xfer(MISSION_FM, adsress[3]);
....................      // Read the requested number of bytes
....................          Data_return = spi_xfer(MISSION_FM, 0x00);  // Send dummy byte to receive data
....................  
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device after reading
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
....................      return Data_return;
....................  }
....................  void READ_CHIP_ID_OF() {
....................      int8 chip_id[8];
....................      output_low(CS_PIN_1);  // Lower the CS PIN
*
0296E:  BCF    F96.2
02970:  BCF    F8D.2
....................      spi_xfer(MAIN_FM, READ_ID);  // READ ID COMMAND (0x9F)
02972:  MOVLW  9F
02974:  MOVLB  2
02976:  MOVWF  xFD
02978:  MOVLW  08
0297A:  MOVWF  xFE
0297C:  MOVLW  01
0297E:  MOVWF  xFF
02980:  MOVLB  0
02982:  CALL   1690
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
02986:  MOVLB  1
02988:  CLRF   xF1
0298A:  MOVF   xF1,W
0298C:  SUBLW  07
0298E:  BNC   29E6
....................          chip_id[i] = spi_xfer(MAIN_FM, 0x00);  // Send dummy bytes to receive data
02990:  CLRF   03
02992:  MOVF   xF1,W
02994:  ADDLW  E9
02996:  MOVWF  FE9
02998:  MOVLW  01
0299A:  ADDWFC 03,W
0299C:  MOVWF  FEA
0299E:  MOVLB  2
029A0:  CLRF   xFD
029A2:  MOVLW  08
029A4:  MOVWF  xFE
029A6:  MOVLW  01
029A8:  MOVWF  xFF
029AA:  MOVLB  0
029AC:  CALL   1690
029B0:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
029B4:  CLRF   03
029B6:  MOVLB  1
029B8:  MOVF   xF1,W
029BA:  ADDLW  E9
029BC:  MOVWF  FE9
029BE:  MOVLW  01
029C0:  ADDWFC 03,W
029C2:  MOVWF  FEA
029C4:  MOVFF  FEF,2FC
029C8:  MOVLW  37
029CA:  MOVLB  2
029CC:  MOVWF  xFD
029CE:  MOVLB  0
029D0:  CALL   17DC
029D4:  MOVLW  20
029D6:  MOVLB  3
029D8:  MOVWF  x02
029DA:  MOVLB  0
029DC:  CALL   134E
029E0:  MOVLB  1
029E2:  INCF   xF1,F
029E4:  BRA    298A
....................      }
....................      fprintf(EXT,"\n");
029E6:  MOVLW  0A
029E8:  MOVLB  3
029EA:  MOVWF  x02
029EC:  MOVLB  0
029EE:  CALL   134E
....................  
....................      output_high(CS_PIN_1);  // Raise CS PIN back
029F2:  BCF    F96.2
029F4:  BSF    F8D.2
029F6:  GOTO   30B2 (RETURN)
....................  }
....................  void READ_CHIP_ID_OF_COM() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_COM);
*
01BD6:  BCF    F94.4
01BD8:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Lower the CS PIN
01BDA:  BCF    F93.3
01BDC:  BCF    F8A.3
....................      spi_xfer(COM_FM, READ_ID);  // READ ID COMMAND (0x9F)
01BDE:  MOVLW  9F
01BE0:  MOVLB  2
01BE2:  MOVWF  xCC
01BE4:  MOVLW  08
01BE6:  MOVWF  xCD
01BE8:  MOVLW  01
01BEA:  MOVWF  xCE
01BEC:  MOVLB  0
01BEE:  RCALL  1B8A
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01BF0:  MOVLB  1
01BF2:  CLRF   xC8
01BF4:  MOVF   xC8,W
01BF6:  SUBLW  07
01BF8:  BNC   1C4C
....................          chip_id[i] = spi_xfer(COM_FM, 0x00);  // Send dummy bytes to receive data
01BFA:  CLRF   03
01BFC:  MOVF   xC8,W
01BFE:  ADDLW  C0
01C00:  MOVWF  FE9
01C02:  MOVLW  01
01C04:  ADDWFC 03,W
01C06:  MOVWF  FEA
01C08:  MOVLB  2
01C0A:  CLRF   xCC
01C0C:  MOVLW  08
01C0E:  MOVWF  xCD
01C10:  MOVLW  01
01C12:  MOVWF  xCE
01C14:  MOVLB  0
01C16:  RCALL  1B8A
01C18:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01C1C:  CLRF   03
01C1E:  MOVLB  1
01C20:  MOVF   xC8,W
01C22:  ADDLW  C0
01C24:  MOVWF  FE9
01C26:  MOVLW  01
01C28:  ADDWFC 03,W
01C2A:  MOVWF  FEA
01C2C:  MOVFF  FEF,2FC
01C30:  MOVLW  37
01C32:  MOVLB  2
01C34:  MOVWF  xFD
01C36:  MOVLB  0
01C38:  RCALL  17DC
01C3A:  MOVLW  20
01C3C:  MOVLB  3
01C3E:  MOVWF  x02
01C40:  MOVLB  0
01C42:  CALL   134E
01C46:  MOVLB  1
01C48:  INCF   xC8,F
01C4A:  BRA    1BF4
....................      }
....................      fprintf(EXT,"\n");
01C4C:  MOVLW  0A
01C4E:  MOVLB  3
01C50:  MOVWF  x02
01C52:  MOVLB  0
01C54:  CALL   134E
....................  
....................      output_high(CS_PIN_COM);  // Raise CS PIN back
01C58:  BCF    F93.3
01C5A:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01C5C:  BCF    F94.4
01C5E:  BSF    F8B.4
01C60:  GOTO   4988 (RETURN)
....................  }
....................  
....................  void READ_CHIP_ID_OF_ADCS() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_ADCS);
*
01CB0:  BCF    F92.5
01CB2:  BCF    F89.5
....................      output_low(CS_PIN_MISSION);  // Lower the CS PIN
01CB4:  BCF    F92.2
01CB6:  BCF    F89.2
....................      spi_xfer(MISSION_FM, READ_ID);  // READ ID COMMAND (0x9F)
01CB8:  MOVLW  9F
01CBA:  MOVLB  1
01CBC:  MOVWF  xEA
01CBE:  MOVLW  08
01CC0:  MOVWF  xEB
01CC2:  MOVLW  01
01CC4:  MOVWF  xEC
01CC6:  MOVLB  0
01CC8:  RCALL  1C64
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01CCA:  MOVLB  1
01CCC:  CLRF   xE5
01CCE:  MOVF   xE5,W
01CD0:  SUBLW  07
01CD2:  BNC   1D24
....................          chip_id[i] = spi_xfer(MISSION_FM, 0x00);  // Send dummy bytes to receive data
01CD4:  CLRF   03
01CD6:  MOVF   xE5,W
01CD8:  ADDLW  DD
01CDA:  MOVWF  FE9
01CDC:  MOVLW  01
01CDE:  ADDWFC 03,W
01CE0:  MOVWF  FEA
01CE2:  CLRF   xEA
01CE4:  MOVLW  08
01CE6:  MOVWF  xEB
01CE8:  MOVLW  01
01CEA:  MOVWF  xEC
01CEC:  MOVLB  0
01CEE:  RCALL  1C64
01CF0:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01CF4:  CLRF   03
01CF6:  MOVLB  1
01CF8:  MOVF   xE5,W
01CFA:  ADDLW  DD
01CFC:  MOVWF  FE9
01CFE:  MOVLW  01
01D00:  ADDWFC 03,W
01D02:  MOVWF  FEA
01D04:  MOVFF  FEF,2FC
01D08:  MOVLW  37
01D0A:  MOVLB  2
01D0C:  MOVWF  xFD
01D0E:  MOVLB  0
01D10:  RCALL  17DC
01D12:  MOVLW  20
01D14:  MOVLB  3
01D16:  MOVWF  x02
01D18:  MOVLB  0
01D1A:  CALL   134E
01D1E:  MOVLB  1
01D20:  INCF   xE5,F
01D22:  BRA    1CCE
....................      }
....................      fprintf(EXT,"\n");
01D24:  MOVLW  0A
01D26:  MOVLB  3
01D28:  MOVWF  x02
01D2A:  MOVLB  0
01D2C:  CALL   134E
....................  
....................      output_high(CS_PIN_MISSION);  // Raise CS PIN back
01D30:  BCF    F92.2
01D32:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
01D34:  BCF    F92.5
01D36:  BSF    F89.5
01D38:  RETURN 0
....................  }
.................... //  void READ_CHIP_ID_GENERIC(int MAIN_FM, int CS_PIN, int MX_PIN) {
.................... //     int8 chip_id[8];
.................... 
.................... //     // Lower MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_low(MX_PIN);
.................... //     }
.................... 
.................... //     // Lower CS to select the SPI device
.................... //     output_low(CS_PIN);
.................... 
.................... //     // Send READ ID command
.................... //     spi_xfer(MAIN_FM, READ_ID);
.................... 
.................... //     // Receive 8 bytes of chip ID
.................... //     for (int i = 0; i < 8; i++) {
.................... //         chip_id[i] = spi_xfer(MAIN_FM, 0x00);  // Send dummy bytes to receive data
.................... //         fprintf(EXT, "%02X ", chip_id[i]);    // Print each byte in hex
.................... //     }
.................... //     fprintf(EXT, "\n");
.................... 
.................... //     // Raise CS to deselect the SPI device
.................... //     output_high(CS_PIN);
.................... 
.................... //     // Raise MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_high(MX_PIN);
.................... //     }
.................... // }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //Command operation
....................  //void SEND_COMMAND_ADCS(void){
....................  //    WRITE_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS, ADCS_COMMAND,1);
....................  //}
....................  ////void READ_HK_ADCS(void){
....................  ////    int8 state_of_pin = 0;
....................  ////    
....................  ////    state_of_pin = input_state(EN_SUP_3V3_2);
....................  ////    if(state_of_pin = FALSE){ 
....................  ////        READ_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS[16], READ_HK_ADCS, 16);
....................  ////        
....................  ////    }
....................  ////}
....................  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  ////EEPROM operation 
....................  ////thus functions used to store essential data order to prevent loosing it in unexpected shutdowns  
....................  //void EEPROM_
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // Main menu functions
....................  
....................  void startup_freeze(){
....................      delay_ms(2000);
*
013BA:  MOVLW  08
013BC:  MOVLB  1
013BE:  MOVWF  xC0
013C0:  MOVLW  FA
013C2:  MOVWF  xE5
013C4:  MOVLB  0
013C6:  RCALL  1324
013C8:  MOVLB  1
013CA:  DECFSZ xC0,F
013CC:  BRA    13C0
....................      fprintf(EXT, "POWER ON!\n");
013CE:  MOVLW  B2
013D0:  MOVWF  FF6
013D2:  MOVLW  00
013D4:  MOVWF  FF7
013D6:  MOVLW  00
013D8:  MOVWF  FF8
013DA:  MOVLB  0
013DC:  RCALL  1392
....................      //EPS power control all disabled when startup, using menu function will turn on
....................      output_low(EN_SUP_3V3_1);
013DE:  BCF    F93.0
013E0:  BCF    F8A.0
....................      output_high(EN_SUP_3V3_2 );
013E2:  BCF    F98.1
013E4:  BSF    F8F.1
....................      output_low(EN_SUP_3V3_DAQ);
013E6:  BCF    F95.0
013E8:  BCF    F8C.0
....................      output_low(EN_SUP_UNREG);
013EA:  BCF    F93.1
013EC:  BCF    F8A.1
....................      output_low(EN_SUP_5V0);
013EE:  BCF    F95.1
013F0:  BCF    F8C.1
....................      output_low(MVCAM_PWR);
013F2:  BCF    F98.0
013F4:  BCF    F8F.0
....................      output_high(OVCAM_PWR);
013F6:  BCF    F95.7
013F8:  BSF    F8C.7
....................      output_high(ADCS_PWR); //turns on the power of ADCS instantly 
013FA:  BCF    F95.6
013FC:  BSF    F8C.6
....................      output_high(CS_PIN_1);
013FE:  BCF    F96.2
01400:  BSF    F8D.2
....................      output_high(CS_PIN_COM );
01402:  BCF    F93.3
01404:  BSF    F8A.3
....................      output_high(CS_PIN_MISSION);
01406:  BCF    F92.2
01408:  BSF    F89.2
....................      output_high(MX_PIN_OVCAM);
0140A:  BCF    F98.2
0140C:  BSF    F8F.2
....................      output_high(MX_PIN_MVCAM );
0140E:  BCF    F98.3
01410:  BSF    F8F.3
....................      output_high(MX_PIN_ADCS );
01412:  BCF    F92.5
01414:  BSF    F89.5
....................      output_high(MX_PIN_COM );
01416:  BCF    F94.4
01418:  BSF    F8B.4
....................      
....................      fprintf(EXT, "Digital pin out configured \n");
0141A:  MOVLW  BE
0141C:  MOVWF  FF6
0141E:  MOVLW  00
01420:  MOVWF  FF7
01422:  MOVLW  00
01424:  MOVWF  FF8
01426:  RCALL  1392
01428:  GOTO   495C (RETURN)
....................          
....................  }
....................  //set RTCC functions counting to all zero 
....................  void set_clock(rtc_time_t &date_time){
....................  
....................     date_time.tm_year=0000;
*
01560:  MOVLB  1
01562:  CLRF   xC0
*
0333A:  MOVLB  1
0333C:  CLRF   xC2
....................     date_time.tm_mon=00;
*
01564:  CLRF   xC3
*
0333E:  CLRF   xC5
....................     date_time.tm_mday=00;
*
01566:  CLRF   xC2
*
03340:  CLRF   xC4
....................     date_time.tm_wday=00;
*
01568:  CLRF   xC5
*
03342:  CLRF   xC7
....................     date_time.tm_hour=00;
*
0156A:  CLRF   xC4
*
03344:  CLRF   xC6
....................     date_time.tm_min=00;
*
0156C:  CLRF   xC7
*
03346:  CLRF   xC9
....................     date_time.tm_sec=0; 
*
0156E:  CLRF   xC6
01570:  MOVLB  F
*
03348:  CLRF   xC8
0334A:  MOVLB  F
....................  }
.................... 
....................  void RTC_initialize(){
....................      setup_lcd(LCD_DISABLED);
*
0153A:  MOVLB  E
0153C:  CLRF   xD6
0153E:  CLRF   xD7
01540:  CLRF   xDA
01542:  CLRF   xD8
01544:  CLRF   xD9
01546:  MOVLB  F
....................      rtc_time_t write_clock, read_clock;
....................      setup_rtc(RTC_ENABLE | RTC_CLOCK_SOSC | RTC_CLOCK_INT, 0);
01548:  MOVLB  F
0154A:  MOVLW  55
0154C:  MOVWF  F7E
0154E:  MOVLW  AA
01550:  MOVWF  F7E
01552:  BSF    x5F.5
01554:  CLRF   x5E
01556:  MOVLW  04
01558:  MOVWF  x57
0155A:  MOVLW  80
0155C:  MOVWF  x5F
0155E:  BCF    x5F.5
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
01572:  MOVLB  F
01574:  MOVLW  55
01576:  MOVWF  F7E
01578:  MOVLW  AA
0157A:  MOVWF  F7E
0157C:  BSF    x5F.5
0157E:  BSF    x5F.0
01580:  BSF    x5F.1
01582:  MOVLW  01
01584:  MOVWF  FEA
01586:  MOVLW  C0
01588:  MOVWF  FE9
0158A:  MOVLW  04
0158C:  MOVWF  01
0158E:  MOVF   FEE,W
01590:  MOVLB  0
01592:  RCALL  142C
01594:  MOVLB  F
01596:  MOVWF  x5C
01598:  MOVF   FEE,W
0159A:  MOVLB  0
0159C:  RCALL  142C
0159E:  MOVLB  F
015A0:  MOVWF  x5D
015A2:  DECFSZ 01,F
015A4:  BRA    158E
015A6:  BCF    x5F.5
....................      rtc_read(&read_clock);
015A8:  BSF    x5F.0
015AA:  BSF    x5F.1
015AC:  MOVLW  01
015AE:  MOVWF  FEA
015B0:  MOVLW  C9
015B2:  MOVWF  FE9
015B4:  MOVLW  04
015B6:  MOVWF  01
015B8:  MOVF   x5C,W
015BA:  MOVLB  0
015BC:  RCALL  1450
015BE:  MOVWF  FEE
015C0:  MOVLB  F
015C2:  MOVF   x5D,W
015C4:  MOVLB  0
015C6:  RCALL  1450
015C8:  MOVWF  FEE
015CA:  DECFSZ 01,F
015CC:  BRA    15D0
015CE:  BRA    15D4
015D0:  MOVLB  F
015D2:  BRA    15B8
....................      read_clock.tm_year - 2000; 
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year , read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
015D4:  MOVLW  0D
015D6:  MOVLB  3
015D8:  MOVWF  x02
015DA:  MOVLB  0
015DC:  RCALL  134E
015DE:  MOVFF  1CC,1DE
015E2:  MOVLW  01
015E4:  MOVLB  1
015E6:  MOVWF  xDF
015E8:  MOVLB  0
015EA:  RCALL  148E
015EC:  MOVLW  2F
015EE:  MOVLB  3
015F0:  MOVWF  x02
015F2:  MOVLB  0
015F4:  RCALL  134E
015F6:  MOVFF  1CB,1DE
015FA:  MOVLW  01
015FC:  MOVLB  1
015FE:  MOVWF  xDF
01600:  MOVLB  0
01602:  RCALL  148E
01604:  MOVLW  E6
01606:  MOVWF  FF6
01608:  MOVLW  00
0160A:  MOVWF  FF7
0160C:  MOVLW  00
0160E:  MOVWF  FF8
01610:  MOVLW  03
01612:  MOVLB  2
01614:  MOVWF  xFC
01616:  MOVLB  0
01618:  RCALL  150A
0161A:  MOVFF  1C9,1DE
0161E:  MOVLW  01
01620:  MOVLB  1
01622:  MOVWF  xDF
01624:  MOVLB  0
01626:  RCALL  148E
01628:  MOVLW  20
0162A:  MOVLB  3
0162C:  MOVWF  x02
0162E:  MOVLB  0
01630:  RCALL  134E
01632:  MOVFF  1CD,1DE
01636:  MOVLW  01
01638:  MOVLB  1
0163A:  MOVWF  xDF
0163C:  MOVLB  0
0163E:  RCALL  148E
01640:  MOVLW  3A
01642:  MOVLB  3
01644:  MOVWF  x02
01646:  MOVLB  0
01648:  RCALL  134E
0164A:  MOVFF  1D0,1DE
0164E:  MOVLW  01
01650:  MOVLB  1
01652:  MOVWF  xDF
01654:  MOVLB  0
01656:  RCALL  148E
01658:  MOVLW  3A
0165A:  MOVLB  3
0165C:  MOVWF  x02
0165E:  MOVLB  0
01660:  RCALL  134E
01662:  MOVFF  1CF,1DE
01666:  MOVLW  01
01668:  MOVLB  1
0166A:  MOVWF  xDF
0166C:  MOVLB  0
0166E:  RCALL  148E
.................... 
....................      fprintf(EXT, "RTCC setup finished!\n");
01670:  MOVLW  FE
01672:  MOVWF  FF6
01674:  MOVLW  00
01676:  MOVWF  FF7
01678:  MOVLW  00
0167A:  MOVWF  FF8
0167C:  RCALL  1392
....................      fprintf(EXT, "RTCC setup finished!\n");
0167E:  MOVLW  14
01680:  MOVWF  FF6
01682:  MOVLW  01
01684:  MOVWF  FF7
01686:  MOVLW  00
01688:  MOVWF  FF8
0168A:  RCALL  1392
0168C:  GOTO   4960 (RETURN)
....................  
....................  }
....................  
....................  //this function will receive from EPS and sent to external port of EXT single character by character   
....................  void uart_repeater() {
....................      int received_data;
....................      while (TRUE) {
....................          // Check if data is available on the EPS stream
....................          if (kbhit(EPS)) {
....................              // Read one byte from the EPS stream
....................              received_data = fgetc(EPS);
....................              // Send the received byte to the EXT stream
....................              fputc(received_data, EXT);
....................          }
....................      }
....................  }
....................  // Function to receive exactly 16 bytes from UART
....................  void receive_16_bytes(int8* buffer) {
....................      for (int8 i = 0; i < 16; i++) {
....................          buffer[i] = getc(EPS);  // Blocks until a byte is received
....................      }
....................  }
....................  
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //adcs command
....................  //
....................  //#define SHUTDOWN_COUNT_ADDRESS  0x00001000  // Address where shutdown count is stored
....................  // this function is not working correctly need to fix it 
....................  int8 *read_data_adcs; //ADCS flash received data will be stored in here 
.................... int8 adcs_mission[3] = {0x33, 0x05, 0x05}; // mission command for ADCS all sensors will run for 3 minutes 
.................... int8 adcs_mag[3] = {0x22, 0x01, 0x05}; // mag each 9 bytes for measurement
.................... int8 adcs_gyro[3] = {0x11, 0x01, 0x05}; // gyro each 9 bytes for measurement 
.................... int8 last_adcs[5] = {0x00, 0x00, 0x00, 0x00, 0x00}; // last command for ADCS 
.................... int8 adcs_quick[3] = {0x33, 0x05, 0x01}; // quick mission for ADCS 
....................                 // first byte is measurement size /9 byte/, second byte is measurement count
....................                 // (how many measurements are taken), (last address of the data)x4 not inverted
....................                 // we will multiply measurement size and how many measurements are taken and subtract from the last address
....................                 // to get the first measurement address of the data
....................                 // later we will read the data from the first address to the last address
.................... int8 adcs_status_address = 0x00020000; // status address of the adcs first byte is measrument count /each 9 byte/, last 4 is last address
.................... int8 adcs_gyro_first_address = 0x00030000; // first address of the gyro data 
.................... 
.................... 
.................... void adcs_mission_mode(void) {
*
040F4:  MOVLB  1
040F6:  CLRF   xCC
040F8:  CLRF   xD0
040FA:  CLRF   xCF
040FC:  CLRF   xCE
040FE:  CLRF   xCD
04100:  CLRF   xD4
04102:  CLRF   xD3
04104:  CLRF   xD2
04106:  CLRF   xD1
....................     // 1. Local storage to prevent pointer corruption
....................     unsigned int8 local_buffer[10]; 
....................     unsigned int8 adcs_status = 0;
....................     unsigned int32 last_adcs_address = 0;
....................     unsigned int32 first_adcs_data_address = 0;
.................... 
....................     output_high(ADCS_PWR);
04108:  BCF    F95.6
0410A:  BSF    F8C.6
....................     delay_ms(1000);
0410C:  MOVLW  04
0410E:  MOVWF  xDD
04110:  MOVLW  FA
04112:  MOVWF  xE5
04114:  MOVLB  0
04116:  CALL   1324
0411A:  MOVLB  1
0411C:  DECFSZ xDD,F
0411E:  BRA    4110
....................     
....................     READ_CHIP_ID_OF_ADCS(); // Verify hardware is awake
04120:  MOVLB  0
04122:  CALL   1CB0
.................... 
....................     // Clear previous command area
....................     fprintf(EXT, "Erasing ADCS command sector...\n");
04126:  MOVLW  2A
04128:  MOVWF  FF6
0412A:  MOVLW  01
0412C:  MOVWF  FF7
0412E:  MOVLW  00
04130:  MOVWF  FF8
04132:  CALL   1392
....................     SECTOR_ERASE_OF_ADCS(0x00000000);
04136:  MOVLB  1
04138:  CLRF   xE0
0413A:  CLRF   xDF
0413C:  CLRF   xDE
0413E:  CLRF   xDD
04140:  MOVLB  0
04142:  BRA    3E0E
....................     delay_ms(200);
04144:  MOVLW  C8
04146:  MOVLB  1
04148:  MOVWF  xE5
0414A:  MOVLB  0
0414C:  CALL   1324
.................... 
....................     // Write Quick Mission Command: {0x33, 0x05, 0x01}
....................     fprintf(EXT, "Sending command: 0x33 0x05 0x01\n");
04150:  MOVLW  4A
04152:  MOVWF  FF6
04154:  MOVLW  01
04156:  MOVWF  FF7
04158:  MOVLW  00
0415A:  MOVWF  FF8
0415C:  CALL   1392
....................     WRITE_DATA_NBYTES_ADCS(0x00000000, adcs_quick, 3);
04160:  MOVLB  1
04162:  CLRF   xE0
04164:  CLRF   xDF
04166:  CLRF   xDE
04168:  CLRF   xDD
0416A:  MOVLW  01
0416C:  MOVWF  xE2
0416E:  MOVLW  18
04170:  MOVWF  xE1
04172:  MOVLW  03
04174:  MOVWF  xE3
04176:  MOVLB  0
04178:  BRA    3EBA
....................     delay_ms(100);
0417A:  MOVLW  64
0417C:  MOVLB  1
0417E:  MOVWF  xE5
04180:  MOVLB  0
04182:  CALL   1324
.................... 
....................     // Verification Read
....................     read_data_adcs = READ_DATA_NBYTES_ADCS(0x00000000, 3);
04186:  MOVLB  1
04188:  CLRF   xE0
0418A:  CLRF   xDF
0418C:  CLRF   xDE
0418E:  CLRF   xDD
04190:  MOVLW  03
04192:  MOVWF  xE1
04194:  MOVLB  0
04196:  RCALL  4052
04198:  MOVFF  02,109
0419C:  MOVFF  01,108
....................     fprintf(EXT, "Verified Command: %02x %02x %02x\n", read_data_adcs[0], read_data_adcs[1], read_data_adcs[2]);
041A0:  MOVLB  1
041A2:  MOVFF  108,FE9
041A6:  MOVFF  109,FEA
041AA:  MOVFF  FEF,1DD
041AE:  MOVLW  01
041B0:  ADDWF  x08,W
041B2:  MOVWF  FE9
041B4:  MOVLW  00
041B6:  ADDWFC x09,W
041B8:  MOVWF  FEA
041BA:  MOVFF  FEF,1DE
041BE:  MOVLW  02
041C0:  ADDWF  x08,W
041C2:  MOVWF  FE9
041C4:  MOVLW  00
041C6:  ADDWFC x09,W
041C8:  MOVWF  FEA
041CA:  MOVFF  FEF,1DF
041CE:  MOVLW  6C
041D0:  MOVWF  FF6
041D2:  MOVLW  01
041D4:  MOVWF  FF7
041D6:  MOVLW  00
041D8:  MOVWF  FF8
041DA:  MOVLW  12
041DC:  MOVLB  2
041DE:  MOVWF  xFC
041E0:  MOVLB  0
041E2:  CALL   150A
041E6:  MOVFF  1DD,2FC
041EA:  MOVLW  57
041EC:  MOVLB  2
041EE:  MOVWF  xFD
041F0:  MOVLB  0
041F2:  CALL   17DC
041F6:  MOVLW  20
041F8:  MOVLB  3
041FA:  MOVWF  x02
041FC:  MOVLB  0
041FE:  CALL   134E
04202:  MOVFF  1DE,2FC
04206:  MOVLW  57
04208:  MOVLB  2
0420A:  MOVWF  xFD
0420C:  MOVLB  0
0420E:  CALL   17DC
04212:  MOVLW  20
04214:  MOVLB  3
04216:  MOVWF  x02
04218:  MOVLB  0
0421A:  CALL   134E
0421E:  MOVFF  1DF,2FC
04222:  MOVLW  57
04224:  MOVLB  2
04226:  MOVWF  xFD
04228:  MOVLB  0
0422A:  CALL   17DC
0422E:  MOVLW  0A
04230:  MOVLB  3
04232:  MOVWF  x02
04234:  MOVLB  0
04236:  CALL   134E
.................... 
....................     // Wait 210 seconds (ADCS is executing and writing measurements to Flash)
....................     for (int i = 0; i <= 21; i++) {
0423A:  MOVLB  1
0423C:  CLRF   xD5
0423E:  MOVF   xD5,W
04240:  SUBLW  15
04242:  BNC   42A6
....................         fprintf(EXT, "ADCS Busy: %ds / 210s\n", i * 10);
04244:  MOVF   xD5,W
04246:  MULLW  0A
04248:  MOVFF  FF3,1DD
0424C:  MOVLW  8E
0424E:  MOVWF  FF6
04250:  MOVLW  01
04252:  MOVWF  FF7
04254:  MOVLW  00
04256:  MOVWF  FF8
04258:  MOVLW  0B
0425A:  MOVLB  2
0425C:  MOVWF  xFC
0425E:  MOVLB  0
04260:  CALL   150A
04264:  MOVFF  1DD,2FC
04268:  MOVLW  18
0426A:  MOVLB  2
0426C:  MOVWF  xFD
0426E:  MOVLB  0
04270:  CALL   1840
04274:  MOVLW  9B
04276:  MOVWF  FF6
04278:  MOVLW  01
0427A:  MOVWF  FF7
0427C:  MOVLW  00
0427E:  MOVWF  FF8
04280:  MOVLW  09
04282:  MOVLB  2
04284:  MOVWF  xFC
04286:  MOVLB  0
04288:  CALL   150A
....................         delay_ms(10000);
0428C:  MOVLW  28
0428E:  MOVLB  1
04290:  MOVWF  xDD
04292:  MOVLW  FA
04294:  MOVWF  xE5
04296:  MOVLB  0
04298:  CALL   1324
0429C:  MOVLB  1
0429E:  DECFSZ xDD,F
042A0:  BRA    4292
042A2:  INCF   xD5,F
042A4:  BRA    423E
....................     }
.................... 
....................     // Read status (1 byte) and last address (4 bytes)
....................     fprintf(EXT, "Reading status from 0x00020000...\n");
042A6:  MOVLW  A6
042A8:  MOVWF  FF6
042AA:  MOVLW  01
042AC:  MOVWF  FF7
042AE:  MOVLW  00
042B0:  MOVWF  FF8
042B2:  MOVLB  0
042B4:  CALL   1392
....................     read_data_adcs = READ_DATA_NBYTES_ADCS(0x00020000, 5);
042B8:  MOVLB  1
042BA:  CLRF   xE0
042BC:  MOVLW  02
042BE:  MOVWF  xDF
042C0:  CLRF   xDE
042C2:  CLRF   xDD
042C4:  MOVLW  05
042C6:  MOVWF  xE1
042C8:  MOVLB  0
042CA:  RCALL  4052
042CC:  MOVFF  02,109
042D0:  MOVFF  01,108
....................     
....................     // Copy to local variables immediately to prevent pointer issues
....................     adcs_status = (unsigned int8)read_data_adcs[0];
042D4:  MOVLB  1
042D6:  MOVFF  108,FE9
042DA:  MOVFF  109,FEA
042DE:  MOVFF  FEF,1CC
....................     last_adcs_address = 0;
042E2:  CLRF   xD0
042E4:  CLRF   xCF
042E6:  CLRF   xCE
042E8:  CLRF   xCD
....................     for (int i = 1; i < 5; i++) {
042EA:  MOVLW  01
042EC:  MOVWF  xD6
042EE:  MOVF   xD6,W
042F0:  SUBLW  04
042F2:  BNC   4318
....................         last_adcs_address = (last_adcs_address << 8) | (unsigned int8)read_data_adcs[i];
042F4:  MOVFF  1CF,1D0
042F8:  MOVFF  1CE,1CF
042FC:  MOVFF  1CD,1CE
04300:  CLRF   xDE
04302:  MOVF   xD6,W
04304:  ADDWF  x08,W
04306:  MOVWF  FE9
04308:  MOVLW  00
0430A:  ADDWFC x09,W
0430C:  MOVWF  FEA
0430E:  MOVF   FEF,W
04310:  IORWF  xDE,W
04312:  MOVWF  xCD
04314:  INCF   xD6,F
04316:  BRA    42EE
....................     }
.................... 
....................     // CRITICAL CHECK: Validate data before looping
....................     // In Flash, 0xFF means "Nothing written" or "Hardware Error"
....................     if (adcs_status == 0x00 || adcs_status == 0xFF) {
04318:  MOVF   xCC,F
0431A:  BZ    4320
0431C:  INCFSZ xCC,W
0431E:  BRA    435C
....................         fprintf(EXT, "FAILED: ADCS returned invalid status: 0x%02X\n", adcs_status);
04320:  MOVLW  CA
04322:  MOVWF  FF6
04324:  MOVLW  01
04326:  MOVWF  FF7
04328:  MOVLW  00
0432A:  MOVWF  FF8
0432C:  MOVLW  28
0432E:  MOVLB  2
04330:  MOVWF  xFC
04332:  MOVLB  0
04334:  CALL   150A
04338:  MOVFF  1CC,2FC
0433C:  MOVLW  37
0433E:  MOVLB  2
04340:  MOVWF  xFD
04342:  MOVLB  0
04344:  CALL   17DC
04348:  MOVLW  0A
0434A:  MOVLB  3
0434C:  MOVWF  x02
0434E:  MOVLB  0
04350:  CALL   134E
....................         output_low(ADCS_PWR);
04354:  BCF    F95.6
04356:  BCF    F8C.6
....................         return; 
04358:  BRA    45D0
0435A:  MOVLB  1
....................     }
.................... 
....................     fprintf(EXT, "SUCCESS: %u measurements found. Last Addr: 0x%08lx\n", adcs_status, last_adcs_address);
0435C:  MOVLW  F8
0435E:  MOVWF  FF6
04360:  MOVLW  01
04362:  MOVWF  FF7
04364:  MOVLW  00
04366:  MOVWF  FF8
04368:  MOVLW  09
0436A:  MOVLB  2
0436C:  MOVWF  xFC
0436E:  MOVLB  0
04370:  CALL   150A
04374:  MOVFF  1CC,1DE
04378:  MOVLW  1B
0437A:  MOVLB  1
0437C:  MOVWF  xDF
0437E:  MOVLB  0
04380:  CALL   148E
04384:  MOVLW  03
04386:  MOVWF  FF6
04388:  MOVLW  02
0438A:  MOVWF  FF7
0438C:  MOVLW  00
0438E:  MOVWF  FF8
04390:  MOVLW  22
04392:  MOVLB  2
04394:  MOVWF  xFC
04396:  MOVLB  0
04398:  CALL   150A
0439C:  MOVFF  1D0,2FC
043A0:  MOVLW  57
043A2:  MOVLB  2
043A4:  MOVWF  xFD
043A6:  MOVLB  0
043A8:  CALL   17DC
043AC:  MOVFF  1CF,2FC
043B0:  MOVLW  57
043B2:  MOVLB  2
043B4:  MOVWF  xFD
043B6:  MOVLB  0
043B8:  CALL   17DC
043BC:  MOVFF  1CE,2FC
043C0:  MOVLW  57
043C2:  MOVLB  2
043C4:  MOVWF  xFD
043C6:  MOVLB  0
043C8:  CALL   17DC
043CC:  MOVFF  1CD,2FC
043D0:  MOVLW  57
043D2:  MOVLB  2
043D4:  MOVWF  xFD
043D6:  MOVLB  0
043D8:  CALL   17DC
043DC:  MOVLW  0A
043DE:  MOVLB  3
043E0:  MOVWF  x02
043E2:  MOVLB  0
043E4:  CALL   134E
.................... 
....................     // Calculate start address: Each measurement is 9 bytes
....................     first_adcs_data_address = last_adcs_address - ((unsigned int32)adcs_status * 9);
043E8:  MOVLB  1
043EA:  CLRF   xDF
043EC:  CLRF   xDE
043EE:  MOVLB  3
043F0:  CLRF   x00
043F2:  MOVLB  2
043F4:  CLRF   xFF
043F6:  MOVLB  2
043F8:  CLRF   xFE
043FA:  MOVLB  3
043FC:  MOVFF  1CC,2FD
04400:  CLRF   x04
04402:  CLRF   x03
04404:  CLRF   x02
04406:  MOVLW  09
04408:  MOVWF  x01
0440A:  MOVLB  0
0440C:  CALL   29FA
04410:  MOVF   00,W
04412:  MOVLB  1
04414:  SUBWF  xCD,W
04416:  MOVWF  xD1
04418:  MOVF   01,W
0441A:  SUBWFB xCE,W
0441C:  MOVWF  xD2
0441E:  MOVF   02,W
04420:  SUBWFB xCF,W
04422:  MOVWF  xD3
04424:  MOVF   03,W
04426:  SUBWFB xD0,W
04428:  MOVWF  xD4
....................     fprintf(EXT, "Data Start: 0x%08lx\n", first_adcs_data_address);
0442A:  MOVLW  2C
0442C:  MOVWF  FF6
0442E:  MOVLW  02
04430:  MOVWF  FF7
04432:  MOVLW  00
04434:  MOVWF  FF8
04436:  MOVLW  0E
04438:  MOVLB  2
0443A:  MOVWF  xFC
0443C:  MOVLB  0
0443E:  CALL   150A
04442:  MOVFF  1D4,2FC
04446:  MOVLW  57
04448:  MOVLB  2
0444A:  MOVWF  xFD
0444C:  MOVLB  0
0444E:  CALL   17DC
04452:  MOVFF  1D3,2FC
04456:  MOVLW  57
04458:  MOVLB  2
0445A:  MOVWF  xFD
0445C:  MOVLB  0
0445E:  CALL   17DC
04462:  MOVFF  1D2,2FC
04466:  MOVLW  57
04468:  MOVLB  2
0446A:  MOVWF  xFD
0446C:  MOVLB  0
0446E:  CALL   17DC
04472:  MOVFF  1D1,2FC
04476:  MOVLW  57
04478:  MOVLB  2
0447A:  MOVWF  xFD
0447C:  MOVLB  0
0447E:  CALL   17DC
04482:  MOVLW  0A
04484:  MOVLB  3
04486:  MOVWF  x02
04488:  MOVLB  0
0448A:  CALL   134E
.................... 
....................     // Read and print each measurement block
....................     for (unsigned int8 i = 0; i < adcs_status; i++) {
0448E:  MOVLB  1
04490:  CLRF   xD7
04492:  MOVF   xCC,W
04494:  SUBWF  xD7,W
04496:  BTFSC  FD8.0
04498:  BRA    45CC
....................         unsigned int32 current_address = first_adcs_data_address + (i * 9);
0449A:  MOVF   xD7,W
0449C:  MULLW  09
0449E:  MOVF   FF3,W
044A0:  ADDWF  xD1,W
044A2:  MOVWF  xD8
044A4:  MOVLW  00
044A6:  ADDWFC xD2,W
044A8:  MOVWF  xD9
044AA:  MOVLW  00
044AC:  ADDWFC xD3,W
044AE:  MOVWF  xDA
044B0:  MOVLW  00
044B2:  ADDWFC xD4,W
044B4:  MOVWF  xDB
....................         
....................         // Read 9 bytes of sensor data
....................         read_data_adcs = READ_DATA_NBYTES_ADCS(current_address, 9);
044B6:  MOVFF  1DB,1E0
044BA:  MOVFF  1DA,1DF
044BE:  MOVFF  1D9,1DE
044C2:  MOVFF  1D8,1DD
044C6:  MOVLW  09
044C8:  MOVWF  xE1
044CA:  MOVLB  0
044CC:  RCALL  4052
044CE:  MOVFF  02,109
044D2:  MOVFF  01,108
....................         
....................         fprintf(EXT, "Data [%u] @ 0x%08lx: ", i + 1, current_address);
044D6:  MOVLW  01
044D8:  MOVLB  1
044DA:  ADDWF  xD7,W
044DC:  MOVWF  xDD
044DE:  MOVLW  42
044E0:  MOVWF  FF6
044E2:  MOVLW  02
044E4:  MOVWF  FF7
044E6:  MOVLW  00
044E8:  MOVWF  FF8
044EA:  MOVLW  06
044EC:  MOVLB  2
044EE:  MOVWF  xFC
044F0:  MOVLB  0
044F2:  CALL   150A
044F6:  MOVFF  1DD,1DE
044FA:  MOVLW  1B
044FC:  MOVLB  1
044FE:  MOVWF  xDF
04500:  MOVLB  0
04502:  CALL   148E
04506:  MOVLW  4A
04508:  MOVWF  FF6
0450A:  MOVLW  02
0450C:  MOVWF  FF7
0450E:  MOVLW  00
04510:  MOVWF  FF8
04512:  MOVLW  06
04514:  MOVLB  2
04516:  MOVWF  xFC
04518:  MOVLB  0
0451A:  CALL   150A
0451E:  MOVFF  1DB,2FC
04522:  MOVLW  57
04524:  MOVLB  2
04526:  MOVWF  xFD
04528:  MOVLB  0
0452A:  CALL   17DC
0452E:  MOVFF  1DA,2FC
04532:  MOVLW  57
04534:  MOVLB  2
04536:  MOVWF  xFD
04538:  MOVLB  0
0453A:  CALL   17DC
0453E:  MOVFF  1D9,2FC
04542:  MOVLW  57
04544:  MOVLB  2
04546:  MOVWF  xFD
04548:  MOVLB  0
0454A:  CALL   17DC
0454E:  MOVFF  1D8,2FC
04552:  MOVLW  57
04554:  MOVLB  2
04556:  MOVWF  xFD
04558:  MOVLB  0
0455A:  CALL   17DC
0455E:  MOVLW  3A
04560:  MOVLB  3
04562:  MOVWF  x02
04564:  MOVLB  0
04566:  CALL   134E
0456A:  MOVLW  20
0456C:  MOVLB  3
0456E:  MOVWF  x02
04570:  MOVLB  0
04572:  CALL   134E
....................         for (int j = 0; j < 9; j++) {
04576:  MOVLB  1
04578:  CLRF   xDC
0457A:  MOVF   xDC,W
0457C:  SUBLW  08
0457E:  BNC   45AE
....................             fprintf(EXT, "%02x ", (unsigned int8)read_data_adcs[j]);
04580:  MOVF   xDC,W
04582:  ADDWF  x08,W
04584:  MOVWF  FE9
04586:  MOVLW  00
04588:  ADDWFC x09,W
0458A:  MOVWF  FEA
0458C:  MOVFF  FEF,2FC
04590:  MOVLW  57
04592:  MOVLB  2
04594:  MOVWF  xFD
04596:  MOVLB  0
04598:  CALL   17DC
0459C:  MOVLW  20
0459E:  MOVLB  3
045A0:  MOVWF  x02
045A2:  MOVLB  0
045A4:  CALL   134E
045A8:  MOVLB  1
045AA:  INCF   xDC,F
045AC:  BRA    457A
....................         }
....................         fprintf(EXT, "\n");
045AE:  MOVLW  0A
045B0:  MOVLB  3
045B2:  MOVWF  x02
045B4:  MOVLB  0
045B6:  CALL   134E
....................         delay_ms(5); 
045BA:  MOVLW  05
045BC:  MOVLB  1
045BE:  MOVWF  xE5
045C0:  MOVLB  0
045C2:  CALL   1324
045C6:  MOVLB  1
045C8:  INCF   xD7,F
045CA:  BRA    4492
....................     }
.................... 
....................     output_low(ADCS_PWR); // Mission complete, save power
045CC:  BCF    F95.6
045CE:  BCF    F8C.6
045D0:  MOVLB  0
045D2:  GOTO   4662 (RETURN)
.................... }
.................... 
.................... void adcs_mission_mode_dumm(void) {
....................     // 1. Local storage to prevent pointer corruption
....................     unsigned int8 local_buffer[10]; 
....................     unsigned int8 adcs_status = 0;
....................     unsigned int32 last_adcs_address = 0;
....................     unsigned int32 first_adcs_data_address = 0;
....................     output_high(EN_SUP_3V3_DAQ); // Enable 3.3V supply for DAQ
....................     output_high(ADCS_PWR);
....................     delay_ms(1000);
....................     
....................     READ_CHIP_ID_OF_ADCS(); // Verify hardware is awake
.................... 
....................     // // Clear previous command area
....................     // fprintf(EXT, "Erasing ADCS command sector...\n");
....................     // SECTOR_ERASE_OF_ADCS(0x00000000);
....................     // delay_ms(200);
.................... 
....................     // // Write Quick Mission Command: {0x33, 0x05, 0x01}
....................     // fprintf(EXT, "Sending command: 0x33 0x05 0x01\n");
....................     // WRITE_DATA_NBYTES_ADCS(0x00000000, adcs_quick, 3);
....................     // delay_ms(100);
.................... 
....................     // // Verification Read
....................     // read_data_adcs = READ_DATA_NBYTES_ADCS(0x00000000, 3);
....................     // fprintf(EXT, "Verified Command: %02x %02x %02x\n", read_data_adcs[0], read_data_adcs[1], read_data_adcs[2]);
.................... 
....................     // // Wait 210 seconds (ADCS is executing and writing measurements to Flash)
....................     // for (int i = 0; i <= 21; i++) {
....................     //     fprintf(EXT, "ADCS Busy: %ds / 210s\n", i * 10);
....................     //     delay_ms(10000);
....................     // }
.................... 
....................     // Read status (1 byte) and last address (4 bytes)
....................     fprintf(EXT, "Reading status from 0x00020000...\n");
....................     read_data_adcs = READ_DATA_NBYTES_ADCS(0x00020000, 5);
....................     
....................     // Copy to local variables immediately to prevent pointer issues
....................     adcs_status = (unsigned int8)read_data_adcs[0];
....................     last_adcs_address = 0;
....................     for (int i = 1; i < 5; i++) {
....................         last_adcs_address = (last_adcs_address << 8) | (unsigned int8)read_data_adcs[i];
....................     }
.................... 
....................     // CRITICAL CHECK: Validate data before looping
....................     // In Flash, 0xFF means "Nothing written" or "Hardware Error"
....................     if (adcs_status == 0x00 || adcs_status == 0xFF) {
....................         fprintf(EXT, "FAILED: ADCS returned invalid status: 0x%02X\n", adcs_status);
....................         output_low(ADCS_PWR);
....................         return; 
....................     }
.................... 
....................     fprintf(EXT, "SUCCESS: %u measurements found. Last Addr: 0x%08lx\n", adcs_status, last_adcs_address);
.................... 
....................     // Calculate start address: Each measurement is 19 bytes
....................     first_adcs_data_address = last_adcs_address - ((unsigned int32)adcs_status * 19);
....................     fprintf(EXT, "Data Start: 0x%08lx\n", first_adcs_data_address);
.................... 
....................     // Read and print each measurement block
....................     for (unsigned int8 i = 0; i < adcs_status; i++) {
....................         unsigned int32 current_address = first_adcs_data_address + (i * 19);
....................         
....................         // Read 19 bytes of sensor data
....................         read_data_adcs = READ_DATA_NBYTES_ADCS(current_address, 19);
....................         
....................         // fprintf(EXT, "Data [%u] @ 0x%08lx: ", i + 1, current_address);
....................         for (int j = 0; j < 19; j++) {
....................             fprintf(EXT, "%02x ", (unsigned int8)read_data_adcs[j]);
....................         }
....................         fprintf(EXT, "\n");
....................         delay_ms(5); 
....................     }
.................... 
....................     output_low(ADCS_PWR); 
....................     output_low(EN_SUP_3V3_DAQ); // Enable 3.3V supply for DAQ
.................... }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // eps functions 
.................... char cmd = 'g'; // Command character to trigger EPS
.................... unsigned int8 eps_buffer[33];
.................... unsigned int8 temperature[7];
.................... unsigned int8 solar_panel_current[5];
.................... unsigned int8 solar_panel_voltage[5];
.................... unsigned int8 sc_pwr;
.................... unsigned int8 sc_i_sens;
.................... unsigned int8 batt_i_sens;
.................... unsigned int8 batt_pwr;
.................... unsigned int8 raw_i_sens;
.................... unsigned int8 raw_v_sens;
.................... unsigned int8 batt_temp;
.................... unsigned int8 DCDC_output_i[5];
.................... bool KS_OBC_STAT;
.................... bool KS_EPS_STAT;
.................... 
.................... // Function to receive 33 bytes from EPS into the buffer
.................... void get_data(unsigned int8* buffer) {
*
03756:  MOVLB  1
03758:  CLRF   xE7
0375A:  CLRF   xE6
0375C:  CLRF   xE8
....................     unsigned int16 timeout = 0;
....................     unsigned int8 start_byte = 0;
.................... 
....................     putc('g', EPS); // Send trigger command
0375E:  MOVLW  67
03760:  MOVWF  xEA
03762:  MOVLB  0
03764:  BRA    36C4
.................... 
....................     // 1. SYNC STEP: Look for the start byte '}' (0x7D)
....................     // This ignores all the <1> or trash bytes sent before the packet
....................     while(start_byte != 0x7D && timeout < 5000) {
03766:  MOVLB  1
03768:  MOVF   xE8,W
0376A:  SUBLW  7D
0376C:  BZ    379A
0376E:  MOVF   xE7,W
03770:  SUBLW  13
03772:  BNC   379A
03774:  BNZ   377C
03776:  MOVF   xE6,W
03778:  SUBLW  87
0377A:  BNC   379A
....................         if(kbhit(EPS)) {
0377C:  BTFSC  F84.4
0377E:  BRA    378A
....................             start_byte = fgetc(EPS);
03780:  MOVLB  0
03782:  RCALL  370C
03784:  MOVFF  01,1E8
03788:  MOVLB  1
....................         }
....................         delay_us(10);
0378A:  MOVLW  0D
0378C:  MOVWF  00
0378E:  DECFSZ 00,F
03790:  BRA    378E
....................         timeout++;
03792:  INCF   xE6,F
03794:  BTFSC  FD8.2
03796:  INCF   xE7,F
03798:  BRA    3768
....................     }
.................... 
....................     if (start_byte != 0x7D) {
0379A:  MOVF   xE8,W
0379C:  SUBLW  7D
0379E:  BZ    37B6
....................         fprintf(EXT, "Timeout: EPS Header not found!\n");
037A0:  MOVLW  F4
037A2:  MOVWF  FF6
037A4:  MOVLW  02
037A6:  MOVWF  FF7
037A8:  MOVLW  00
037AA:  MOVWF  FF8
037AC:  MOVLB  0
037AE:  CALL   1392
....................         return;
037B2:  BRA    37F6
037B4:  MOVLB  1
....................     }
.................... 
....................     // 2. FILL STEP: Now that we found 0x7D, fill the rest of the 33 bytes
....................     buffer[0] = start_byte; 
037B6:  MOVFF  1E4,FE9
037BA:  MOVFF  1E5,FEA
037BE:  MOVFF  1E8,FEF
....................     for (int8 i = 1; i < 33; i++) {
037C2:  MOVLW  01
037C4:  MOVWF  xE9
037C6:  MOVF   xE9,W
037C8:  SUBLW  20
037CA:  BNC   37F6
....................         buffer[i] = fgetc(EPS); 
037CC:  MOVF   xE9,W
037CE:  ADDWF  xE4,W
037D0:  MOVWF  FE9
037D2:  MOVLW  00
037D4:  ADDWFC xE5,W
037D6:  MOVWF  FEA
037D8:  MOVFF  FEA,1ED
037DC:  MOVFF  FE9,1EC
037E0:  MOVLB  0
037E2:  RCALL  370C
037E4:  MOVFF  1ED,FEA
037E8:  MOVFF  1EC,FE9
037EC:  MOVFF  01,FEF
037F0:  MOVLB  1
037F2:  INCF   xE9,F
037F4:  BRA    37C6
037F6:  MOVLB  0
....................     }
037F8:  GOTO   3D92 (RETURN)
.................... }
.................... 
.................... // Function to send 33 bytes to EXT
.................... void send_data(char* buffer) {
....................     for (int8 i = 0; i < 33; i++) {
....................         putc(buffer[i], EXT); // Send each byte to EXT
....................     }
....................     printf(EXT, "\n"); // Newline after sending all bytes
.................... }
.................... 
.................... /// Update store_eps_data for accuracy
.................... void store_eps_data(unsigned int8* buffer) {
....................     // Check start '}' and end 'f' frames for data integrity
....................     if (buffer[0] == '}' && buffer[32] == 'f') {
037FC:  MOVLB  1
037FE:  MOVFF  1E4,FE9
03802:  MOVFF  1E5,FEA
03806:  MOVF   FEF,W
03808:  SUBLW  7D
0380A:  BTFSS  FD8.2
0380C:  BRA    3974
0380E:  MOVLW  20
03810:  ADDWF  xE4,W
03812:  MOVWF  FE9
03814:  MOVLW  00
03816:  ADDWFC xE5,W
03818:  MOVWF  FEA
0381A:  MOVF   FEF,W
0381C:  SUBLW  66
0381E:  BTFSS  FD8.2
03820:  BRA    3974
....................         memcpy(temperature, &buffer[1], 7);
03822:  MOVLW  01
03824:  ADDWF  xE4,W
03826:  MOVWF  01
03828:  MOVLW  00
0382A:  ADDWFC xE5,W
0382C:  MOVWF  03
0382E:  MOVFF  01,1E6
03832:  MOVWF  xE7
03834:  MOVLW  01
03836:  MOVWF  FEA
03838:  MOVLW  3F
0383A:  MOVWF  FE9
0383C:  MOVFF  03,FE2
03840:  MOVFF  01,FE1
03844:  MOVLW  07
03846:  MOVWF  01
03848:  MOVFF  FE6,FEE
0384C:  DECFSZ 01,F
0384E:  BRA    3848
....................         memcpy(solar_panel_current, &buffer[8], 5);
03850:  MOVLW  08
03852:  ADDWF  xE4,W
03854:  MOVWF  01
03856:  MOVLW  00
03858:  ADDWFC xE5,W
0385A:  MOVWF  03
0385C:  MOVFF  01,1E6
03860:  MOVWF  xE7
03862:  MOVLW  01
03864:  MOVWF  FEA
03866:  MOVLW  46
03868:  MOVWF  FE9
0386A:  MOVFF  03,FE2
0386E:  MOVFF  01,FE1
03872:  MOVLW  05
03874:  MOVWF  01
03876:  MOVFF  FE6,FEE
0387A:  DECFSZ 01,F
0387C:  BRA    3876
....................         memcpy(solar_panel_voltage, &buffer[13], 5);
0387E:  MOVLW  0D
03880:  ADDWF  xE4,W
03882:  MOVWF  01
03884:  MOVLW  00
03886:  ADDWFC xE5,W
03888:  MOVWF  03
0388A:  MOVFF  01,1E6
0388E:  MOVWF  xE7
03890:  MOVLW  01
03892:  MOVWF  FEA
03894:  MOVLW  4B
03896:  MOVWF  FE9
03898:  MOVFF  03,FE2
0389C:  MOVFF  01,FE1
038A0:  MOVLW  05
038A2:  MOVWF  01
038A4:  MOVFF  FE6,FEE
038A8:  DECFSZ 01,F
038AA:  BRA    38A4
....................         sc_pwr    = buffer[18];
038AC:  MOVLW  12
038AE:  ADDWF  xE4,W
038B0:  MOVWF  FE9
038B2:  MOVLW  00
038B4:  ADDWFC xE5,W
038B6:  MOVWF  FEA
038B8:  MOVFF  FEF,150
....................         sc_i_sens = buffer[19];
038BC:  MOVLW  13
038BE:  ADDWF  xE4,W
038C0:  MOVWF  FE9
038C2:  MOVLW  00
038C4:  ADDWFC xE5,W
038C6:  MOVWF  FEA
038C8:  MOVFF  FEF,151
....................         batt_i_sens = buffer[20];
038CC:  MOVLW  14
038CE:  ADDWF  xE4,W
038D0:  MOVWF  FE9
038D2:  MOVLW  00
038D4:  ADDWFC xE5,W
038D6:  MOVWF  FEA
038D8:  MOVFF  FEF,152
....................         batt_pwr  = buffer[21];
038DC:  MOVLW  15
038DE:  ADDWF  xE4,W
038E0:  MOVWF  FE9
038E2:  MOVLW  00
038E4:  ADDWFC xE5,W
038E6:  MOVWF  FEA
038E8:  MOVFF  FEF,153
....................         raw_i_sens = buffer[22];
038EC:  MOVLW  16
038EE:  ADDWF  xE4,W
038F0:  MOVWF  FE9
038F2:  MOVLW  00
038F4:  ADDWFC xE5,W
038F6:  MOVWF  FEA
038F8:  MOVFF  FEF,154
....................         raw_v_sens = buffer[23];
038FC:  MOVLW  17
038FE:  ADDWF  xE4,W
03900:  MOVWF  FE9
03902:  MOVLW  00
03904:  ADDWFC xE5,W
03906:  MOVWF  FEA
03908:  MOVFF  FEF,155
....................         batt_temp = buffer[24];
0390C:  MOVLW  18
0390E:  ADDWF  xE4,W
03910:  MOVWF  FE9
03912:  MOVLW  00
03914:  ADDWFC xE5,W
03916:  MOVWF  FEA
03918:  MOVFF  FEF,156
....................         memcpy(DCDC_output_i, &buffer[25], 5);
0391C:  MOVLW  19
0391E:  ADDWF  xE4,W
03920:  MOVWF  01
03922:  MOVLW  00
03924:  ADDWFC xE5,W
03926:  MOVWF  03
03928:  MOVFF  01,1E6
0392C:  MOVWF  xE7
0392E:  MOVLW  01
03930:  MOVWF  FEA
03932:  MOVLW  57
03934:  MOVWF  FE9
03936:  MOVFF  03,FE2
0393A:  MOVFF  01,FE1
0393E:  MOVLW  05
03940:  MOVWF  01
03942:  MOVFF  FE6,FEE
03946:  DECFSZ 01,F
03948:  BRA    3942
....................         KS_OBC_STAT = (buffer[30] != 0);
0394A:  BCF    x5C.0
0394C:  MOVLW  1E
0394E:  ADDWF  xE4,W
03950:  MOVWF  FE9
03952:  MOVLW  00
03954:  ADDWFC xE5,W
03956:  MOVWF  FEA
03958:  MOVF   FEF,F
0395A:  BZ    395E
0395C:  BSF    x5C.0
....................         KS_EPS_STAT = (buffer[31] != 0);
0395E:  BCF    x5C.1
03960:  MOVLW  1F
03962:  ADDWF  xE4,W
03964:  MOVWF  FE9
03966:  MOVLW  00
03968:  ADDWFC xE5,W
0396A:  MOVWF  FEA
0396C:  MOVF   FEF,F
0396E:  BZ    3972
03970:  BSF    x5C.1
....................     } else {
03972:  BRA    399C
....................         printf(EXT, "CRC/Framing Error! Start: %c, End: %c\n", buffer[0], buffer[32]);
03974:  MOVFF  1E4,FE9
03978:  MOVFF  1E5,FEA
0397C:  MOVFF  FEF,1E6
03980:  MOVLW  20
03982:  ADDWF  xE4,W
03984:  MOVWF  FE9
03986:  MOVLW  00
03988:  ADDWFC xE5,W
0398A:  MOVWF  FEA
0398C:  MOVFF  FEF,1E7
03990:  CLRF   FEA
03992:  MOVLW  02
03994:  MOVWF  FE9
03996:  MOVLB  0
03998:  RCALL  369E
0399A:  MOVLB  1
....................     }
0399C:  MOVLB  0
0399E:  GOTO   3DA0 (RETURN)
.................... }
.................... 
.................... void print_table() {
....................     // Use a constant for the ADC conversion to ensure float precision
....................     // Equation: (Value * Vref) / Res / Gain
....................     const float conv_factor = 3.3 / 256.0 / 20.0;
.................... 
....................     printf(EXT, "\n%-15s | %-8s | %-12s\n", "Variable", "Raw", "Value (V/A)");
*
03ACE:  CLRF   FEA
03AD0:  MOVLW  02
03AD2:  MOVWF  FE9
03AD4:  RCALL  369E
....................     printf(EXT, "--------------------------------------------------\n");
03AD6:  CLRF   FEA
03AD8:  MOVLW  02
03ADA:  MOVWF  FE9
03ADC:  RCALL  369E
....................     
....................     // Using (float) cast ensures the compiler uses floating point math
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_pwr", sc_pwr, (float)sc_pwr * conv_factor);
03ADE:  MOVLB  1
03AE0:  CLRF   xE5
03AE2:  MOVFF  150,1E4
03AE6:  MOVLB  0
03AE8:  RCALL  39A2
03AEA:  MOVFF  03,1E7
03AEE:  MOVFF  02,1E6
03AF2:  MOVFF  01,1E5
03AF6:  MOVFF  00,1E4
03AFA:  MOVFF  03,1EB
03AFE:  MOVFF  02,1EA
03B02:  MOVFF  01,1E9
03B06:  MOVFF  00,1E8
03B0A:  MOVLW  C2
03B0C:  MOVLB  1
03B0E:  MOVWF  xEF
03B10:  MOVLW  F5
03B12:  MOVWF  xEE
03B14:  MOVLW  28
03B16:  MOVWF  xED
03B18:  MOVLW  74
03B1A:  MOVWF  xEC
03B1C:  MOVLB  0
03B1E:  RCALL  39D8
03B20:  MOVFF  03,1E7
03B24:  MOVFF  02,1E6
03B28:  MOVFF  01,1E5
03B2C:  MOVFF  00,1E4
03B30:  CLRF   FEA
03B32:  MOVLW  02
03B34:  MOVWF  FE9
03B36:  RCALL  369E
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_i_sens", sc_i_sens, (float)sc_i_sens * conv_factor);
03B38:  MOVLB  1
03B3A:  CLRF   xE5
03B3C:  MOVFF  151,1E4
03B40:  MOVLB  0
03B42:  RCALL  39A2
03B44:  MOVFF  03,1E7
03B48:  MOVFF  02,1E6
03B4C:  MOVFF  01,1E5
03B50:  MOVFF  00,1E4
03B54:  MOVFF  03,1EB
03B58:  MOVFF  02,1EA
03B5C:  MOVFF  01,1E9
03B60:  MOVFF  00,1E8
03B64:  MOVLW  C2
03B66:  MOVLB  1
03B68:  MOVWF  xEF
03B6A:  MOVLW  F5
03B6C:  MOVWF  xEE
03B6E:  MOVLW  28
03B70:  MOVWF  xED
03B72:  MOVLW  74
03B74:  MOVWF  xEC
03B76:  MOVLB  0
03B78:  RCALL  39D8
03B7A:  MOVFF  03,1E7
03B7E:  MOVFF  02,1E6
03B82:  MOVFF  01,1E5
03B86:  MOVFF  00,1E4
03B8A:  CLRF   FEA
03B8C:  MOVLW  02
03B8E:  MOVWF  FE9
03B90:  RCALL  369E
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_i_sens", raw_i_sens, (float)raw_i_sens * conv_factor);
03B92:  MOVLB  1
03B94:  CLRF   xE5
03B96:  MOVFF  154,1E4
03B9A:  MOVLB  0
03B9C:  RCALL  39A2
03B9E:  MOVFF  03,1E7
03BA2:  MOVFF  02,1E6
03BA6:  MOVFF  01,1E5
03BAA:  MOVFF  00,1E4
03BAE:  MOVFF  03,1EB
03BB2:  MOVFF  02,1EA
03BB6:  MOVFF  01,1E9
03BBA:  MOVFF  00,1E8
03BBE:  MOVLW  C2
03BC0:  MOVLB  1
03BC2:  MOVWF  xEF
03BC4:  MOVLW  F5
03BC6:  MOVWF  xEE
03BC8:  MOVLW  28
03BCA:  MOVWF  xED
03BCC:  MOVLW  74
03BCE:  MOVWF  xEC
03BD0:  MOVLB  0
03BD2:  RCALL  39D8
03BD4:  MOVFF  03,1E7
03BD8:  MOVFF  02,1E6
03BDC:  MOVFF  01,1E5
03BE0:  MOVFF  00,1E4
03BE4:  CLRF   FEA
03BE6:  MOVLW  02
03BE8:  MOVWF  FE9
03BEA:  RCALL  369E
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_v_sens", raw_v_sens, (float)raw_v_sens * conv_factor);
03BEC:  MOVLB  1
03BEE:  CLRF   xE5
03BF0:  MOVFF  155,1E4
03BF4:  MOVLB  0
03BF6:  RCALL  39A2
03BF8:  MOVFF  03,1E7
03BFC:  MOVFF  02,1E6
03C00:  MOVFF  01,1E5
03C04:  MOVFF  00,1E4
03C08:  MOVFF  03,1EB
03C0C:  MOVFF  02,1EA
03C10:  MOVFF  01,1E9
03C14:  MOVFF  00,1E8
03C18:  MOVLW  C2
03C1A:  MOVLB  1
03C1C:  MOVWF  xEF
03C1E:  MOVLW  F5
03C20:  MOVWF  xEE
03C22:  MOVLW  28
03C24:  MOVWF  xED
03C26:  MOVLW  74
03C28:  MOVWF  xEC
03C2A:  MOVLB  0
03C2C:  RCALL  39D8
03C2E:  MOVFF  03,1E7
03C32:  MOVFF  02,1E6
03C36:  MOVFF  01,1E5
03C3A:  MOVFF  00,1E4
03C3E:  CLRF   FEA
03C40:  MOVLW  02
03C42:  MOVWF  FE9
03C44:  RCALL  369E
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_pwr", batt_pwr, (float)batt_pwr * conv_factor);
03C46:  MOVLB  1
03C48:  CLRF   xE5
03C4A:  MOVFF  153,1E4
03C4E:  MOVLB  0
03C50:  RCALL  39A2
03C52:  MOVFF  03,1E7
03C56:  MOVFF  02,1E6
03C5A:  MOVFF  01,1E5
03C5E:  MOVFF  00,1E4
03C62:  MOVFF  03,1EB
03C66:  MOVFF  02,1EA
03C6A:  MOVFF  01,1E9
03C6E:  MOVFF  00,1E8
03C72:  MOVLW  C2
03C74:  MOVLB  1
03C76:  MOVWF  xEF
03C78:  MOVLW  F5
03C7A:  MOVWF  xEE
03C7C:  MOVLW  28
03C7E:  MOVWF  xED
03C80:  MOVLW  74
03C82:  MOVWF  xEC
03C84:  MOVLB  0
03C86:  RCALL  39D8
03C88:  MOVFF  03,1E7
03C8C:  MOVFF  02,1E6
03C90:  MOVFF  01,1E5
03C94:  MOVFF  00,1E4
03C98:  CLRF   FEA
03C9A:  MOVLW  02
03C9C:  MOVWF  FE9
03C9E:  RCALL  369E
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_i_sens", batt_i_sens, (float)batt_i_sens * conv_factor);
03CA0:  MOVLB  1
03CA2:  CLRF   xE5
03CA4:  MOVFF  152,1E4
03CA8:  MOVLB  0
03CAA:  RCALL  39A2
03CAC:  MOVFF  03,1E7
03CB0:  MOVFF  02,1E6
03CB4:  MOVFF  01,1E5
03CB8:  MOVFF  00,1E4
03CBC:  MOVFF  03,1EB
03CC0:  MOVFF  02,1EA
03CC4:  MOVFF  01,1E9
03CC8:  MOVFF  00,1E8
03CCC:  MOVLW  C2
03CCE:  MOVLB  1
03CD0:  MOVWF  xEF
03CD2:  MOVLW  F5
03CD4:  MOVWF  xEE
03CD6:  MOVLW  28
03CD8:  MOVWF  xED
03CDA:  MOVLW  74
03CDC:  MOVWF  xEC
03CDE:  MOVLB  0
03CE0:  RCALL  39D8
03CE2:  MOVFF  03,1E7
03CE6:  MOVFF  02,1E6
03CEA:  MOVFF  01,1E5
03CEE:  MOVFF  00,1E4
03CF2:  CLRF   FEA
03CF4:  MOVLW  02
03CF6:  MOVWF  FE9
03CF8:  RCALL  369E
....................     
....................     printf(EXT, "OBC Status: %s | EPS Status: %s\n", 
....................            KS_OBC_STAT ? "ON" : "OFF", 
....................            KS_EPS_STAT ? "ON" : "OFF");
03CFA:  MOVLB  1
03CFC:  BTFSS  x5C.0
03CFE:  BRA    3D10
03D00:  MOVLW  00
03D02:  MOVWF  02
03D04:  MOVLW  03
03D06:  MOVWF  01
03D08:  MOVLW  14
03D0A:  MOVWF  00
03D0C:  CLRF   03
03D0E:  BRA    3D1E
03D10:  MOVLW  00
03D12:  MOVWF  02
03D14:  MOVLW  03
03D16:  MOVWF  01
03D18:  MOVLW  18
03D1A:  MOVWF  00
03D1C:  CLRF   03
03D1E:  MOVFF  03,1E7
03D22:  MOVFF  02,1E6
03D26:  MOVFF  01,1E5
03D2A:  MOVFF  00,1E4
03D2E:  BTFSS  x5C.1
03D30:  BRA    3D44
03D32:  MOVLW  00
03D34:  MOVWF  02
03D36:  MOVLW  03
03D38:  MOVWF  01
03D3A:  MOVLW  1C
03D3C:  MOVWF  00
03D3E:  CLRF   03
03D40:  MOVF   00,W
03D42:  BRA    3D54
03D44:  MOVLW  00
03D46:  MOVWF  02
03D48:  MOVLW  03
03D4A:  MOVWF  01
03D4C:  MOVLW  20
03D4E:  MOVWF  00
03D50:  CLRF   03
03D52:  MOVF   00,W
03D54:  MOVWF  xE8
03D56:  CLRF   FEA
03D58:  MOVLW  02
03D5A:  MOVWF  FE9
03D5C:  MOVLB  0
03D5E:  RCALL  369E
03D60:  GOTO   3DA2 (RETURN)
.................... }
.................... 
.................... void eps_mission_mode(void) {
....................     printf(EXT, "--- EPS MISSION STARTs ---\n");
03D64:  CLRF   FEA
03D66:  MOVLW  02
03D68:  MOVWF  FE9
03D6A:  RCALL  369E
....................     unsigned int8 eps_buffer[33];
....................     printf(EXT, "--- EPS MISSION START ---\n");
03D6C:  CLRF   FEA
03D6E:  MOVLW  02
03D70:  MOVWF  FE9
03D72:  RCALL  369E
....................     output_high(EN_SUP_3V3_DAQ); 
03D74:  BCF    F95.0
03D76:  BSF    F8C.0
....................     delay_ms(10); // Give DAQ time to stabilize
03D78:  MOVLW  0A
03D7A:  MOVLB  1
03D7C:  MOVWF  xE5
03D7E:  MOVLB  0
03D80:  CALL   1324
.................... 
....................     get_data(eps_buffer);      // Get 33 bytes
03D84:  MOVLW  01
03D86:  MOVLB  1
03D88:  MOVWF  xE5
03D8A:  MOVLW  C2
03D8C:  MOVWF  xE4
03D8E:  MOVLB  0
03D90:  BRA    3756
....................     store_eps_data(eps_buffer); // Parse
03D92:  MOVLW  01
03D94:  MOVLB  1
03D96:  MOVWF  xE5
03D98:  MOVLW  C2
03D9A:  MOVWF  xE4
03D9C:  MOVLB  0
03D9E:  BRA    37FC
....................     print_table();             // Display
03DA0:  BRA    3ACE
....................     
....................     // Correct way to forward the raw buffer for debugging
....................     for(int i=0; i<33; i++) {
03DA2:  MOVLB  1
03DA4:  CLRF   xE3
03DA6:  MOVF   xE3,W
03DA8:  SUBLW  20
03DAA:  BNC   3DDC
....................         fprintf(EXT, "%02x ", eps_buffer[i]);
03DAC:  CLRF   03
03DAE:  MOVF   xE3,W
03DB0:  ADDLW  C2
03DB2:  MOVWF  FE9
03DB4:  MOVLW  01
03DB6:  ADDWFC 03,W
03DB8:  MOVWF  FEA
03DBA:  MOVFF  FEF,2FC
03DBE:  MOVLW  57
03DC0:  MOVLB  2
03DC2:  MOVWF  xFD
03DC4:  MOVLB  0
03DC6:  CALL   17DC
03DCA:  MOVLW  20
03DCC:  MOVLB  3
03DCE:  MOVWF  x02
03DD0:  MOVLB  0
03DD2:  CALL   134E
03DD6:  MOVLB  1
03DD8:  INCF   xE3,F
03DDA:  BRA    3DA6
....................     }
....................     printf(EXT, "\n--- EPS MISSION END ---\n");
03DDC:  CLRF   FEA
03DDE:  MOVLW  02
03DE0:  MOVWF  FE9
03DE2:  MOVLB  0
03DE4:  RCALL  369E
03DE6:  RETURN 0
.................... }
....................  
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // IHS functions
.................... // Changed return type to signed int8 to allow -1 error code
.................... // Helper function to wait for specific text from Camera
.................... int8 wait_for_cam_confirmation(unsigned int16 timeout_ms) {
*
020FA:  CLRF   xD2
020FC:  CLRF   xD1
020FE:  CLRF   xD0
02100:  CLRF   xCF
....................     char window[2] = {0, 0}; // Our small array to hold the last 2 chars
*
020F4:  MOVLB  1
020F6:  CLRF   xCD
020F8:  CLRF   xCE
....................     unsigned int32 timer = 0;
.................... 
....................     // Clear the software UART buffer first to remove old data
....................     while(kbhit(CAM)) { fgetc(CAM); } 
*
02102:  BTFSC  F85.7
02104:  BRA    210E
02106:  MOVLB  0
02108:  RCALL  20A6
0210A:  MOVLB  1
0210C:  BRA    2102
.................... 
....................     while(timer < timeout_ms) {
0210E:  MOVF   xD2,F
02110:  BNZ   2170
02112:  MOVF   xD1,F
02114:  BNZ   2170
02116:  MOVF   xD0,W
02118:  SUBWF  xCC,W
0211A:  BNC   2170
0211C:  BNZ   2124
0211E:  MOVF   xCB,W
02120:  SUBWF  xCF,W
02122:  BC    2170
....................         if(kbhit(CAM)) {
02124:  BTFSC  F85.7
02126:  BRA    2152
....................             // Slide the window (This is what you meant by array processing)
....................             window[0] = window[1];
02128:  MOVFF  1CE,1CD
....................             window[1] = fgetc(CAM);
0212C:  MOVLB  0
0212E:  RCALL  20A6
02130:  MOVFF  01,1CE
....................             
....................             // Optional: Send to debug terminal
....................             fputc(window[1], EXT); 
02134:  MOVFF  1CE,302
02138:  CALL   134E
.................... 
....................             // Check the array
....................             if (window[0] == 'O' && window[1] == 'K') {
0213C:  MOVLB  1
0213E:  MOVF   xCD,W
02140:  SUBLW  4F
02142:  BNZ   2150
02144:  MOVF   xCE,W
02146:  SUBLW  4B
02148:  BNZ   2150
....................                 return 1; // "OK" found!
0214A:  MOVLW  01
0214C:  MOVWF  01
0214E:  BRA    2174
....................             }
....................         } else {
02150:  BRA    216E
....................             delay_ms(1);
02152:  MOVLW  01
02154:  MOVWF  xE5
02156:  MOVLB  0
02158:  CALL   1324
....................             timer++;
0215C:  MOVLW  01
0215E:  MOVLB  1
02160:  ADDWF  xCF,F
02162:  BTFSC  FD8.0
02164:  INCF   xD0,F
02166:  BTFSC  FD8.2
02168:  INCF   xD1,F
0216A:  BTFSC  FD8.2
0216C:  INCF   xD2,F
....................         }
0216E:  BRA    210E
....................     }
....................     return 0; // Timeout
02170:  MOVLW  00
02172:  MOVWF  01
02174:  MOVLB  0
02176:  GOTO   23B4 (RETURN)
.................... }
.................... 
.................... int8 CAM_MISSION_MAIN (unsigned int8 cam_select, unsigned int8 mission_number) {
....................     unsigned int8 cam_response; 
....................     
....................     fprintf(EXT, "\n--- CAM MISSION START ---\n");
*
022D0:  MOVLW  24
022D2:  MOVWF  FF6
022D4:  MOVLW  03
022D6:  MOVWF  FF7
022D8:  MOVLW  00
022DA:  MOVWF  FF8
022DC:  CALL   1392
.................... 
....................     // 1. Send Capture Command (Append 'x' to end Arduino parsing instantly)
....................     if (cam_select == 1) {
022E0:  MOVLB  1
022E2:  DECFSZ xC0,W
022E4:  BRA    2340
....................         fprintf(CAM, "c%u", mission_number); 
022E6:  MOVLW  63
022E8:  MOVWF  xCD
022EA:  MOVLB  0
022EC:  RCALL  1FE2
022EE:  MOVFF  1C1,1CB
022F2:  MOVLW  1B
022F4:  MOVLB  1
022F6:  MOVWF  xCC
022F8:  MOVLB  0
022FA:  RCALL  2026
....................         fprintf(EXT, "Command Sent: c%u (Capture)\n", mission_number);
022FC:  MOVLW  40
022FE:  MOVWF  FF6
02300:  MOVLW  03
02302:  MOVWF  FF7
02304:  MOVLW  00
02306:  MOVWF  FF8
02308:  MOVLW  0F
0230A:  MOVLB  2
0230C:  MOVWF  xFC
0230E:  MOVLB  0
02310:  CALL   150A
02314:  MOVFF  1C1,1DE
02318:  MOVLW  1B
0231A:  MOVLB  1
0231C:  MOVWF  xDF
0231E:  MOVLB  0
02320:  CALL   148E
02324:  MOVLW  51
02326:  MOVWF  FF6
02328:  MOVLW  03
0232A:  MOVWF  FF7
0232C:  MOVLW  00
0232E:  MOVWF  FF8
02330:  MOVLW  0B
02332:  MOVLB  2
02334:  MOVWF  xFC
02336:  MOVLB  0
02338:  CALL   150A
....................     } else {
0233C:  BRA    2396
0233E:  MOVLB  1
....................         fprintf(CAM, "v%u", mission_number); 
02340:  MOVLW  76
02342:  MOVWF  xCD
02344:  MOVLB  0
02346:  RCALL  1FE2
02348:  MOVFF  1C1,1CB
0234C:  MOVLW  1B
0234E:  MOVLB  1
02350:  MOVWF  xCC
02352:  MOVLB  0
02354:  RCALL  2026
....................         fprintf(EXT, "Command Sent: v%u (Capture)\n", mission_number);
02356:  MOVLW  5E
02358:  MOVWF  FF6
0235A:  MOVLW  03
0235C:  MOVWF  FF7
0235E:  MOVLW  00
02360:  MOVWF  FF8
02362:  MOVLW  0F
02364:  MOVLB  2
02366:  MOVWF  xFC
02368:  MOVLB  0
0236A:  CALL   150A
0236E:  MOVFF  1C1,1DE
02372:  MOVLW  1B
02374:  MOVLB  1
02376:  MOVWF  xDF
02378:  MOVLB  0
0237A:  CALL   148E
0237E:  MOVLW  6F
02380:  MOVWF  FF6
02382:  MOVLW  03
02384:  MOVWF  FF7
02386:  MOVLW  00
02388:  MOVWF  FF8
0238A:  MOVLW  0B
0238C:  MOVLB  2
0238E:  MOVWF  xFC
02390:  MOVLB  0
02392:  CALL   150A
....................     }
.................... 
....................     // 2. THE FIX: Wait for "CAM1 SAVE... OK"
....................     // This cleans the text out of the buffer so it doesn't corrupt the image
....................     fprintf(EXT, "Waiting for Save Confirmation...\n");
02396:  MOVLW  7C
02398:  MOVWF  FF6
0239A:  MOVLW  03
0239C:  MOVWF  FF7
0239E:  MOVLW  00
023A0:  MOVWF  FF8
023A2:  CALL   1392
....................     if (!wait_for_cam_confirmation(5000)) { // 5 second timeout
023A6:  MOVLW  13
023A8:  MOVLB  1
023AA:  MOVWF  xCC
023AC:  MOVLW  88
023AE:  MOVWF  xCB
023B0:  MOVLB  0
023B2:  BRA    20F4
023B4:  MOVF   01,F
023B6:  BNZ   23CE
....................         fprintf(EXT, "ERROR: Camera timed out or failed to save!\n");
023B8:  MOVLW  9E
023BA:  MOVWF  FF6
023BC:  MOVLW  03
023BE:  MOVWF  FF7
023C0:  MOVLW  00
023C2:  MOVWF  FF8
023C4:  CALL   1392
....................         return -1;
023C8:  MOVLW  FF
023CA:  MOVWF  01
023CC:  BRA    24D6
....................     }
....................     fprintf(EXT, "\nConfirmation Received! Requesting Download...\n");
023CE:  MOVLW  CA
023D0:  MOVWF  FF6
023D2:  MOVLW  03
023D4:  MOVWF  FF7
023D6:  MOVLW  00
023D8:  MOVWF  FF8
023DA:  CALL   1392
....................     
....................     delay_ms(100); // Short safety pause
023DE:  MOVLW  64
023E0:  MOVLB  1
023E2:  MOVWF  xE5
023E4:  MOVLB  0
023E6:  CALL   1324
.................... 
....................     // 3. Request Binary Download
....................     if (cam_select == 1) {
023EA:  MOVLB  1
023EC:  DECFSZ xC0,W
023EE:  BRA    240A
....................         fprintf(CAM, "d%u", mission_number);
023F0:  MOVLW  64
023F2:  MOVWF  xCD
023F4:  MOVLB  0
023F6:  RCALL  1FE2
023F8:  MOVFF  1C1,1CB
023FC:  MOVLW  1B
023FE:  MOVLB  1
02400:  MOVWF  xCC
02402:  MOVLB  0
02404:  RCALL  2026
....................     } else {
02406:  BRA    2420
02408:  MOVLB  1
....................         fprintf(CAM, "f%u", mission_number);
0240A:  MOVLW  66
0240C:  MOVWF  xCD
0240E:  MOVLB  0
02410:  RCALL  1FE2
02412:  MOVFF  1C1,1CB
02416:  MOVLW  1B
02418:  MOVLB  1
0241A:  MOVWF  xCC
0241C:  MOVLB  0
0241E:  RCALL  2026
....................     }
.................... 
....................     // 4. Receive Binary Data
....................     // No delays here, just fast reading
....................     unsigned int32 inactivity_timer = 0;
....................     unsigned int32 bytes_read = 0;
02420:  MOVLB  1
02422:  CLRF   xC6
02424:  CLRF   xC5
02426:  CLRF   xC4
02428:  CLRF   xC3
0242A:  CLRF   xCA
0242C:  CLRF   xC9
0242E:  CLRF   xC8
02430:  CLRF   xC7
....................     
....................     while (inactivity_timer < 100000) { 
02432:  MOVF   xC6,F
02434:  BNZ   248C
02436:  MOVF   xC5,W
02438:  SUBLW  01
0243A:  BNC   248C
0243C:  BNZ   244C
0243E:  MOVF   xC4,W
02440:  SUBLW  86
02442:  BNC   248C
02444:  BNZ   244C
02446:  MOVF   xC3,W
02448:  SUBLW  9F
0244A:  BNC   248C
....................         if (kbhit(CAM)) {
0244C:  BTFSC  F85.7
0244E:  BRA    247A
....................             cam_response = fgetc(CAM); 
02450:  MOVLB  0
02452:  RCALL  20A6
02454:  MOVFF  01,1C2
....................             fputc(cam_response, EXT); // Send raw byte to terminal
02458:  MOVFF  1C2,302
0245C:  CALL   134E
....................             bytes_read++;
02460:  MOVLW  01
02462:  MOVLB  1
02464:  ADDWF  xC7,F
02466:  BTFSC  FD8.0
02468:  INCF   xC8,F
0246A:  BTFSC  FD8.2
0246C:  INCF   xC9,F
0246E:  BTFSC  FD8.2
02470:  INCF   xCA,F
....................             inactivity_timer = 0;     // Reset timer because we got data
02472:  CLRF   xC6
02474:  CLRF   xC5
02476:  CLRF   xC4
02478:  CLRF   xC3
....................         }
....................         inactivity_timer++;
0247A:  MOVLW  01
0247C:  ADDWF  xC3,F
0247E:  BTFSC  FD8.0
02480:  INCF   xC4,F
02482:  BTFSC  FD8.2
02484:  INCF   xC5,F
02486:  BTFSC  FD8.2
02488:  INCF   xC6,F
0248A:  BRA    2432
....................     }
.................... 
....................     fprintf(EXT, "\n--- CAM MISSION ENDED (Bytes: %lu) ---\n", bytes_read);
0248C:  MOVLW  FA
0248E:  MOVWF  FF6
02490:  MOVLW  03
02492:  MOVWF  FF7
02494:  MOVLW  00
02496:  MOVWF  FF8
02498:  MOVLW  1F
0249A:  MOVLB  2
0249C:  MOVWF  xFC
0249E:  MOVLB  0
024A0:  CALL   150A
024A4:  MOVLW  41
024A6:  MOVWF  FE9
024A8:  MOVFF  1CA,1CE
024AC:  MOVFF  1C9,1CD
024B0:  MOVFF  1C8,1CC
024B4:  MOVFF  1C7,1CB
024B8:  BRA    220E
024BA:  MOVLW  1C
024BC:  MOVWF  FF6
024BE:  MOVLW  04
024C0:  MOVWF  FF7
024C2:  MOVLW  00
024C4:  MOVWF  FF8
024C6:  MOVLW  06
024C8:  MOVLB  2
024CA:  MOVWF  xFC
024CC:  MOVLB  0
024CE:  CALL   150A
....................     return 0;
024D2:  MOVLW  00
024D4:  MOVWF  01
024D6:  GOTO   4B30 (RETURN)
.................... }
.................... 
....................  int8 update_shutdown_count(void) {
....................      fprintf(EXT, "Shutdown count started\n");
*
01A86:  MOVLW  24
01A88:  MOVWF  FF6
01A8A:  MOVLW  04
01A8C:  MOVWF  FF7
01A8E:  MOVLW  00
01A90:  MOVWF  FF8
01A92:  RCALL  1392
....................  
....................      // Read shutdown count directly from memory
....................      unsigned char shutdown_count[1];
....................      shutdown_count[0] = READ_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, 1); // Updated call
01A94:  MOVLB  1
01A96:  CLRF   xEC
01A98:  MOVLW  10
01A9A:  MOVWF  xEB
01A9C:  CLRF   xEA
01A9E:  MOVLW  11
01AA0:  MOVWF  xE9
01AA2:  MOVLW  01
01AA4:  MOVWF  xED
01AA6:  MOVLB  0
01AA8:  RCALL  16EC
01AAA:  MOVFF  01,1C0
....................      delay_ms(10);
01AAE:  MOVLW  0A
01AB0:  MOVLB  1
01AB2:  MOVWF  xE5
01AB4:  MOVLB  0
01AB6:  RCALL  1324
....................  
....................      fprintf(EXT, "Read shutdown count: %u\n", shutdown_count[0]);
01AB8:  MOVLW  3C
01ABA:  MOVWF  FF6
01ABC:  MOVLW  04
01ABE:  MOVWF  FF7
01AC0:  MOVLW  00
01AC2:  MOVWF  FF8
01AC4:  MOVLW  15
01AC6:  MOVLB  2
01AC8:  MOVWF  xFC
01ACA:  MOVLB  0
01ACC:  RCALL  150A
01ACE:  MOVFF  1C0,1DE
01AD2:  MOVLW  1B
01AD4:  MOVLB  1
01AD6:  MOVWF  xDF
01AD8:  MOVLB  0
01ADA:  RCALL  148E
01ADC:  MOVLW  0A
01ADE:  MOVLB  3
01AE0:  MOVWF  x02
01AE2:  MOVLB  0
01AE4:  RCALL  134E
....................  
....................      shutdown_count[0]++;  // Increment the shutdown count
01AE6:  MOVLB  1
01AE8:  INCF   xC0,F
....................      fprintf(EXT, "Incremented shutdown count: %u\n", shutdown_count[0]);
01AEA:  MOVLW  56
01AEC:  MOVWF  FF6
01AEE:  MOVLW  04
01AF0:  MOVWF  FF7
01AF2:  MOVLW  00
01AF4:  MOVWF  FF8
01AF6:  MOVLW  1C
01AF8:  MOVLB  2
01AFA:  MOVWF  xFC
01AFC:  MOVLB  0
01AFE:  RCALL  150A
01B00:  MOVFF  1C0,1DE
01B04:  MOVLW  1B
01B06:  MOVLB  1
01B08:  MOVWF  xDF
01B0A:  MOVLB  0
01B0C:  RCALL  148E
01B0E:  MOVLW  0A
01B10:  MOVLB  3
01B12:  MOVWF  x02
01B14:  MOVLB  0
01B16:  RCALL  134E
....................  
....................      // Write the updated shutdown count back to memory
....................      WRITE_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, shutdown_count, 1);
01B18:  MOVLB  2
01B1A:  CLRF   xF3
01B1C:  MOVLW  10
01B1E:  MOVWF  xF2
01B20:  CLRF   xF1
01B22:  MOVLW  11
01B24:  MOVWF  xF0
01B26:  MOVLW  01
01B28:  MOVWF  xF5
01B2A:  MOVLW  C0
01B2C:  MOVWF  xF4
01B2E:  MOVLW  01
01B30:  MOVWF  xF6
01B32:  MOVLB  0
01B34:  RCALL  1916
....................      delay_ms(10);
01B36:  MOVLW  0A
01B38:  MOVLB  1
01B3A:  MOVWF  xE5
01B3C:  MOVLB  0
01B3E:  CALL   1324
....................  
....................      fprintf(EXT, "Now shutdown count is : %u\n\n", shutdown_count[0]);
01B42:  MOVLW  76
01B44:  MOVWF  FF6
01B46:  MOVLW  04
01B48:  MOVWF  FF7
01B4A:  MOVLW  00
01B4C:  MOVWF  FF8
01B4E:  MOVLW  18
01B50:  MOVLB  2
01B52:  MOVWF  xFC
01B54:  MOVLB  0
01B56:  RCALL  150A
01B58:  MOVFF  1C0,1DE
01B5C:  MOVLW  1B
01B5E:  MOVLB  1
01B60:  MOVWF  xDF
01B62:  MOVLB  0
01B64:  RCALL  148E
01B66:  MOVLW  0A
01B68:  MOVLB  3
01B6A:  MOVWF  x02
01B6C:  MOVLB  0
01B6E:  CALL   134E
01B72:  MOVLW  0A
01B74:  MOVLB  3
01B76:  MOVWF  x02
01B78:  MOVLB  0
01B7A:  CALL   134E
....................  
....................      return shutdown_count[0];
01B7E:  MOVLB  1
01B80:  MOVFF  1C0,01
01B84:  MOVLB  0
01B86:  GOTO   4964 (RETURN)
....................  }
....................  
....................  
....................  //main flash memory consol for main_menu() function
....................  void write_to_main_flash_menu(){
....................              unsigned int32 address;
....................              unsigned int8 data[256]; // Buffer for data to be written (adjust size as needed)
....................              unsigned char data_number;
....................              unsigned char choice;
....................              unsigned int8 i;
....................              // Prompt user to enter the address
....................              fprintf(EXT, "\nEnter Address (hex, 0x1234): 0x");
*
02C54:  MOVLW  94
02C56:  MOVWF  FF6
02C58:  MOVLW  04
02C5A:  MOVWF  FF7
02C5C:  MOVLW  00
02C5E:  MOVWF  FF8
02C60:  CALL   1392
....................              fscanf(EXT, "%x", &address); // Read address input in hex
02C64:  MOVLB  2
02C66:  CLRF   xF0
02C68:  CLRF   xF1
02C6A:  MOVLW  01
02C6C:  MOVWF  xF3
02C6E:  MOVLW  E9
02C70:  MOVWF  xF2
02C72:  CLRF   xF5
02C74:  CLRF   xF4
02C76:  MOVLB  0
02C78:  RCALL  2A72
02C7A:  MOVF   01,F
02C7C:  BNZ   2C86
02C7E:  MOVLB  2
02C80:  CLRF   xF1
02C82:  BRA    2C8E
02C84:  MOVLB  0
02C86:  MOVF   01,W
02C88:  MOVLB  2
02C8A:  ADDWF  xF0,F
02C8C:  INCF   xF1,F
....................  
....................              // Prompt user to enter the number of bytes
....................              fprintf(EXT, "\nEnter number of bytes to write (max 256): ");
02C8E:  MOVLW  B6
02C90:  MOVWF  FF6
02C92:  MOVLW  04
02C94:  MOVWF  FF7
02C96:  MOVLW  00
02C98:  MOVWF  FF8
02C9A:  MOVLB  0
02C9C:  CALL   1392
....................              fscanf(EXT, "%x", &data_number); // Read number of bytes
02CA0:  MOVLB  2
02CA2:  CLRF   xF0
02CA4:  CLRF   xF1
02CA6:  MOVLW  02
02CA8:  MOVWF  xF5
02CAA:  MOVLW  ED
02CAC:  MOVWF  xF4
02CAE:  CLRF   xF7
02CB0:  CLRF   xF6
02CB2:  MOVLB  0
02CB4:  RCALL  2B84
02CB6:  MOVF   01,F
02CB8:  BNZ   2CC2
02CBA:  MOVLB  2
02CBC:  CLRF   xF1
02CBE:  BRA    2CCA
02CC0:  MOVLB  0
02CC2:  MOVF   01,W
02CC4:  MOVLB  2
02CC6:  ADDWF  xF0,F
02CC8:  INCF   xF1,F
....................  
.................... //             if (data_number > 256) {
.................... //                 fprintf(EXT, "Error: Maximum data length is 256 bytes.\n");
.................... //                 continue;
.................... //             }
....................  
....................              // Get data from user
....................              fprintf(EXT, "Enter %d bytes of data (in hex):\n", data_number);
02CCA:  MOVLW  E2
02CCC:  MOVWF  FF6
02CCE:  MOVLW  04
02CD0:  MOVWF  FF7
02CD2:  MOVLW  00
02CD4:  MOVWF  FF8
02CD6:  MOVLW  06
02CD8:  MOVWF  xFC
02CDA:  MOVLB  0
02CDC:  CALL   150A
02CE0:  MOVFF  2ED,2FC
02CE4:  MOVLW  18
02CE6:  MOVLB  2
02CE8:  MOVWF  xFD
02CEA:  MOVLB  0
02CEC:  CALL   1840
02CF0:  MOVLW  EA
02CF2:  MOVWF  FF6
02CF4:  MOVLW  04
02CF6:  MOVWF  FF7
02CF8:  MOVLW  00
02CFA:  MOVWF  FF8
02CFC:  MOVLW  19
02CFE:  MOVLB  2
02D00:  MOVWF  xFC
02D02:  MOVLB  0
02D04:  CALL   150A
....................              for (i = 0; i < data_number; i++) {
02D08:  MOVLB  2
02D0A:  CLRF   xEF
02D0C:  MOVF   xED,W
02D0E:  SUBWF  xEF,W
02D10:  BC    2D98
....................                  fprintf(EXT, "Byte %d: 0x", i + 1);
02D12:  MOVLW  01
02D14:  ADDWF  xEF,W
02D16:  MOVWF  xF0
02D18:  MOVLW  04
02D1A:  MOVWF  FF6
02D1C:  MOVLW  05
02D1E:  MOVWF  FF7
02D20:  MOVLW  00
02D22:  MOVWF  FF8
02D24:  MOVLW  05
02D26:  MOVWF  xFC
02D28:  MOVLB  0
02D2A:  CALL   150A
02D2E:  MOVFF  2F0,2FC
02D32:  MOVLW  18
02D34:  MOVLB  2
02D36:  MOVWF  xFD
02D38:  MOVLB  0
02D3A:  CALL   1840
02D3E:  MOVLW  0B
02D40:  MOVWF  FF6
02D42:  MOVLW  05
02D44:  MOVWF  FF7
02D46:  MOVLW  00
02D48:  MOVWF  FF8
02D4A:  MOVLW  04
02D4C:  MOVLB  2
02D4E:  MOVWF  xFC
02D50:  MOVLB  0
02D52:  CALL   150A
....................                  fscanf(EXT, "%x", &data[i]); // Read byte in hex format
02D56:  CLRF   03
02D58:  MOVLB  2
02D5A:  MOVF   xEF,W
02D5C:  ADDLW  ED
02D5E:  MOVWF  01
02D60:  MOVLW  01
02D62:  ADDWFC 03,F
02D64:  MOVFF  01,2F0
02D68:  MOVFF  03,2F1
02D6C:  CLRF   xF2
02D6E:  CLRF   xF3
02D70:  MOVFF  03,2F5
02D74:  MOVFF  01,2F4
02D78:  CLRF   xF7
02D7A:  CLRF   xF6
02D7C:  MOVLB  0
02D7E:  RCALL  2B84
02D80:  MOVF   01,F
02D82:  BNZ   2D8C
02D84:  MOVLB  2
02D86:  CLRF   xF3
02D88:  BRA    2D94
02D8A:  MOVLB  0
02D8C:  MOVF   01,W
02D8E:  MOVLB  2
02D90:  ADDWF  xF2,F
02D92:  INCF   xF3,F
02D94:  INCF   xEF,F
02D96:  BRA    2D0C
....................              }
....................  
....................              // Call the function to write data to the address
....................              WRITE_DATA_NBYTES(address, data, data_number);
02D98:  MOVFF  1EC,2F3
02D9C:  MOVFF  1EB,2F2
02DA0:  MOVFF  1EA,2F1
02DA4:  MOVFF  1E9,2F0
02DA8:  MOVLW  01
02DAA:  MOVWF  xF5
02DAC:  MOVLW  ED
02DAE:  MOVWF  xF4
02DB0:  MOVFF  2ED,2F6
02DB4:  MOVLB  0
02DB6:  CALL   1916
....................  
....................              fprintf(EXT, "\nData successfully written.\n");
02DBA:  MOVLW  10
02DBC:  MOVWF  FF6
02DBE:  MOVLW  05
02DC0:  MOVWF  FF7
02DC2:  MOVLW  00
02DC4:  MOVWF  FF8
02DC6:  CALL   1392
02DCA:  GOTO   30B2 (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_main_flash_memory() {
....................      char main_flash_option;
....................      unsigned int32 address;
....................      unsigned char data[32];
....................      unsigned char data_length;
....................  
....................      fprintf(EXT, "MAIN flash memory chosen\n");
*
02EFA:  MOVLW  2E
02EFC:  MOVWF  FF6
02EFE:  MOVLW  05
02F00:  MOVWF  FF7
02F02:  MOVLW  00
02F04:  MOVWF  FF8
02F06:  CALL   1392
....................      fprintf(EXT, "press a: Read ID of the chip\n");
02F0A:  MOVLW  48
02F0C:  MOVWF  FF6
02F0E:  MOVLW  05
02F10:  MOVWF  FF7
02F12:  MOVLW  00
02F14:  MOVWF  FF8
02F16:  CALL   1392
....................      fprintf(EXT, "press b: Write data set in specified address\n");
02F1A:  MOVLW  66
02F1C:  MOVWF  FF6
02F1E:  MOVLW  05
02F20:  MOVWF  FF7
02F22:  MOVLW  00
02F24:  MOVWF  FF8
02F26:  CALL   1392
....................      fprintf(EXT, "press c: Read data set in specified address\n");
02F2A:  MOVLW  94
02F2C:  MOVWF  FF6
02F2E:  MOVLW  05
02F30:  MOVWF  FF7
02F32:  MOVLW  00
02F34:  MOVWF  FF8
02F36:  CALL   1392
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
02F3A:  MOVLW  C2
02F3C:  MOVWF  FF6
02F3E:  MOVLW  05
02F40:  MOVWF  FF7
02F42:  MOVLW  00
02F44:  MOVWF  FF8
02F46:  CALL   1392
....................  
....................      main_flash_option = fgetc(EXT);
02F4A:  CALL   24DA
02F4E:  MOVFF  01,1C3
....................  
....................      switch (main_flash_option) {
02F52:  MOVLB  1
02F54:  MOVF   xC3,W
02F56:  XORLW  61
02F58:  MOVLB  0
02F5A:  BZ    2F6C
02F5C:  XORLW  03
02F5E:  BZ    2F80
02F60:  XORLW  01
02F62:  BZ    2F84
02F64:  XORLW  1B
02F66:  BTFSC  FD8.2
02F68:  BRA    30A0
02F6A:  BRA    30A2
....................          case 'a':
....................              fprintf(EXT, "Started reading chip ID of MAIN flash memory\n");
02F6C:  MOVLW  E0
02F6E:  MOVWF  FF6
02F70:  MOVLW  05
02F72:  MOVWF  FF7
02F74:  MOVLW  00
02F76:  MOVWF  FF8
02F78:  CALL   1392
....................              READ_CHIP_ID_OF();  
02F7C:  BRA    296E
....................              break;
02F7E:  BRA    30B2
....................          case 'b':
....................              write_to_main_flash_menu();
02F80:  BRA    2C54
....................              break;
02F82:  BRA    30B2
....................          case 'c':
....................              fprintf(EXT, "Read data set in specified address\n");
02F84:  MOVLW  0E
02F86:  MOVWF  FF6
02F88:  MOVLW  06
02F8A:  MOVWF  FF7
02F8C:  MOVLW  00
02F8E:  MOVWF  FF8
02F90:  CALL   1392
....................              fprintf(EXT, "Enter your specified address and length (e.g., 0x1234 10): ");
02F94:  MOVLW  32
02F96:  MOVWF  FF6
02F98:  MOVLW  06
02F9A:  MOVWF  FF7
02F9C:  MOVLW  00
02F9E:  MOVWF  FF8
02FA0:  CALL   1392
....................              if (scanf("%x %d", &address, &data_length)) {
02FA4:  MOVLB  1
02FA6:  CLRF   xE9
02FA8:  CLRF   xEA
02FAA:  MOVLW  01
02FAC:  MOVLB  2
02FAE:  MOVWF  xF3
02FB0:  MOVLW  C4
02FB2:  MOVWF  xF2
02FB4:  CLRF   xF5
02FB6:  CLRF   xF4
02FB8:  MOVLB  0
02FBA:  RCALL  2A72
02FBC:  MOVF   01,F
02FBE:  BNZ   2FC8
02FC0:  MOVLB  1
02FC2:  CLRF   xEA
02FC4:  BRA    2FF8
02FC6:  MOVLB  0
02FC8:  MOVF   01,W
02FCA:  MOVLB  1
02FCC:  ADDWF  xE9,F
02FCE:  INCF   xEA,F
02FD0:  CLRF   xEC
02FD2:  CLRF   xEB
02FD4:  MOVLW  01
02FD6:  MOVWF  xEE
02FD8:  MOVLW  E8
02FDA:  MOVWF  xED
02FDC:  MOVLW  0A
02FDE:  MOVWF  xEF
02FE0:  MOVLB  0
02FE2:  BRA    2E1E
02FE4:  MOVF   01,F
02FE6:  BNZ   2FF0
02FE8:  MOVLB  1
02FEA:  CLRF   xEA
02FEC:  BRA    2FF8
02FEE:  MOVLB  0
02FF0:  MOVF   01,W
02FF2:  MOVLB  1
02FF4:  ADDWF  xE9,F
02FF6:  INCF   xEA,F
02FF8:  MOVF   xEA,W
02FFA:  BZ    308C
....................                  fprintf(EXT, "Address: 0x%09x, Length: %d\n", address, data_length);
02FFC:  MOVLW  6E
02FFE:  MOVWF  FF6
03000:  MOVLW  06
03002:  MOVWF  FF7
03004:  MOVLW  00
03006:  MOVWF  FF8
03008:  MOVLW  0B
0300A:  MOVLB  2
0300C:  MOVWF  xFC
0300E:  MOVLB  0
03010:  CALL   150A
03014:  MOVLW  07
03016:  MOVLB  1
03018:  MOVWF  xE9
0301A:  MOVLW  30
0301C:  MOVLB  3
0301E:  MOVWF  x02
03020:  MOVLB  0
03022:  CALL   134E
03026:  MOVLB  1
03028:  DECFSZ xE9,F
0302A:  BRA    301A
0302C:  MOVFF  1C4,2FC
03030:  MOVLW  57
03032:  MOVLB  2
03034:  MOVWF  xFD
03036:  MOVLB  0
03038:  CALL   17DC
0303C:  MOVLW  7D
0303E:  MOVWF  FF6
03040:  MOVLW  06
03042:  MOVWF  FF7
03044:  MOVLW  00
03046:  MOVWF  FF8
03048:  MOVLW  0A
0304A:  MOVLB  2
0304C:  MOVWF  xFC
0304E:  MOVLB  0
03050:  CALL   150A
03054:  MOVFF  1E8,2FC
03058:  MOVLW  18
0305A:  MOVLB  2
0305C:  MOVWF  xFD
0305E:  MOVLB  0
03060:  CALL   1840
03064:  MOVLW  0A
03066:  MOVLB  3
03068:  MOVWF  x02
0306A:  MOVLB  0
0306C:  CALL   134E
....................                  READ_DATA_NBYTES(address, data_length);  // Replace with actual function
03070:  MOVFF  1C7,1EC
03074:  MOVFF  1C6,1EB
03078:  MOVFF  1C5,1EA
0307C:  MOVFF  1C4,1E9
03080:  MOVFF  1E8,1ED
03084:  CALL   16EC
....................              } else {
03088:  BRA    309E
0308A:  MOVLB  1
....................                  fprintf(EXT, "Invalid input. Please enter a valid address and length.\n");
0308C:  MOVLW  8C
0308E:  MOVWF  FF6
03090:  MOVLW  06
03092:  MOVWF  FF7
03094:  MOVLW  00
03096:  MOVWF  FF8
03098:  MOVLB  0
0309A:  CALL   1392
....................              }
....................              break;
0309E:  BRA    30B2
....................  
....................          case 'x':
....................              return;
030A0:  BRA    30B2
....................          default:
....................              fprintf(EXT, "Invalid MAIN flash memory option. Please try again.\n");
030A2:  MOVLW  C6
030A4:  MOVWF  FF6
030A6:  MOVLW  06
030A8:  MOVWF  FF7
030AA:  MOVLW  00
030AC:  MOVWF  FF8
030AE:  CALL   1392
....................              break;
....................      }
030B2:  GOTO   31CC (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_flash_memories() {
....................      char flash_option;
....................      fprintf(EXT, "pressed option d: Check Flash Memories\n\n");
030B6:  MOVLW  FC
030B8:  MOVWF  FF6
030BA:  MOVLW  06
030BC:  MOVWF  FF7
030BE:  MOVLW  00
030C0:  MOVWF  FF8
030C2:  CALL   1392
....................      fprintf(EXT, "Please choose which flash memory to work on (a, b, c, d, e):\n");
030C6:  MOVLW  26
030C8:  MOVWF  FF6
030CA:  MOVLW  07
030CC:  MOVWF  FF7
030CE:  MOVLW  00
030D0:  MOVWF  FF8
030D2:  CALL   1392
....................      fprintf(EXT, "press a: MAIN flash memory\n");
030D6:  MOVLW  64
030D8:  MOVWF  FF6
030DA:  MOVLW  07
030DC:  MOVWF  FF7
030DE:  MOVLW  00
030E0:  MOVWF  FF8
030E2:  CALL   1392
....................      fprintf(EXT, "press b: COM shared flash memory\n");
030E6:  MOVLW  80
030E8:  MOVWF  FF6
030EA:  MOVLW  07
030EC:  MOVWF  FF7
030EE:  MOVLW  00
030F0:  MOVWF  FF8
030F2:  CALL   1392
....................      fprintf(EXT, "press c: ADCS shared flash memory\n");
030F6:  MOVLW  A2
030F8:  MOVWF  FF6
030FA:  MOVLW  07
030FC:  MOVWF  FF7
030FE:  MOVLW  00
03100:  MOVWF  FF8
03102:  CALL   1392
....................      fprintf(EXT, "press d: OVCAM shared flash memory\n");
03106:  MOVLW  C6
03108:  MOVWF  FF6
0310A:  MOVLW  07
0310C:  MOVWF  FF7
0310E:  MOVLW  00
03110:  MOVWF  FF8
03112:  CALL   1392
....................      fprintf(EXT, "press e: MVCAM shared flash memory\n");
03116:  MOVLW  EA
03118:  MOVWF  FF6
0311A:  MOVLW  07
0311C:  MOVWF  FF7
0311E:  MOVLW  00
03120:  MOVWF  FF8
03122:  CALL   1392
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
03126:  MOVLW  0E
03128:  MOVWF  FF6
0312A:  MOVLW  08
0312C:  MOVWF  FF7
0312E:  MOVLW  00
03130:  MOVWF  FF8
03132:  CALL   1392
....................  
....................      flash_option = fgetc(EXT);
03136:  CALL   24DA
0313A:  MOVFF  01,1C2
....................  
....................      switch (flash_option) {
0313E:  MOVLB  1
03140:  MOVF   xC2,W
03142:  XORLW  61
03144:  MOVLB  0
03146:  BZ    315E
03148:  XORLW  03
0314A:  BZ    3172
0314C:  XORLW  01
0314E:  BZ    3184
03150:  XORLW  07
03152:  BZ    3196
03154:  XORLW  01
03156:  BZ    31A8
03158:  XORLW  1D
0315A:  BZ    31BA
0315C:  BRA    31BC
....................          case 'a':
....................              fprintf(EXT, "MAIN shared flash memory chosen\n");
0315E:  MOVLW  2C
03160:  MOVWF  FF6
03162:  MOVLW  08
03164:  MOVWF  FF7
03166:  MOVLW  00
03168:  MOVWF  FF8
0316A:  CALL   1392
....................              handle_main_flash_memory();
0316E:  BRA    2EFA
....................              break;
03170:  BRA    31CC
....................          case 'b':
....................              fprintf(EXT, "COM shared flash memory chosen\n");
03172:  MOVLW  4E
03174:  MOVWF  FF6
03176:  MOVLW  08
03178:  MOVWF  FF7
0317A:  MOVLW  00
0317C:  MOVWF  FF8
0317E:  CALL   1392
....................              // Implement COM shared flash memory handling
....................              break;
03182:  BRA    31CC
....................          case 'c':
....................              fprintf(EXT, "ADCS shared flash memory chosen\n");
03184:  MOVLW  6E
03186:  MOVWF  FF6
03188:  MOVLW  08
0318A:  MOVWF  FF7
0318C:  MOVLW  00
0318E:  MOVWF  FF8
03190:  CALL   1392
....................              // Implement ADCS shared flash memory handling
....................              break;
03194:  BRA    31CC
....................           case 'd':
....................              fprintf(EXT, "OVCAM shared flash memory chosen\n");
03196:  MOVLW  90
03198:  MOVWF  FF6
0319A:  MOVLW  08
0319C:  MOVWF  FF7
0319E:  MOVLW  00
031A0:  MOVWF  FF8
031A2:  CALL   1392
....................              // Implement ADCS shared flash memory handling
....................              break;
031A6:  BRA    31CC
....................           case 'e':
....................              fprintf(EXT, "MVCAM shared flash memory chosen\n");
031A8:  MOVLW  B2
031AA:  MOVWF  FF6
031AC:  MOVLW  08
031AE:  MOVWF  FF7
031B0:  MOVLW  00
031B2:  MOVWF  FF8
031B4:  CALL   1392
....................              // Implement ADCS shared flash memory handling
....................              break;
031B8:  BRA    31CC
....................           case'x':
....................               break;
031BA:  BRA    31CC
....................          default:
....................              fprintf(EXT, "Invalid flash memory option. Please try again.\n");
031BC:  MOVLW  D4
031BE:  MOVWF  FF6
031C0:  MOVLW  08
031C2:  MOVWF  FF7
031C4:  MOVLW  00
031C6:  MOVWF  FF8
031C8:  CALL   1392
....................              break;
....................      }
031CC:  RETURN 0
....................  }
....................  
....................  //main RTCC functions consol for main_menu() function
....................  void handle_set_time() {
....................      char handle_set_time_option;
....................      fprintf(EXT, "Settings of RTC chosen\n");
031CE:  MOVLW  04
031D0:  MOVWF  FF6
031D2:  MOVLW  09
031D4:  MOVWF  FF7
031D6:  MOVLW  00
031D8:  MOVWF  FF8
031DA:  CALL   1392
....................      fprintf(EXT, "    press a: to reset the RTC /all current time will be set zero/\n");
031DE:  MOVLW  1C
031E0:  MOVWF  FF6
031E2:  MOVLW  09
031E4:  MOVWF  FF7
031E6:  MOVLW  00
031E8:  MOVWF  FF8
031EA:  CALL   1392
....................      fprintf(EXT, "    press b: display current time\n");
031EE:  MOVLW  60
031F0:  MOVWF  FF6
031F2:  MOVLW  09
031F4:  MOVWF  FF7
031F6:  MOVLW  00
031F8:  MOVWF  FF8
031FA:  CALL   1392
....................      fprintf(EXT, "    press c: display current time nonstop\n");
031FE:  MOVLW  84
03200:  MOVWF  FF6
03202:  MOVLW  09
03204:  MOVWF  FF7
03206:  MOVLW  00
03208:  MOVWF  FF8
0320A:  CALL   1392
....................      handle_set_time_option = fgetc(EXT);
0320E:  CALL   24DA
03212:  MOVFF  01,1C1
....................  
....................      switch (handle_set_time_option) {
03216:  MOVLB  1
03218:  MOVF   xC1,W
0321A:  XORLW  61
0321C:  MOVLB  0
0321E:  BZ    3234
03220:  XORLW  03
03222:  BTFSC  FD8.2
03224:  BRA    3480
03226:  XORLW  01
03228:  BTFSC  FD8.2
0322A:  BRA    3568
0322C:  XORLW  1B
0322E:  BTFSC  FD8.2
03230:  BRA    3686
03232:  BRA    368A
....................          case 'a':
....................      rtc_time_t write_clock, read_clock;
....................      rtc_read(&read_clock);
03234:  MOVLB  F
03236:  BSF    x5F.0
03238:  BSF    x5F.1
0323A:  MOVLW  01
0323C:  MOVWF  FEA
0323E:  MOVLW  CB
03240:  MOVWF  FE9
03242:  MOVLW  04
03244:  MOVWF  01
03246:  MOVF   x5C,W
03248:  MOVLB  0
0324A:  CALL   1450
0324E:  MOVWF  FEE
03250:  MOVLB  F
03252:  MOVF   x5D,W
03254:  MOVLB  0
03256:  CALL   1450
0325A:  MOVWF  FEE
0325C:  DECFSZ 01,F
0325E:  BRA    3262
03260:  BRA    3266
03262:  MOVLB  F
03264:  BRA    3246
....................      fprintf(EXT, "Now time is\n");
03266:  MOVLW  B0
03268:  MOVWF  FF6
0326A:  MOVLW  09
0326C:  MOVWF  FF7
0326E:  MOVLW  00
03270:  MOVWF  FF8
03272:  CALL   1392
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
03276:  MOVLW  0D
03278:  MOVLB  3
0327A:  MOVWF  x02
0327C:  MOVLB  0
0327E:  CALL   134E
03282:  MOVFF  1CE,1DE
03286:  MOVLW  01
03288:  MOVLB  1
0328A:  MOVWF  xDF
0328C:  MOVLB  0
0328E:  CALL   148E
03292:  MOVLW  2F
03294:  MOVLB  3
03296:  MOVWF  x02
03298:  MOVLB  0
0329A:  CALL   134E
0329E:  MOVFF  1CD,1DE
032A2:  MOVLW  01
032A4:  MOVLB  1
032A6:  MOVWF  xDF
032A8:  MOVLB  0
032AA:  CALL   148E
032AE:  MOVLW  C8
032B0:  MOVWF  FF6
032B2:  MOVLW  09
032B4:  MOVWF  FF7
032B6:  MOVLW  00
032B8:  MOVWF  FF8
032BA:  MOVLW  03
032BC:  MOVLB  2
032BE:  MOVWF  xFC
032C0:  MOVLB  0
032C2:  CALL   150A
032C6:  MOVFF  1CB,1DE
032CA:  MOVLW  01
032CC:  MOVLB  1
032CE:  MOVWF  xDF
032D0:  MOVLB  0
032D2:  CALL   148E
032D6:  MOVLW  20
032D8:  MOVLB  3
032DA:  MOVWF  x02
032DC:  MOVLB  0
032DE:  CALL   134E
032E2:  MOVFF  1CF,1DE
032E6:  MOVLW  01
032E8:  MOVLB  1
032EA:  MOVWF  xDF
032EC:  MOVLB  0
032EE:  CALL   148E
032F2:  MOVLW  3A
032F4:  MOVLB  3
032F6:  MOVWF  x02
032F8:  MOVLB  0
032FA:  CALL   134E
032FE:  MOVFF  1D2,1DE
03302:  MOVLW  01
03304:  MOVLB  1
03306:  MOVWF  xDF
03308:  MOVLB  0
0330A:  CALL   148E
0330E:  MOVLW  3A
03310:  MOVLB  3
03312:  MOVWF  x02
03314:  MOVLB  0
03316:  CALL   134E
0331A:  MOVFF  1D1,1DE
0331E:  MOVLW  01
03320:  MOVLB  1
03322:  MOVWF  xDF
03324:  MOVLB  0
03326:  CALL   148E
....................      fprintf(EXT, "Time changing function activated\n");
0332A:  MOVLW  E0
0332C:  MOVWF  FF6
0332E:  MOVLW  09
03330:  MOVWF  FF7
03332:  MOVLW  00
03334:  MOVWF  FF8
03336:  CALL   1392
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
0334C:  MOVLB  F
0334E:  MOVLW  55
03350:  MOVWF  F7E
03352:  MOVLW  AA
03354:  MOVWF  F7E
03356:  BSF    x5F.5
03358:  BSF    x5F.0
0335A:  BSF    x5F.1
0335C:  MOVLW  01
0335E:  MOVWF  FEA
03360:  MOVLW  C2
03362:  MOVWF  FE9
03364:  MOVLW  04
03366:  MOVWF  01
03368:  MOVF   FEE,W
0336A:  MOVLB  0
0336C:  CALL   142C
03370:  MOVLB  F
03372:  MOVWF  x5C
03374:  MOVF   FEE,W
03376:  MOVLB  0
03378:  CALL   142C
0337C:  MOVLB  F
0337E:  MOVWF  x5D
03380:  DECFSZ 01,F
03382:  BRA    3368
03384:  BCF    x5F.5
....................      fprintf(EXT, "Time successfully changed. Current time is:\n");
03386:  MOVLW  02
03388:  MOVWF  FF6
0338A:  MOVLW  0A
0338C:  MOVWF  FF7
0338E:  MOVLW  00
03390:  MOVWF  FF8
03392:  MOVLB  0
03394:  CALL   1392
....................      rtc_read(&read_clock);
03398:  MOVLB  F
0339A:  BSF    x5F.0
0339C:  BSF    x5F.1
0339E:  MOVLW  01
033A0:  MOVWF  FEA
033A2:  MOVLW  CB
033A4:  MOVWF  FE9
033A6:  MOVLW  04
033A8:  MOVWF  01
033AA:  MOVF   x5C,W
033AC:  MOVLB  0
033AE:  CALL   1450
033B2:  MOVWF  FEE
033B4:  MOVLB  F
033B6:  MOVF   x5D,W
033B8:  MOVLB  0
033BA:  CALL   1450
033BE:  MOVWF  FEE
033C0:  DECFSZ 01,F
033C2:  BRA    33C6
033C4:  BRA    33CA
033C6:  MOVLB  F
033C8:  BRA    33AA
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
033CA:  MOVLW  0D
033CC:  MOVLB  3
033CE:  MOVWF  x02
033D0:  MOVLB  0
033D2:  CALL   134E
033D6:  MOVFF  1CE,1DE
033DA:  MOVLW  01
033DC:  MOVLB  1
033DE:  MOVWF  xDF
033E0:  MOVLB  0
033E2:  CALL   148E
033E6:  MOVLW  2F
033E8:  MOVLB  3
033EA:  MOVWF  x02
033EC:  MOVLB  0
033EE:  CALL   134E
033F2:  MOVFF  1CD,1DE
033F6:  MOVLW  01
033F8:  MOVLB  1
033FA:  MOVWF  xDF
033FC:  MOVLB  0
033FE:  CALL   148E
03402:  MOVLW  3A
03404:  MOVWF  FF6
03406:  MOVLW  0A
03408:  MOVWF  FF7
0340A:  MOVLW  00
0340C:  MOVWF  FF8
0340E:  MOVLW  03
03410:  MOVLB  2
03412:  MOVWF  xFC
03414:  MOVLB  0
03416:  CALL   150A
0341A:  MOVFF  1CB,1DE
0341E:  MOVLW  01
03420:  MOVLB  1
03422:  MOVWF  xDF
03424:  MOVLB  0
03426:  CALL   148E
0342A:  MOVLW  20
0342C:  MOVLB  3
0342E:  MOVWF  x02
03430:  MOVLB  0
03432:  CALL   134E
03436:  MOVFF  1CF,1DE
0343A:  MOVLW  01
0343C:  MOVLB  1
0343E:  MOVWF  xDF
03440:  MOVLB  0
03442:  CALL   148E
03446:  MOVLW  3A
03448:  MOVLB  3
0344A:  MOVWF  x02
0344C:  MOVLB  0
0344E:  CALL   134E
03452:  MOVFF  1D2,1DE
03456:  MOVLW  01
03458:  MOVLB  1
0345A:  MOVWF  xDF
0345C:  MOVLB  0
0345E:  CALL   148E
03462:  MOVLW  3A
03464:  MOVLB  3
03466:  MOVWF  x02
03468:  MOVLB  0
0346A:  CALL   134E
0346E:  MOVFF  1D1,1DE
03472:  MOVLW  01
03474:  MOVLB  1
03476:  MOVWF  xDF
03478:  MOVLB  0
0347A:  CALL   148E
....................      break;
0347E:  BRA    369A
....................          case 'b':
....................              rtc_read(&read_clock);
03480:  MOVLB  F
03482:  BSF    x5F.0
03484:  BSF    x5F.1
03486:  MOVLW  01
03488:  MOVWF  FEA
0348A:  MOVLW  CB
0348C:  MOVWF  FE9
0348E:  MOVLW  04
03490:  MOVWF  01
03492:  MOVF   x5C,W
03494:  MOVLB  0
03496:  CALL   1450
0349A:  MOVWF  FEE
0349C:  MOVLB  F
0349E:  MOVF   x5D,W
034A0:  MOVLB  0
034A2:  CALL   1450
034A6:  MOVWF  FEE
034A8:  DECFSZ 01,F
034AA:  BRA    34AE
034AC:  BRA    34B2
034AE:  MOVLB  F
034B0:  BRA    3492
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
034B2:  MOVLW  0D
034B4:  MOVLB  3
034B6:  MOVWF  x02
034B8:  MOVLB  0
034BA:  CALL   134E
034BE:  MOVFF  1CE,1DE
034C2:  MOVLW  01
034C4:  MOVLB  1
034C6:  MOVWF  xDF
034C8:  MOVLB  0
034CA:  CALL   148E
034CE:  MOVLW  2F
034D0:  MOVLB  3
034D2:  MOVWF  x02
034D4:  MOVLB  0
034D6:  CALL   134E
034DA:  MOVFF  1CD,1DE
034DE:  MOVLW  01
034E0:  MOVLB  1
034E2:  MOVWF  xDF
034E4:  MOVLB  0
034E6:  CALL   148E
034EA:  MOVLW  5C
034EC:  MOVWF  FF6
034EE:  MOVLW  0A
034F0:  MOVWF  FF7
034F2:  MOVLW  00
034F4:  MOVWF  FF8
034F6:  MOVLW  03
034F8:  MOVLB  2
034FA:  MOVWF  xFC
034FC:  MOVLB  0
034FE:  CALL   150A
03502:  MOVFF  1CB,1DE
03506:  MOVLW  01
03508:  MOVLB  1
0350A:  MOVWF  xDF
0350C:  MOVLB  0
0350E:  CALL   148E
03512:  MOVLW  20
03514:  MOVLB  3
03516:  MOVWF  x02
03518:  MOVLB  0
0351A:  CALL   134E
0351E:  MOVFF  1CF,1DE
03522:  MOVLW  01
03524:  MOVLB  1
03526:  MOVWF  xDF
03528:  MOVLB  0
0352A:  CALL   148E
0352E:  MOVLW  3A
03530:  MOVLB  3
03532:  MOVWF  x02
03534:  MOVLB  0
03536:  CALL   134E
0353A:  MOVFF  1D2,1DE
0353E:  MOVLW  01
03540:  MOVLB  1
03542:  MOVWF  xDF
03544:  MOVLB  0
03546:  CALL   148E
0354A:  MOVLW  3A
0354C:  MOVLB  3
0354E:  MOVWF  x02
03550:  MOVLB  0
03552:  CALL   134E
03556:  MOVFF  1D1,1DE
0355A:  MOVLW  01
0355C:  MOVLB  1
0355E:  MOVWF  xDF
03560:  MOVLB  0
03562:  CALL   148E
....................      break;
03566:  BRA    369A
....................          case 'c':
....................                  while(true){
....................                      rtc_read(&read_clock);
03568:  MOVLB  F
0356A:  BSF    x5F.0
0356C:  BSF    x5F.1
0356E:  MOVLW  01
03570:  MOVWF  FEA
03572:  MOVLW  CB
03574:  MOVWF  FE9
03576:  MOVLW  04
03578:  MOVWF  01
0357A:  MOVF   x5C,W
0357C:  MOVLB  0
0357E:  CALL   1450
03582:  MOVWF  FEE
03584:  MOVLB  F
03586:  MOVF   x5D,W
03588:  MOVLB  0
0358A:  CALL   1450
0358E:  MOVWF  FEE
03590:  DECFSZ 01,F
03592:  BRA    3596
03594:  BRA    359A
03596:  MOVLB  F
03598:  BRA    357A
....................                      fprintf(EXT, "Now time is\n");
0359A:  MOVLW  74
0359C:  MOVWF  FF6
0359E:  MOVLW  0A
035A0:  MOVWF  FF7
035A2:  MOVLW  00
035A4:  MOVWF  FF8
035A6:  CALL   1392
....................                      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u\n", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);   
035AA:  MOVLW  0D
035AC:  MOVLB  3
035AE:  MOVWF  x02
035B0:  MOVLB  0
035B2:  CALL   134E
035B6:  MOVFF  1CE,1DE
035BA:  MOVLW  01
035BC:  MOVLB  1
035BE:  MOVWF  xDF
035C0:  MOVLB  0
035C2:  CALL   148E
035C6:  MOVLW  2F
035C8:  MOVLB  3
035CA:  MOVWF  x02
035CC:  MOVLB  0
035CE:  CALL   134E
035D2:  MOVFF  1CD,1DE
035D6:  MOVLW  01
035D8:  MOVLB  1
035DA:  MOVWF  xDF
035DC:  MOVLB  0
035DE:  CALL   148E
035E2:  MOVLW  8C
035E4:  MOVWF  FF6
035E6:  MOVLW  0A
035E8:  MOVWF  FF7
035EA:  MOVLW  00
035EC:  MOVWF  FF8
035EE:  MOVLW  03
035F0:  MOVLB  2
035F2:  MOVWF  xFC
035F4:  MOVLB  0
035F6:  CALL   150A
035FA:  MOVFF  1CB,1DE
035FE:  MOVLW  01
03600:  MOVLB  1
03602:  MOVWF  xDF
03604:  MOVLB  0
03606:  CALL   148E
0360A:  MOVLW  20
0360C:  MOVLB  3
0360E:  MOVWF  x02
03610:  MOVLB  0
03612:  CALL   134E
03616:  MOVFF  1CF,1DE
0361A:  MOVLW  01
0361C:  MOVLB  1
0361E:  MOVWF  xDF
03620:  MOVLB  0
03622:  CALL   148E
03626:  MOVLW  3A
03628:  MOVLB  3
0362A:  MOVWF  x02
0362C:  MOVLB  0
0362E:  CALL   134E
03632:  MOVFF  1D2,1DE
03636:  MOVLW  01
03638:  MOVLB  1
0363A:  MOVWF  xDF
0363C:  MOVLB  0
0363E:  CALL   148E
03642:  MOVLW  3A
03644:  MOVLB  3
03646:  MOVWF  x02
03648:  MOVLB  0
0364A:  CALL   134E
0364E:  MOVFF  1D1,1DE
03652:  MOVLW  01
03654:  MOVLB  1
03656:  MOVWF  xDF
03658:  MOVLB  0
0365A:  CALL   148E
0365E:  MOVLW  0A
03660:  MOVLB  3
03662:  MOVWF  x02
03664:  MOVLB  0
03666:  CALL   134E
....................                      delay_ms(1000);
0366A:  MOVLW  04
0366C:  MOVLB  1
0366E:  MOVWF  xD4
03670:  MOVLW  FA
03672:  MOVWF  xE5
03674:  MOVLB  0
03676:  CALL   1324
0367A:  MOVLB  1
0367C:  DECFSZ xD4,F
0367E:  BRA    3670
03680:  MOVLB  0
03682:  BRA    3568
....................                  }
....................              break;
03684:  BRA    369A
....................          case 'x':
....................              break;
03686:  BRA    369A
....................              return;
03688:  BRA    369A
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
0368A:  MOVLW  A4
0368C:  MOVWF  FF6
0368E:  MOVLW  0A
03690:  MOVWF  FF7
03692:  MOVLW  00
03694:  MOVWF  FF8
03696:  CALL   1392
....................      break;
....................              
....................  }
0369A:  GOTO   4826 (RETURN)
....................  }
....................  //main IO control consol for main_menu() function
....................  void handle_io_control() {
....................      char io_option;
....................      int8 state_of_pin;
....................  
....................      fprintf(EXT, "IO control chosen\n");
*
02528:  MOVLW  CA
0252A:  MOVWF  FF6
0252C:  MOVLW  0A
0252E:  MOVWF  FF7
02530:  MOVLW  00
02532:  MOVWF  FF8
02534:  CALL   1392
....................  
....................      // Check and display the state of each pin before providing options
....................      state_of_pin = input_state(EN_SUP_3V3_1);
02538:  MOVLB  1
0253A:  CLRF   xC2
0253C:  BTFSC  F81.0
0253E:  INCF   xC2,F
....................      fprintf(EXT, "    press a: Toggle EN_SUP_3V3_1 /is currently/");
02540:  MOVLW  DE
02542:  MOVWF  FF6
02544:  MOVLW  0A
02546:  MOVWF  FF7
02548:  MOVLW  00
0254A:  MOVWF  FF8
0254C:  MOVLB  0
0254E:  CALL   1392
....................      if(state_of_pin == 1 ){
02552:  MOVLB  1
02554:  DECFSZ xC2,W
02556:  BRA    256E
....................          fprintf(EXT, "HIGH\n");
02558:  MOVLW  0E
0255A:  MOVWF  FF6
0255C:  MOVLW  0B
0255E:  MOVWF  FF7
02560:  MOVLW  00
02562:  MOVWF  FF8
02564:  MOVLB  0
02566:  CALL   1392
....................      }else if(state_of_pin == 0){
0256A:  BRA    259A
0256C:  MOVLB  1
0256E:  MOVF   xC2,F
02570:  BNZ   2588
....................          fprintf(EXT, "LOW\n");
02572:  MOVLW  14
02574:  MOVWF  FF6
02576:  MOVLW  0B
02578:  MOVWF  FF7
0257A:  MOVLW  00
0257C:  MOVWF  FF8
0257E:  MOVLB  0
02580:  CALL   1392
....................      }else {
02584:  BRA    259A
02586:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02588:  MOVLW  1A
0258A:  MOVWF  FF6
0258C:  MOVLW  0B
0258E:  MOVWF  FF7
02590:  MOVLW  00
02592:  MOVWF  FF8
02594:  MOVLB  0
02596:  CALL   1392
....................      }
....................      state_of_pin = input_state(EN_SUP_3V3_2);
0259A:  MOVLB  1
0259C:  CLRF   xC2
0259E:  BTFSC  F86.1
025A0:  INCF   xC2,F
....................      fprintf(EXT, "    press b: Toggle EN_SUP_3V3_2 /is currently/");
025A2:  MOVLW  24
025A4:  MOVWF  FF6
025A6:  MOVLW  0B
025A8:  MOVWF  FF7
025AA:  MOVLW  00
025AC:  MOVWF  FF8
025AE:  MOVLB  0
025B0:  CALL   1392
....................      if(state_of_pin == 1 ){
025B4:  MOVLB  1
025B6:  DECFSZ xC2,W
025B8:  BRA    25D0
....................          fprintf(EXT, "HIGH\n");
025BA:  MOVLW  54
025BC:  MOVWF  FF6
025BE:  MOVLW  0B
025C0:  MOVWF  FF7
025C2:  MOVLW  00
025C4:  MOVWF  FF8
025C6:  MOVLB  0
025C8:  CALL   1392
....................      }else if(state_of_pin == 0){
025CC:  BRA    25FC
025CE:  MOVLB  1
025D0:  MOVF   xC2,F
025D2:  BNZ   25EA
....................          fprintf(EXT, "LOW\n");
025D4:  MOVLW  5A
025D6:  MOVWF  FF6
025D8:  MOVLW  0B
025DA:  MOVWF  FF7
025DC:  MOVLW  00
025DE:  MOVWF  FF8
025E0:  MOVLB  0
025E2:  CALL   1392
....................      }else {
025E6:  BRA    25FC
025E8:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
025EA:  MOVLW  60
025EC:  MOVWF  FF6
025EE:  MOVLW  0B
025F0:  MOVWF  FF7
025F2:  MOVLW  00
025F4:  MOVWF  FF8
025F6:  MOVLB  0
025F8:  CALL   1392
....................      }
....................       state_of_pin = input_state(EN_SUP_3V3_DAQ);
025FC:  MOVLB  1
025FE:  CLRF   xC2
02600:  BTFSC  F83.0
02602:  INCF   xC2,F
....................      fprintf(EXT, "    press c: Toggle EN_SUP_3V3_DAQ /is currently/");
02604:  MOVLW  6A
02606:  MOVWF  FF6
02608:  MOVLW  0B
0260A:  MOVWF  FF7
0260C:  MOVLW  00
0260E:  MOVWF  FF8
02610:  MOVLB  0
02612:  CALL   1392
....................      if(state_of_pin == 1 ){
02616:  MOVLB  1
02618:  DECFSZ xC2,W
0261A:  BRA    2632
....................          fprintf(EXT, "HIGH\n");
0261C:  MOVLW  9C
0261E:  MOVWF  FF6
02620:  MOVLW  0B
02622:  MOVWF  FF7
02624:  MOVLW  00
02626:  MOVWF  FF8
02628:  MOVLB  0
0262A:  CALL   1392
....................      }else if(state_of_pin == 0){
0262E:  BRA    265E
02630:  MOVLB  1
02632:  MOVF   xC2,F
02634:  BNZ   264C
....................          fprintf(EXT, "LOW\n");
02636:  MOVLW  A2
02638:  MOVWF  FF6
0263A:  MOVLW  0B
0263C:  MOVWF  FF7
0263E:  MOVLW  00
02640:  MOVWF  FF8
02642:  MOVLB  0
02644:  CALL   1392
....................      }else {
02648:  BRA    265E
0264A:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
0264C:  MOVLW  A8
0264E:  MOVWF  FF6
02650:  MOVLW  0B
02652:  MOVWF  FF7
02654:  MOVLW  00
02656:  MOVWF  FF8
02658:  MOVLB  0
0265A:  CALL   1392
....................      }
....................      state_of_pin = input_state(EN_SUP_UNREG);
0265E:  MOVLB  1
02660:  CLRF   xC2
02662:  BTFSC  F81.1
02664:  INCF   xC2,F
....................      fprintf(EXT, "    press d: Toggle EN_SUP_UNREG /is currently/");
02666:  MOVLW  B2
02668:  MOVWF  FF6
0266A:  MOVLW  0B
0266C:  MOVWF  FF7
0266E:  MOVLW  00
02670:  MOVWF  FF8
02672:  MOVLB  0
02674:  CALL   1392
....................      if(state_of_pin == 1 ){
02678:  MOVLB  1
0267A:  DECFSZ xC2,W
0267C:  BRA    2694
....................          fprintf(EXT, "HIGH\n");
0267E:  MOVLW  E2
02680:  MOVWF  FF6
02682:  MOVLW  0B
02684:  MOVWF  FF7
02686:  MOVLW  00
02688:  MOVWF  FF8
0268A:  MOVLB  0
0268C:  CALL   1392
....................      }else if(state_of_pin == 0){
02690:  BRA    26C0
02692:  MOVLB  1
02694:  MOVF   xC2,F
02696:  BNZ   26AE
....................          fprintf(EXT, "LOW\n");
02698:  MOVLW  E8
0269A:  MOVWF  FF6
0269C:  MOVLW  0B
0269E:  MOVWF  FF7
026A0:  MOVLW  00
026A2:  MOVWF  FF8
026A4:  MOVLB  0
026A6:  CALL   1392
....................      }else {
026AA:  BRA    26C0
026AC:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
026AE:  MOVLW  EE
026B0:  MOVWF  FF6
026B2:  MOVLW  0B
026B4:  MOVWF  FF7
026B6:  MOVLW  00
026B8:  MOVWF  FF8
026BA:  MOVLB  0
026BC:  CALL   1392
....................      }
....................      state_of_pin = input_state(EN_SUP_5V0);
026C0:  MOVLB  1
026C2:  CLRF   xC2
026C4:  BTFSC  F83.1
026C6:  INCF   xC2,F
....................      fprintf(EXT, "    press e: Toggle EN_SUP_5V0 /is currently/");
026C8:  MOVLW  F8
026CA:  MOVWF  FF6
026CC:  MOVLW  0B
026CE:  MOVWF  FF7
026D0:  MOVLW  00
026D2:  MOVWF  FF8
026D4:  MOVLB  0
026D6:  CALL   1392
....................      if(state_of_pin == 1 ){
026DA:  MOVLB  1
026DC:  DECFSZ xC2,W
026DE:  BRA    26F6
....................          fprintf(EXT, "HIGH\n");
026E0:  MOVLW  26
026E2:  MOVWF  FF6
026E4:  MOVLW  0C
026E6:  MOVWF  FF7
026E8:  MOVLW  00
026EA:  MOVWF  FF8
026EC:  MOVLB  0
026EE:  CALL   1392
....................      }else if(state_of_pin == 0){
026F2:  BRA    2722
026F4:  MOVLB  1
026F6:  MOVF   xC2,F
026F8:  BNZ   2710
....................          fprintf(EXT, "LOW\n");
026FA:  MOVLW  2C
026FC:  MOVWF  FF6
026FE:  MOVLW  0C
02700:  MOVWF  FF7
02702:  MOVLW  00
02704:  MOVWF  FF8
02706:  MOVLB  0
02708:  CALL   1392
....................      }else {
0270C:  BRA    2722
0270E:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02710:  MOVLW  32
02712:  MOVWF  FF6
02714:  MOVLW  0C
02716:  MOVWF  FF7
02718:  MOVLW  00
0271A:  MOVWF  FF8
0271C:  MOVLB  0
0271E:  CALL   1392
....................      }
....................      state_of_pin = input_state(KILL_SWITCH);
02722:  MOVLB  1
02724:  CLRF   xC2
02726:  BTFSC  F80.4
02728:  INCF   xC2,F
....................      fprintf(EXT, "    press f: Toggle KILL_SWITCH /is currently/");
0272A:  MOVLW  3C
0272C:  MOVWF  FF6
0272E:  MOVLW  0C
02730:  MOVWF  FF7
02732:  MOVLW  00
02734:  MOVWF  FF8
02736:  MOVLB  0
02738:  CALL   1392
....................      if(state_of_pin == 1 ){
0273C:  MOVLB  1
0273E:  DECFSZ xC2,W
02740:  BRA    2758
....................          fprintf(EXT, "HIGH\n");
02742:  MOVLW  6C
02744:  MOVWF  FF6
02746:  MOVLW  0C
02748:  MOVWF  FF7
0274A:  MOVLW  00
0274C:  MOVWF  FF8
0274E:  MOVLB  0
02750:  CALL   1392
....................      }else if(state_of_pin == 0){
02754:  BRA    2784
02756:  MOVLB  1
02758:  MOVF   xC2,F
0275A:  BNZ   2772
....................          fprintf(EXT, "LOW\n");
0275C:  MOVLW  72
0275E:  MOVWF  FF6
02760:  MOVLW  0C
02762:  MOVWF  FF7
02764:  MOVLW  00
02766:  MOVWF  FF8
02768:  MOVLB  0
0276A:  CALL   1392
....................      }else {
0276E:  BRA    2784
02770:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02772:  MOVLW  78
02774:  MOVWF  FF6
02776:  MOVLW  0C
02778:  MOVWF  FF7
0277A:  MOVLW  00
0277C:  MOVWF  FF8
0277E:  MOVLB  0
02780:  CALL   1392
....................      }
....................          state_of_pin = input_state(MVCAM_PWR);
02784:  MOVLB  1
02786:  CLRF   xC2
02788:  BTFSC  F86.0
0278A:  INCF   xC2,F
....................      fprintf(EXT, "    press g: Toggle MVCAM_PWR /is currently/");
0278C:  MOVLW  82
0278E:  MOVWF  FF6
02790:  MOVLW  0C
02792:  MOVWF  FF7
02794:  MOVLW  00
02796:  MOVWF  FF8
02798:  MOVLB  0
0279A:  CALL   1392
....................      if(state_of_pin == 1 ){
0279E:  MOVLB  1
027A0:  DECFSZ xC2,W
027A2:  BRA    27BA
....................          fprintf(EXT, "HIGH\n");
027A4:  MOVLW  B0
027A6:  MOVWF  FF6
027A8:  MOVLW  0C
027AA:  MOVWF  FF7
027AC:  MOVLW  00
027AE:  MOVWF  FF8
027B0:  MOVLB  0
027B2:  CALL   1392
....................      }else if(state_of_pin == 0){
027B6:  BRA    27E6
027B8:  MOVLB  1
027BA:  MOVF   xC2,F
027BC:  BNZ   27D4
....................          fprintf(EXT, "LOW\n");
027BE:  MOVLW  B6
027C0:  MOVWF  FF6
027C2:  MOVLW  0C
027C4:  MOVWF  FF7
027C6:  MOVLW  00
027C8:  MOVWF  FF8
027CA:  MOVLB  0
027CC:  CALL   1392
....................      }else {
027D0:  BRA    27E6
027D2:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
027D4:  MOVLW  BC
027D6:  MOVWF  FF6
027D8:  MOVLW  0C
027DA:  MOVWF  FF7
027DC:  MOVLW  00
027DE:  MOVWF  FF8
027E0:  MOVLB  0
027E2:  CALL   1392
....................      }
....................          state_of_pin = input_state(OVCAM_PWR);
027E6:  MOVLB  1
027E8:  CLRF   xC2
027EA:  BTFSC  F83.7
027EC:  INCF   xC2,F
....................      fprintf(EXT, "    press h: Toggle OVCAM_PWR /is currently/");
027EE:  MOVLW  C6
027F0:  MOVWF  FF6
027F2:  MOVLW  0C
027F4:  MOVWF  FF7
027F6:  MOVLW  00
027F8:  MOVWF  FF8
027FA:  MOVLB  0
027FC:  CALL   1392
....................      if(state_of_pin == 1 ){
02800:  MOVLB  1
02802:  DECFSZ xC2,W
02804:  BRA    281C
....................          fprintf(EXT, "HIGH\n");
02806:  MOVLW  F4
02808:  MOVWF  FF6
0280A:  MOVLW  0C
0280C:  MOVWF  FF7
0280E:  MOVLW  00
02810:  MOVWF  FF8
02812:  MOVLB  0
02814:  CALL   1392
....................      }else if(state_of_pin == 0){
02818:  BRA    2848
0281A:  MOVLB  1
0281C:  MOVF   xC2,F
0281E:  BNZ   2836
....................          fprintf(EXT, "LOW\n");
02820:  MOVLW  FA
02822:  MOVWF  FF6
02824:  MOVLW  0C
02826:  MOVWF  FF7
02828:  MOVLW  00
0282A:  MOVWF  FF8
0282C:  MOVLB  0
0282E:  CALL   1392
....................      }else {
02832:  BRA    2848
02834:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02836:  MOVLW  00
02838:  MOVWF  FF6
0283A:  MOVLW  0D
0283C:  MOVWF  FF7
0283E:  MOVLW  00
02840:  MOVWF  FF8
02842:  MOVLB  0
02844:  CALL   1392
....................      }
....................          state_of_pin = input_state(ADCS_PWR);
02848:  MOVLB  1
0284A:  CLRF   xC2
0284C:  BTFSC  F83.6
0284E:  INCF   xC2,F
....................      fprintf(EXT, "    press i: Toggle ADCS_PWR /is currently/");
02850:  MOVLW  0A
02852:  MOVWF  FF6
02854:  MOVLW  0D
02856:  MOVWF  FF7
02858:  MOVLW  00
0285A:  MOVWF  FF8
0285C:  MOVLB  0
0285E:  CALL   1392
....................      if(state_of_pin == 1 ){
02862:  MOVLB  1
02864:  DECFSZ xC2,W
02866:  BRA    287E
....................          fprintf(EXT, "HIGH\n");
02868:  MOVLW  36
0286A:  MOVWF  FF6
0286C:  MOVLW  0D
0286E:  MOVWF  FF7
02870:  MOVLW  00
02872:  MOVWF  FF8
02874:  MOVLB  0
02876:  CALL   1392
....................      }else if(state_of_pin == 0){
0287A:  BRA    28AA
0287C:  MOVLB  1
0287E:  MOVF   xC2,F
02880:  BNZ   2898
....................          fprintf(EXT, "LOW\n");
02882:  MOVLW  3C
02884:  MOVWF  FF6
02886:  MOVLW  0D
02888:  MOVWF  FF7
0288A:  MOVLW  00
0288C:  MOVWF  FF8
0288E:  MOVLB  0
02890:  CALL   1392
....................      }else {
02894:  BRA    28AA
02896:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02898:  MOVLW  42
0289A:  MOVWF  FF6
0289C:  MOVLW  0D
0289E:  MOVWF  FF7
028A0:  MOVLW  00
028A2:  MOVWF  FF8
028A4:  MOVLB  0
028A6:  CALL   1392
....................      }
....................      fprintf(EXT, "    press j: Toggle all Pins");
028AA:  MOVLW  4C
028AC:  MOVWF  FF6
028AE:  MOVLW  0D
028B0:  MOVWF  FF7
028B2:  MOVLW  00
028B4:  MOVWF  FF8
028B6:  CALL   1392
....................      
....................  
....................      io_option = fgetc(EXT);
028BA:  RCALL  24DA
028BC:  MOVFF  01,1C1
....................  
....................      switch (io_option) {
028C0:  MOVLB  1
028C2:  MOVF   xC1,W
028C4:  XORLW  61
028C6:  MOVLB  0
028C8:  BZ    28F8
028CA:  XORLW  03
028CC:  BZ    28FE
028CE:  XORLW  01
028D0:  BZ    2904
028D2:  XORLW  07
028D4:  BZ    290A
028D6:  XORLW  01
028D8:  BZ    2910
028DA:  XORLW  03
028DC:  BZ    2916
028DE:  XORLW  01
028E0:  BZ    291C
028E2:  XORLW  0F
028E4:  BZ    2922
028E6:  XORLW  01
028E8:  BZ    2928
028EA:  XORLW  03
028EC:  BZ    292E
028EE:  XORLW  01
028F0:  BZ    2950
028F2:  XORLW  13
028F4:  BZ    2956
028F6:  BRA    295A
....................          case 'a':
....................              output_toggle(EN_SUP_3V3_1);
028F8:  BCF    F93.0
028FA:  BTG    F8A.0
....................              break;
028FC:  BRA    296A
....................          case 'b':
....................              output_toggle(EN_SUP_3V3_2);
028FE:  BCF    F98.1
02900:  BTG    F8F.1
....................              break;
02902:  BRA    296A
....................          case 'c':
....................              output_toggle(EN_SUP_3V3_DAQ);
02904:  BCF    F95.0
02906:  BTG    F8C.0
....................              break;
02908:  BRA    296A
....................          case 'd':
....................              output_toggle(EN_SUP_UNREG);
0290A:  BCF    F93.1
0290C:  BTG    F8A.1
....................              break;
0290E:  BRA    296A
....................          case 'e':
....................              output_toggle(EN_SUP_5V0);
02910:  BCF    F95.1
02912:  BTG    F8C.1
....................              break;
02914:  BRA    296A
....................          case 'f':
....................              output_toggle(KILL_SWITCH);
02916:  BCF    F92.4
02918:  BTG    F89.4
....................              break;
0291A:  BRA    296A
....................          case 'g':
....................              output_toggle(MVCAM_PWR);
0291C:  BCF    F98.0
0291E:  BTG    F8F.0
....................              break;
02920:  BRA    296A
....................          case 'h':
....................              output_toggle(OVCAM_PWR);        
02922:  BCF    F95.7
02924:  BTG    F8C.7
....................              break;
02926:  BRA    296A
....................          case 'i':
....................              output_toggle(ADCS_PWR);        
02928:  BCF    F95.6
0292A:  BTG    F8C.6
....................              break;    
0292C:  BRA    296A
....................          case 'j' :
....................              output_toggle(OVCAM_PWR);
0292E:  BCF    F95.7
02930:  BTG    F8C.7
....................              output_toggle(MVCAM_PWR);  
02932:  BCF    F98.0
02934:  BTG    F8F.0
....................              output_toggle(KILL_SWITCH);
02936:  BCF    F92.4
02938:  BTG    F89.4
....................              output_toggle(EN_SUP_5V0);
0293A:  BCF    F95.1
0293C:  BTG    F8C.1
....................              output_toggle(EN_SUP_UNREG);
0293E:  BCF    F93.1
02940:  BTG    F8A.1
....................              output_toggle(EN_SUP_3V3_DAQ);
02942:  BCF    F95.0
02944:  BTG    F8C.0
....................              output_toggle(EN_SUP_3V3_2);
02946:  BCF    F98.1
02948:  BTG    F8F.1
....................              output_toggle(EN_SUP_3V3_1);
0294A:  BCF    F93.0
0294C:  BTG    F8A.0
....................              break;
0294E:  BRA    296A
....................          case 'k' :
....................              output_toggle(MX_PIN_COM);
02950:  BCF    F94.4
02952:  BTG    F8B.4
....................              break;
02954:  BRA    296A
....................          case 'x':
....................              break;
02956:  BRA    296A
....................              return;
02958:  BRA    296A
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
0295A:  MOVLW  6A
0295C:  MOVWF  FF6
0295E:  MOVLW  0D
02960:  MOVWF  FF7
02962:  MOVLW  00
02964:  MOVWF  FF8
02966:  CALL   1392
....................              break;
....................      }
0296A:  GOTO   4826 (RETURN)
....................  }
....................  void testmode(void){
....................     fprintf(EXT, "    press a: ADCS mission mode\n");
*
045D6:  MOVLW  90
045D8:  MOVWF  FF6
045DA:  MOVLW  0D
045DC:  MOVWF  FF7
045DE:  MOVLW  00
045E0:  MOVWF  FF8
045E2:  CALL   1392
....................     fprintf(EXT, "    press b: EPS mission mode\n");
045E6:  MOVLW  B0
045E8:  MOVWF  FF6
045EA:  MOVLW  0D
045EC:  MOVWF  FF7
045EE:  MOVLW  00
045F0:  MOVWF  FF8
045F2:  CALL   1392
....................     fprintf(EXT, "    press c: Check Flash Memories\n");
045F6:  MOVLW  D0
045F8:  MOVWF  FF6
045FA:  MOVLW  0D
045FC:  MOVWF  FF7
045FE:  MOVLW  00
04600:  MOVWF  FF8
04602:  CALL   1392
....................           //fprintf(EXT, "    press e: See satellite Log\n");
....................           char io_option;
....................             io_option = fgetc(EXT);
04606:  CALL   24DA
0460A:  MOVFF  01,1C1
....................             switch (io_option) {
0460E:  MOVLB  1
04610:  MOVF   xC1,W
04612:  XORLW  61
04614:  MOVLB  0
04616:  BZ    4622
04618:  XORLW  03
0461A:  BZ    4636
0461C:  XORLW  01
0461E:  BZ    464C
04620:  BRA    4652
....................               case 'a':
....................                 fprintf(EXT, "ADCS mission mode\n");
04622:  MOVLW  F4
04624:  MOVWF  FF6
04626:  MOVLW  0D
04628:  MOVWF  FF7
0462A:  MOVLW  00
0462C:  MOVWF  FF8
0462E:  CALL   1392
....................                 adcs_mission_mode();
04632:  BRA    40F4
....................                 break;
04634:  BRA    4662
....................                 case 'b':
....................                 fprintf(EXT, "EPS mission mode\n");
04636:  MOVLW  08
04638:  MOVWF  FF6
0463A:  MOVLW  0E
0463C:  MOVWF  FF7
0463E:  MOVLW  00
04640:  MOVWF  FF8
04642:  CALL   1392
....................                 eps_mission_mode();
04646:  CALL   3D64
....................                 break;
0464A:  BRA    4662
....................                 case 'c':
....................                 handle_flash_memories();
0464C:  CALL   30B6
....................                 break;
04650:  BRA    4662
....................                 default:
....................                 fprintf(EXT, "Invalid IO option. Please try again.\n");
04652:  MOVLW  1A
04654:  MOVWF  FF6
04656:  MOVLW  0E
04658:  MOVWF  FF7
0465A:  MOVLW  00
0465C:  MOVWF  FF8
0465E:  CALL   1392
....................                 break;
....................    }
04662:  GOTO   4826 (RETURN)
....................  }
....................          
.................... void main_menu(void) {
....................     char option;
....................   fprintf(EXT, " __  __ _____ _   _ _   _   _____                 _   _             \n");
04666:  MOVLW  40
04668:  MOVWF  FF6
0466A:  MOVLW  0E
0466C:  MOVWF  FF7
0466E:  MOVLW  00
04670:  MOVWF  FF8
04672:  CALL   1392
....................   fprintf(EXT, "|  \\/  | ____| \\ | | | | | |  ___|   _ _ __   ___| |_(_) ___  _ __  \n");
04676:  MOVLW  86
04678:  MOVWF  FF6
0467A:  MOVLW  0E
0467C:  MOVWF  FF7
0467E:  MOVLW  00
04680:  MOVWF  FF8
04682:  CALL   1392
....................   fprintf(EXT, "| |\\/| |  _| |  \\| | | | | | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\ \n");
04686:  MOVLW  CC
04688:  MOVWF  FF6
0468A:  MOVLW  0E
0468C:  MOVWF  FF7
0468E:  MOVLW  00
04690:  MOVWF  FF8
04692:  CALL   1392
....................   fprintf(EXT, "| |  | | |___| |\\  | |_| | |  _|| |_| | | | | (__| |_| | (_) | | | |\n");
04696:  MOVLW  12
04698:  MOVWF  FF6
0469A:  MOVLW  0F
0469C:  MOVWF  FF7
0469E:  MOVLW  00
046A0:  MOVWF  FF8
046A2:  CALL   1392
....................   fprintf(EXT, "|_| _|_|_____|_| \\_|\\___/  |_|_  \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|\n");
046A6:  MOVLW  58
046A8:  MOVWF  FF6
046AA:  MOVLW  0F
046AC:  MOVWF  FF7
046AE:  MOVLW  00
046B0:  MOVWF  FF8
046B2:  CALL   1392
....................   fprintf(EXT, "   / \\   ___| |_(_)_   ____ _| |_ ___  __| | |                      \n");
046B6:  MOVLW  9E
046B8:  MOVWF  FF6
046BA:  MOVLW  0F
046BC:  MOVWF  FF7
046BE:  MOVLW  00
046C0:  MOVWF  FF8
046C2:  CALL   1392
....................   fprintf(EXT, "  / _ \\ / __| __| \\ \\ / / _` | __/ _ \\/ _` | |                      \n");
046C6:  MOVLW  E4
046C8:  MOVWF  FF6
046CA:  MOVLW  0F
046CC:  MOVWF  FF7
046CE:  MOVLW  00
046D0:  MOVWF  FF8
046D2:  CALL   1392
....................   fprintf(EXT, " / ___ \\ (__| |_| |\\ V / (_| | ||  __/ (_| |_|                      \n");
046D6:  MOVLW  2A
046D8:  MOVWF  FF6
046DA:  MOVLW  10
046DC:  MOVWF  FF7
046DE:  MOVLW  00
046E0:  MOVWF  FF8
046E2:  CALL   1392
....................   fprintf(EXT, "/_/   \\_\\___|\\__|_| \\_/ \\__,_|\\__\\___|\\__,_(_)                      \n");
046E6:  MOVLW  70
046E8:  MOVWF  FF6
046EA:  MOVLW  10
046EC:  MOVWF  FF7
046EE:  MOVLW  00
046F0:  MOVWF  FF8
046F2:  CALL   1392
....................     
....................     while (1) {
....................         // Display Main Menu
....................         fprintf(EXT, "\n-----------------Main Menu-----------------\n");
046F6:  MOVLW  B6
046F8:  MOVWF  FF6
046FA:  MOVLW  10
046FC:  MOVWF  FF7
046FE:  MOVLW  00
04700:  MOVWF  FF8
04702:  CALL   1392
....................         //fprintf(EXT, "    press a: Get House keeping data\n");
....................         fprintf(EXT, "    press b: EPS Power output control\n");
04706:  MOVLW  E4
04708:  MOVWF  FF6
0470A:  MOVLW  10
0470C:  MOVWF  FF7
0470E:  MOVLW  00
04710:  MOVWF  FF8
04712:  CALL   1392
....................         fprintf(EXT, "    press c: House keeping data collection\n");
04716:  MOVLW  0C
04718:  MOVWF  FF6
0471A:  MOVLW  11
0471C:  MOVWF  FF7
0471E:  MOVLW  00
04720:  MOVWF  FF8
04722:  CALL   1392
....................         fprintf(EXT, "    press d: Check Flash Memories\n");
04726:  MOVLW  38
04728:  MOVWF  FF6
0472A:  MOVLW  11
0472C:  MOVWF  FF7
0472E:  MOVLW  00
04730:  MOVWF  FF8
04732:  CALL   1392
....................         //fprintf(EXT, "    press e: See satellite Log\n");
....................         fprintf(EXT, "    press f: Settings of RTC\n");
04736:  MOVLW  5C
04738:  MOVWF  FF6
0473A:  MOVLW  11
0473C:  MOVWF  FF7
0473E:  MOVLW  00
04740:  MOVWF  FF8
04742:  CALL   1392
....................         //fprintf(EXT, "    press g: Satellite log down-link command\n");
....................         //fprintf(EXT, "    press h: IHC Mission start\n");
....................         //fprintf(EXT, "    press i: SEL current Measurement\n");
....................         //fprintf(EXT, "    press j: H8 COM Reset\n");
....................         fprintf(EXT, "    press k: UART TEST of EPS\n");
04746:  MOVLW  7A
04748:  MOVWF  FF6
0474A:  MOVLW  11
0474C:  MOVWF  FF7
0474E:  MOVLW  00
04750:  MOVWF  FF8
04752:  CALL   1392
....................         fprintf(EXT, "    press l: testmode \n");
04756:  MOVLW  9A
04758:  MOVWF  FF6
0475A:  MOVLW  11
0475C:  MOVWF  FF7
0475E:  MOVLW  00
04760:  MOVWF  FF8
04762:  CALL   1392
....................         fprintf(EXT, "    press x: Exit Main Menu\n");
04766:  MOVLW  B2
04768:  MOVWF  FF6
0476A:  MOVLW  11
0476C:  MOVWF  FF7
0476E:  MOVLW  00
04770:  MOVWF  FF8
04772:  CALL   1392
....................         fprintf(EXT, "    DO NOT USE CAPITAL CHARACTERS TO WRITE!\n\n");
04776:  MOVLW  D0
04778:  MOVWF  FF6
0477A:  MOVLW  11
0477C:  MOVWF  FF7
0477E:  MOVLW  00
04780:  MOVWF  FF8
04782:  CALL   1392
.................... 
....................         // Read the user's choice
....................         option = fgetc(EXT);
04786:  CALL   24DA
0478A:  MOVFF  01,1C0
.................... 
....................         // Main menu switch
....................         switch (option) {
0478E:  MOVLB  1
04790:  MOVF   xC0,W
04792:  XORLW  61
04794:  MOVLB  0
04796:  BZ    47CA
04798:  XORLW  03
0479A:  BZ    47CC
0479C:  XORLW  01
0479E:  BZ    47D2
047A0:  XORLW  07
047A2:  BZ    47D4
047A4:  XORLW  01
047A6:  BZ    47DA
047A8:  XORLW  03
047AA:  BZ    47DC
047AC:  XORLW  01
047AE:  BZ    47E2
047B0:  XORLW  0F
047B2:  BZ    47E4
047B4:  XORLW  01
047B6:  BZ    47E6
047B8:  XORLW  03
047BA:  BZ    47E8
047BC:  XORLW  01
047BE:  BZ    47EA
047C0:  XORLW  07
047C2:  BZ    4800
047C4:  XORLW  14
047C6:  BZ    4814
047C8:  BRA    4816
....................             case 'a':
....................                 // Call a function to get housekeeping data
....................                 // get_housekeeping_data();
....................                 break;
047CA:  BRA    4826
....................             case 'b':
....................                 // Call a function to control EPS power output
....................                 handle_io_control();
047CC:  GOTO   2528
....................                 break;
047D0:  BRA    4826
....................             case 'c':
....................                 // Call a function to collect housekeeping data
....................                 // collect_housekeeping_data();
....................                 break;
047D2:  BRA    4826
....................             case 'd':
....................                 handle_flash_memories();
047D4:  CALL   30B6
....................                 break;
047D8:  BRA    4826
....................             case 'e':
....................                 // Call a function to see satellite log
....................                 // see_satellite_log();
....................                 break;
047DA:  BRA    4826
....................             case 'f':
....................                 handle_set_time();
047DC:  GOTO   31CE
....................                 break;
047E0:  BRA    4826
....................             case 'g':
....................                 // Call a function for satellite log downlink command
....................                 // satellite_log_downlink_command();
....................                 break;
047E2:  BRA    4826
....................             case 'h':
....................                 // Call a function for IHC mission start
....................                 // ihc_mission_start();
....................                 break;
047E4:  BRA    4826
....................             case 'i':
....................                 // Call a function for SEL current measurement
....................                 // sel_current_measurement();
....................                 break;
047E6:  BRA    4826
....................             case 'j':
....................                 // Call a function for H8 COM reset
....................                 // h8_com_reset();
....................                 break;
047E8:  BRA    4826
....................             case 'k':
....................                 fprintf(EXT, "UART TEST Initialized.\n");
047EA:  MOVLW  FE
047EC:  MOVWF  FF6
047EE:  MOVLW  11
047F0:  MOVWF  FF7
047F2:  MOVLW  00
047F4:  MOVWF  FF8
047F6:  CALL   1392
....................                 eps_mission_mode();
047FA:  CALL   3D64
....................                 break;
047FE:  BRA    4826
....................             case 'l':
....................                 fprintf(EXT, "Testmode initialized\n");
04800:  MOVLW  16
04802:  MOVWF  FF6
04804:  MOVLW  12
04806:  MOVWF  FF7
04808:  MOVLW  00
0480A:  MOVWF  FF8
0480C:  CALL   1392
....................                 testmode();
04810:  BRA    45D6
....................                 break;
04812:  BRA    4826
....................                 
....................             case 'x':
....................                 return;
04814:  BRA    4828
....................             default:
....................                 fprintf(EXT, "Invalid option. Please try again.\n");
04816:  MOVLW  2C
04818:  MOVWF  FF6
0481A:  MOVLW  12
0481C:  MOVWF  FF7
0481E:  MOVLW  00
04820:  MOVWF  FF8
04822:  CALL   1392
....................                 break;
....................         }
04826:  BRA    46F6
....................     }
04828:  GOTO   4B36 (RETURN)
.................... }
.................... 
.................... 
.................... // #include <flashoperation.h>
.................... 
.................... 
.................... 
....................  
....................  #ifdef	__cplusplus
....................  }
....................  #endif
....................  
....................  #endif	/* MAIN_H */
....................  
....................  
.................... 
.................... 
.................... char bichig[25] = "test data update of MAIN"; //test data for testing 
.................... char bichigcom[24] = "test data update of COM"; //test data for testing 
.................... char bichigadcs[25] = "test data update of ADCS"; //test data for testing 
.................... char *read_data; //MAIN flash received data will be stored in here 
.................... // unsigned char buffer[40]; //secondary buffer 
.................... char *read_data_com; //COM flash received data will be stored in here 
.................... unsigned int8 local_buffer[10]; 
....................     unsigned int8 adcs_status = 0;
....................     unsigned int32 last_adcs_address = 0;
....................     unsigned int32 first_adcs_data_address = 0;
.................... 
.................... void main() {
0482C:  CLRF   FF8
0482E:  BCF    FD0.7
04830:  CLRF   F9B
04832:  CLRF   F64
04834:  CLRF   F65
04836:  CLRF   F66
04838:  MOVLW  02
0483A:  MOVWF  FD3
0483C:  BCF    F96.5
0483E:  BSF    F8D.5
04840:  BCF    F94.6
04842:  BSF    F8B.6
04844:  BCF    F95.2
04846:  BSF    F8C.2
04848:  BCF    F97.6
0484A:  BSF    F8E.6
0484C:  BSF    F96.0
0484E:  BCF    F96.6
04850:  BCF    F96.1
04852:  BCF    F8D.1
04854:  BSF    F93.5
04856:  BCF    F93.4
04858:  BCF    F93.2
0485A:  BCF    F8A.2
0485C:  BSF    F92.0
0485E:  BCF    F92.1
04860:  BCF    F92.3
04862:  BCF    F89.3
04864:  MOVLB  1
04866:  CLRF   x07
04868:  CLRF   x06
0486A:  CLRF   x1B
0486C:  CLRF   x1C
0486E:  MOVLW  67
04870:  MOVWF  x1D
04872:  CLRF   xB5
04874:  CLRF   xB9
04876:  CLRF   xB8
04878:  CLRF   xB7
0487A:  CLRF   xB6
0487C:  CLRF   xBD
0487E:  CLRF   xBC
04880:  CLRF   xBB
04882:  CLRF   xBA
04884:  MOVLB  E
04886:  CLRF   xD9
04888:  CLRF   xDA
0488A:  CLRF   xCE
0488C:  CLRF   xCF
0488E:  CLRF   xD0
04890:  CLRF   xD1
04892:  CLRF   xD2
04894:  CLRF   xD3
04896:  CLRF   xD4
04898:  CLRF   xD5
0489A:  CLRF   x45
0489C:  CLRF   x46
0489E:  CLRF   x47
048A0:  BCF    x8D.7
048A2:  BCF    x8D.6
048A4:  BCF    x8D.5
048A6:  MOVLB  F
048A8:  CLRF   x53
048AA:  CLRF   x38
048AC:  CLRF   x37
048AE:  BRA    4918
048B0:  DATA 02,00
048B2:  DATA 04,00
048B4:  DATA 00,09
048B6:  DATA 01,0A
048B8:  DATA 33,05
048BA:  DATA 05,22
048BC:  DATA 01,05
048BE:  DATA 11,01
048C0:  DATA 05,05
048C2:  DATA C0,00
048C4:  DATA 03,80
048C6:  DATA 33,05
048C8:  DATA 01,4A
048CA:  DATA 01,5D
048CC:  DATA 74,65
048CE:  DATA 73,74
048D0:  DATA 20,64
048D2:  DATA 61,74
048D4:  DATA 61,20
048D6:  DATA 75,70
048D8:  DATA 64,61
048DA:  DATA 74,65
048DC:  DATA 20,6F
048DE:  DATA 66,20
048E0:  DATA 4D,41
048E2:  DATA 49,4E
048E4:  DATA 00,74
048E6:  DATA 65,73
048E8:  DATA 74,20
048EA:  DATA 64,61
048EC:  DATA 74,61
048EE:  DATA 20,75
048F0:  DATA 70,64
048F2:  DATA 61,74
048F4:  DATA 65,20
048F6:  DATA 6F,66
048F8:  DATA 20,43
048FA:  DATA 4F,4D
048FC:  DATA 00,74
048FE:  DATA 65,73
04900:  DATA 74,20
04902:  DATA 64,61
04904:  DATA 74,61
04906:  DATA 20,75
04908:  DATA 70,64
0490A:  DATA 61,74
0490C:  DATA 65,20
0490E:  DATA 6F,66
04910:  DATA 20,41
04912:  DATA 44,43
04914:  DATA 53,00
04916:  DATA 00,00
04918:  MOVLW  00
0491A:  MOVWF  FF8
0491C:  MOVLW  48
0491E:  MOVWF  FF7
04920:  MOVLW  B0
04922:  MOVWF  FF6
04924:  TBLRD*+
04926:  MOVF   FF5,W
04928:  MOVWF  00
0492A:  XORLW  00
0492C:  BZ    4954
0492E:  TBLRD*+
04930:  MOVF   FF5,W
04932:  MOVWF  01
04934:  BTFSC  FE8.7
04936:  BRA    4942
04938:  ANDLW  3F
0493A:  MOVWF  FEA
0493C:  TBLRD*+
0493E:  MOVFF  FF5,FE9
04942:  BTFSC  01.6
04944:  TBLRD*+
04946:  BTFSS  01.6
04948:  TBLRD*+
0494A:  MOVFF  FF5,FEE
0494E:  DCFSNZ 00,F
04950:  BRA    4924
04952:  BRA    4946
04954:  CLRF   FF8
....................     //------------------------Start_Indicator-------------------------
....................     startup_freeze();
04956:  MOVLB  0
04958:  GOTO   13BA
....................     //--------------------------RTC-----------------------------------
....................     RTC_initialize();
0495C:  GOTO   153A
....................     //------------------------restart_indicator-----------------------
....................     update_shutdown_count();
04960:  GOTO   1A86
....................     //------------------------read_chip_ID----------------------------
....................     fprintf(EXT, "Reading chip ID of main\n");
04964:  MOVLW  50
04966:  MOVWF  FF6
04968:  MOVLW  12
0496A:  MOVWF  FF7
0496C:  MOVLW  00
0496E:  MOVWF  FF8
04970:  CALL   1392
....................     // READ_CHIP_ID_GENERIC(SPIPORT, CS_PIN_1, -1);  // Pass the array to be filled by the function
....................     fprintf(EXT, "Reading chip ID of COM\n");
04974:  MOVLW  6A
04976:  MOVWF  FF6
04978:  MOVLW  12
0497A:  MOVWF  FF7
0497C:  MOVLW  00
0497E:  MOVWF  FF8
04980:  CALL   1392
....................     READ_CHIP_ID_OF_COM();
04984:  GOTO   1BD6
....................     fprintf(EXT, "Reading chip ID of ADCS\n");
04988:  MOVLW  82
0498A:  MOVWF  FF6
0498C:  MOVLW  12
0498E:  MOVWF  FF7
04990:  MOVLW  00
04992:  MOVWF  FF8
04994:  CALL   1392
....................     READ_CHIP_ID_OF_ADCS();
04998:  CALL   1CB0
....................     fprintf(EXT, "Done reading chip ID\n");
0499C:  MOVLW  9C
0499E:  MOVWF  FF6
049A0:  MOVLW  12
049A2:  MOVWF  FF7
049A4:  MOVLW  00
049A6:  MOVWF  FF8
049A8:  CALL   1392
....................     delay_ms(1000);
049AC:  MOVLW  04
049AE:  MOVLB  1
049B0:  MOVWF  xC0
049B2:  MOVLW  FA
049B4:  MOVWF  xE5
049B6:  MOVLB  0
049B8:  CALL   1324
049BC:  MOVLB  1
049BE:  DECFSZ xC0,F
049C0:  BRA    49B2
.................... 
.................... 
....................     //------------------------write_flash_memory--------------------------
....................     // Write and read from MAIN flash memory 
....................     fprintf(EXT, "Starting to write data in MAIN flash memory\n");
049C2:  MOVLW  B2
049C4:  MOVWF  FF6
049C6:  MOVLW  12
049C8:  MOVWF  FF7
049CA:  MOVLW  00
049CC:  MOVWF  FF8
049CE:  MOVLB  0
049D0:  CALL   1392
....................     WRITE_DATA_NBYTES (0x00005000, bichig, sizeof(bichig));
049D4:  MOVLB  2
049D6:  CLRF   xF3
049D8:  CLRF   xF2
049DA:  MOVLW  50
049DC:  MOVWF  xF1
049DE:  CLRF   xF0
049E0:  MOVLW  01
049E2:  MOVWF  xF5
049E4:  MOVLW  5D
049E6:  MOVWF  xF4
049E8:  MOVLW  19
049EA:  MOVWF  xF6
049EC:  MOVLB  0
049EE:  CALL   1916
....................     delay_ms(1000);
049F2:  MOVLW  04
049F4:  MOVLB  1
049F6:  MOVWF  xC0
049F8:  MOVLW  FA
049FA:  MOVWF  xE5
049FC:  MOVLB  0
049FE:  CALL   1324
04A02:  MOVLB  1
04A04:  DECFSZ xC0,F
04A06:  BRA    49F8
....................     
....................     read_data = (0x00005000, sizeof(bichig));
04A08:  CLRF   xA8
04A0A:  MOVLW  19
04A0C:  MOVWF  xA7
....................     delay_ms(1000);
04A0E:  MOVLW  04
04A10:  MOVWF  xC0
04A12:  MOVLW  FA
04A14:  MOVWF  xE5
04A16:  MOVLB  0
04A18:  CALL   1324
04A1C:  MOVLB  1
04A1E:  DECFSZ xC0,F
04A20:  BRA    4A12
....................     for (int i = 0; i < sizeof(bichig); i++) {
04A22:  CLRF   xBE
04A24:  MOVF   xBE,W
04A26:  SUBLW  18
04A28:  BNC   4A52
....................         fprintf(EXT, "%c", read_data[i]);
04A2A:  MOVF   xBE,W
04A2C:  ADDWF  xA7,W
04A2E:  MOVWF  FE9
04A30:  MOVLW  00
04A32:  ADDWFC xA8,W
04A34:  MOVWF  FEA
04A36:  MOVFF  FEF,302
04A3A:  MOVLB  0
04A3C:  CALL   134E
....................         delay_ms(2);
04A40:  MOVLW  02
04A42:  MOVLB  1
04A44:  MOVWF  xE5
04A46:  MOVLB  0
04A48:  CALL   1324
04A4C:  MOVLB  1
04A4E:  INCF   xBE,F
04A50:  BRA    4A24
....................     }
....................     fprintf(EXT, "\n"); 
04A52:  MOVLW  0A
04A54:  MOVLB  3
04A56:  MOVWF  x02
04A58:  MOVLB  0
04A5A:  CALL   134E
.................... 
....................     // Write and read from COM flash memory
....................     fprintf(EXT, "Starting to write data in COM flash memory\n");
04A5E:  MOVLW  E0
04A60:  MOVWF  FF6
04A62:  MOVLW  12
04A64:  MOVWF  FF7
04A66:  MOVLW  00
04A68:  MOVWF  FF8
04A6A:  CALL   1392
....................     WRITE_DATA_NBYTES_COM(0x00005000, bichigcom, sizeof(bichigcom));
04A6E:  MOVLB  1
04A70:  CLRF   xC3
04A72:  CLRF   xC2
04A74:  MOVLW  50
04A76:  MOVWF  xC1
04A78:  CLRF   xC0
04A7A:  MOVLW  01
04A7C:  MOVWF  xC5
04A7E:  MOVLW  76
04A80:  MOVWF  xC4
04A82:  MOVLW  18
04A84:  MOVWF  xC6
04A86:  MOVLB  0
04A88:  GOTO   1D60
....................     delay_ms(1000);
04A8C:  MOVLW  04
04A8E:  MOVLB  1
04A90:  MOVWF  xC0
04A92:  MOVLW  FA
04A94:  MOVWF  xE5
04A96:  MOVLB  0
04A98:  CALL   1324
04A9C:  MOVLB  1
04A9E:  DECFSZ xC0,F
04AA0:  BRA    4A92
....................     
....................     read_data_com = READ_DATA_NBYTES_COM(0x00005000, sizeof(bichigcom));
04AA2:  CLRF   xC3
04AA4:  CLRF   xC2
04AA6:  MOVLW  50
04AA8:  MOVWF  xC1
04AAA:  CLRF   xC0
04AAC:  MOVLW  18
04AAE:  MOVWF  xC4
04AB0:  MOVLB  0
04AB2:  GOTO   1EE4
04AB6:  MOVFF  02,1AA
04ABA:  MOVFF  01,1A9
....................     delay_ms(1000);
04ABE:  MOVLW  04
04AC0:  MOVLB  1
04AC2:  MOVWF  xC0
04AC4:  MOVLW  FA
04AC6:  MOVWF  xE5
04AC8:  MOVLB  0
04ACA:  CALL   1324
04ACE:  MOVLB  1
04AD0:  DECFSZ xC0,F
04AD2:  BRA    4AC4
....................     for (int i = 0; i < sizeof(bichigcom); i++) {
04AD4:  CLRF   xBF
04AD6:  MOVF   xBF,W
04AD8:  SUBLW  17
04ADA:  BNC   4B04
....................         fprintf(EXT, "%c", read_data_com[i]);
04ADC:  MOVF   xBF,W
04ADE:  ADDWF  xA9,W
04AE0:  MOVWF  FE9
04AE2:  MOVLW  00
04AE4:  ADDWFC xAA,W
04AE6:  MOVWF  FEA
04AE8:  MOVFF  FEF,302
04AEC:  MOVLB  0
04AEE:  CALL   134E
....................         delay_ms(2);
04AF2:  MOVLW  02
04AF4:  MOVLB  1
04AF6:  MOVWF  xE5
04AF8:  MOVLB  0
04AFA:  CALL   1324
04AFE:  MOVLB  1
04B00:  INCF   xBF,F
04B02:  BRA    4AD6
....................     }
....................     fprintf(EXT, "\n"); 
04B04:  MOVLW  0A
04B06:  MOVLB  3
04B08:  MOVWF  x02
04B0A:  MOVLB  0
04B0C:  CALL   134E
....................     fprintf(EXT, "MAIN TEST IS FINISHED!\n");
04B10:  MOVLW  0C
04B12:  MOVWF  FF6
04B14:  MOVLW  13
04B16:  MOVWF  FF7
04B18:  MOVLW  00
04B1A:  MOVWF  FF8
04B1C:  CALL   1392
....................     //------------------------send_and_write_adcs_mission--------------------------
.................... //    adcs_mission_mode();
.................... // adcs_mission_mode_dumm();
....................      //------------------------send_and_plot_IHC_miss--------------------------
....................     // // eps_mission_mode();
....................     // fprintf(CAM, "v247"); // command to take picture ov5642 camera module c is the each slot of 64kB and 247 is one of 0 to 2047 slots 
....................     // delay_ms(2000);
....................     // fprintf(EXT, "CAM COMMAND SENT\n"); // after sending command wait for 1 second and receive jpeg from camera ov5642 it's 8kB data 
....................     // //cam1 command "c" for take picture in slot 1-2047 slots of 64kB
....................     // //cam2 command "v" for take picture in slot 1-2047 slots of 64kB
....................     // //cam2 command "f" for retreat command from taking picture form given slot 
....................     // //cam1 command "d" for retreat command from taking picture form given slot
....................     // //example to take picture in slot 247 
....................     // //camera example output jpeg data should look like this 
....................     // /*04 00 00 E6 38 00 00 E6 FD 42 4F 4F 54 0D 0A 4A 45 44 45 43 3A 20 30 20 30 20 30 0D 0A 43 41 4D 20 53 50 49 20 74 65 73 74 3A 20 30 78 30 0D 0A 43 41 4D 20 53 50 49 20 74 65 73 74 3A 20 30 78 31 31 0D 0A 43 61 6D 65 72 61 20 72 65 61 64 79 2E 0D 0A 43 6F 6D 6D 61 6E 64 73 3A 0D 0A 20 20 63 4E 20 3D 20 63 61 70 74 75 72 65 20 26 20 73 61 76 65 20 74 6F 20 73 6C 6F 74 20 4E 20 20 20 28 65 78 61 6D 70 6C 65 3A 20 63 35 29 0D 0A 20 20 64 4E 20 3D 20 64 75 6D 70 20 73 6C 6F 74 20 4E 20 62 69 6E 61 72 79 20 20 20 20 20 20 20 20 20 28 65 78 61 6D 70 6C 65 3A 20 64 35 29 0D 0A 4D 61 78 20 73 6C 6F 74 73 3A 20 32 30 34 37 0D 0A 00 00 0E 58 FF D8 FF E0 00 10 4A 46 49 46 00 01 01 01 00 00 00 00 00 00 FF DB 00 43 00 08 06 06 07 06 05 08 07 07 07 09 09 08 0A 0C 14 0D 0C 0B 0B 0C 19 12 13 0F 14 1D 1A 1F 1E 1D 1A 1C 1C 20 24 2E 27 20 22 2C 23 1C 1C 28 37 29 2C 30 31 34 34 34 1F 27 39 3D 38 32 3C 2E 33 34 32 FF DB 00 43 01 09 09 09 0C 0B 0C 18 0D 0D 18 32 21 1C 21 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 FF C4 00 1F 00 00 01 05 01 01 01 01 01 01 00 00 00 00 00 00 00 00 01 02 03 04 05 06 07 08 09 0A 0B FF C4 00 B5 10 00 02 01 03 03 02 04 03 05 05 04 04 00 00 01 7D 01 02 03 00 04 11 05 12 21 31 41 06 13 51 61 07 22 71 14 32 81 91 A1 08 23 42 B1 C1 15 52 D1 F0 24 33 62 72 82 09 0A 16 17 18 19 1A 25 26 27 28 29 2A 34 35 36 37 38 39 3A 43 44 45 46 47 48 49 4A 53 54 55 56 57 58 59 5A 63 64 65 66 67 68 69 6A 73 74 75 76 77 78 79 7A 83 84 85 86 87 88 89 8A 92 93 94 95 96 97 98 99 9A A2 A3 A4 A5 A6 A7 A8 A9 AA B2 B3 B4 B5 B6 B7 B8 B9 BA C2 C3 C4 C5 C6 C7 C8 C9 CA D2 D3 D4 D5 D6 D7 D8 D9 DA E1 E2 E3 E4 E5 E6 E7 E8 E9 EA F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FF C4 00 1F 01 00 03 01 01 01 01 01 01 01 01 01 00 00 00 00 00 00 01 02 03 04 05 06 07 08 09 0A 0B FF C4 00 B5 11 00 02 01 02 04 04 03 04 07 05 04 04 00 01 02 77 00 01 02 03 11 04 05 21 31 06 12 41 51 07 61 71 13 22 32 81 08 14 42 91 A1 B1 C1 09 23 33 52 F0 15 62 72 D1 0A 16 24 34 E1 25 F1 17 18 19 1A 26 27 28 29 2A 35 36 37 38 39 3A 43 44 45 46 47 48 49 4A 53 54 55 56 57 58 59 5A 63 64 65 66 67 68 69 6A 73 74 75 76 77 78 79 7A 82 83 84 85 86 87 88 89 8A 92 93 94 95 96 97 98 99 9A A2 A3 A4 A5 A6 A7 A8 A9 AA B2 B3 B4 B5 B6 B7 B8 B9 BA C2 C3 C4 C5 C6 C7 C8 C9 CA D2 D3 D4 D5 D6 D7 D8 D9 DA E2 E3 E4 E5 E6 E7 E8 E9 EA F2 F3 F4 F5 F6 F7 F8 F9 FA FF C0 00 11 08 00 F0 01 40 03 01 21 00 02 11 01 03 11 01 FF DA 00 0C 03 01 00 02 11 03 11 00 3F 00 DE CD 34 9A A2 48 CD 30 D4 8C 8C D4 66 80 12 96 80 1A 68 A0 05 A7 0A 00 75 3A 80 0A 28 00 A5 CD 03 0C D2 66 80 0D D4 DD D4 08 6E EA 4F 32 81 12 2C 95 28 7A 00 90 49 52 09 68 02 55 9A A4 13 D0 22 41 3D 48 2E 68 02 41 73 EF 4E FB 55 00 48 2E BD E9 0D E7 BD 02 23 37 BE F5 13 5F 7B D0 04 0D 7C 7D 6A 09 2F 4E DE B4 01 1D 34 D3 2C 8C D3 69 0C 8C D4 74 00 52 D0 02 51 40 05 28 A0 43 A9 68 18 B4 50 02 52 66 80 13 34 99 A0 06 96 A6 16 A0 43 4B 54 7B E8 01 44 B5 30 96 80 24 12 D4 82 4A 04 3C 49 4E F3 68 01 DE 6D 2F 9D 40 0E F3 FD E9 7C FA 00 3E D3 51 B5 CF BD 00 44 6E BD EA 16 BB A0 08 5A EE A1 7B BE 0D 02 36 E8 C5 05 0D 22 A3 22 81 91 95 A6 ED A4 01 B6 8D B4 00 9B 68 C5 00 18 A5 A0 05 A2 80 16 8A 00 61 A6 50 02 66 9B 9A 60 34 9A 8C 9A 00 8C B5 44 CF 40 86 79 9C D3 D6 6A 00 95 65 A9 04 D4 08 70 9A 9D E7 50 02 F9 D4 79 F4 00 BE 7D 27 DA 28 02 36 BB AA ED 79 40 10 3D E7 BD 40 D7 94 00 CF B4 66 9F BC 91 40 1D 90 A2 82 86 9A 8C 8A 40 33 6D 1B 69 00 6D A3 6D 30 13 14 DC 50 02 62 8C 50 02 E2 8C 50 02 62 8A 00 61 A8 DA 80 22 34 C2 69 81 1E EA 61 6A 00 61 35 0B 9A 04 40 4D 01 A8 02 41 25 48 24 A0 07 09 69 7C DA 00 3C DA 4F 3A 80 1A 67 A8 9E E6 81 15 DE E6 AB 3D D7 34 01 01 B8 CD 39 5C 9A 00 B0 95 65 7A 50 23 B2 CD 2D 49 61 46 DA 00 36 D2 6D A0 03 65 26 28 01 9B 69 31 40 06 28 DB 4C 03 14 B8 A0 04 C5 34 AD 00 46 45 44 D4 01 03 54 2C 68 01 84 D3 0D 30 1A 7A 54 4D 40 10 35 37 34 00 66 97 34 00 BB A8 DD 40 84 2F 4C 32 50 04 4D 2D 40 F3 D0 05 69 24 26 AB 92 4D 02 1C A2 AD 46 28 02 DA 55 A5 E9 40 8E C8 21 A9 04 75 25 8E D9 4E F2 E9 00 BE 5D 2F 97 40 08 63 A6 79 54 00 D3 1D 46 52 98 09 E5 9A 3C B3 40 0B E5 D2 F9 74 00 9B 29 85 68 02 26 5A 81 D6 98 15 DC 55 76 A0 08 9A A2 26 98 0D 2D 50 B3 D0 04 45 A9 99 A0 03 34 6E A4 01 BA 8D F4 00 C2 F5 1B 3D 00 40 CC 73 51 1C D0 02 62 9B 8E 68 11 22 AD 4E 82 98 8B 29 56 17 A5 02 3D 01 62 A9 04 55 05 8F 10 D3 BC 9A 00 5F 26 9D E4 D0 02 79 54 D3 0D 30 19 E4 53 0C 14 00 79 14 79 14 00 79 34 9E 55 00 46 52 A2 2B 40 10 3A D5 77 5A 60 55 90 55 49 28 02 BB 54 26 98 11 93 51 9A 00 8F 14 62 80 0C 52 62 90 0D C5 26 28 01 A4 53 0A D0 03 0A D3 4A 50 03 76 D1 B6 80 1E AB 53 01 4C 44 AA 2A 75 A0 93 D2 91 2A 75 8E A0 B2 41 1D 3B CB A0 05 F2 E9 C2 2A 60 2F 95 4D F2 A8 10 DF 2A 9B E5 50 30 F2 69 3C 9A 00 4F 2E A2 68 E8 11 0B 25 42 C9 40 15 DD 6A AC 8B 4C 0A 92 0A A1 35 03 2A 39 A8 19 A9 81 09 34 94 80 4A 5A 00 28 C5 00 26 29 B8 A4 02 6D A6 91 40 C4 DB 4D 2B 4C 43 36 D2 6D A0 07 81 52 0A 62 24 5A 98 74 A0 47 A9 22 D4 EA 95 05 12 05 A9 36 D0 20 DB 4B 8A 60 2E 28 F2 E8 00 F2 A8 F2 A9 80 79 54 79 34 80 8C C3 50 BC 54 C0 AC F1 D5 67 4A 04 55 91 6A 9C 82 81 95 24 AC F9 E9 8C CE 94 D5 72 68 01 B4 EA 40 2E 29 71 40 06 28 C5 21 89 B6 8D B4 00 9B 68 DB 40 0D DB 4D 2B 40 0C 2B 49 B6 98 85 C5 3B 14 C0 78 A9 87 4A 09 3D 59 05 58 55 A8 19 2A A5 3F 6D 30 17 65 2E CA 00 70 4A 78 8E 98 87 F9 54 79 54 00 BE 55 2F 95 40 0C 31 54 0F 0D 30 2B 3C 35 56 48 68 02 9C B0 D6 7C D1 50 06 7C A9 59 F3 A5 03 33 26 5A A8 47 34 86 2D 28 A0 07 52 E2 90 C5 C5 2E 28 00 C5 1B 69 0C 5D B4 9B 68 01 36 D3 0A D3 10 C2 B4 DD B4 08 31 4B 8A A0 1E 05 4A 05 04 9E B6 8B 53 AA D4 0C 95 45 49 8A 60 2E DA 5D B4 C0 90 2D 48 12 81 12 04 A7 79 74 00 EF 2E 97 CA A6 03 1A 2A 85 A2 A0 0A EF 15 55 92 2A 00 A5 2C 55 9F 3C 54 01 97 71 1D 66 4E 94 0C CB 9D 6A 83 0A 43 12 9C 29 0C 75 2D 20 16 96 81 8E A5 A0 05 C5 18 A0 04 22 98 56 80 18 56 99 8A 62 0D B4 B8 A6 21 C0 54 A0 71 4C 47 AC C7 56 16 A0 09 56 A4 A6 02 D3 85 30 25 5A 99 45 02 26 55 A7 85 A6 21 FB 69 DB 28 01 A5 2A 16 8E 80 2B BC 75 56 48 E8 02 9C B1 D6 74 F1 D0 06 4D CC 75 91 3A D0 33 26 E4 73 59 CF D6 91 44 74 B4 86 3A 9D 48 63 A9 68 01 45 3A 80 1D 4E C5 00 04 53 08 A0 06 6D A6 E2 98 86 E2 97 14 C4 38 0A 94 0E 29 88 F5 28 CD 5A 53 52 22 45 35 20 A6 03 A9 E2 80 24 5A 99 4D 00 4E A6 A5 06 98 89 05 3A 80 0A 8D A8 02 B3 D5 59 28 02 9C B5 9D 3D 00 65 5C 8A C7 B8 14 0C C7 BA 15 95 27 5A 45 11 51 48 A1 D9 A5 CD 20 1D 9A 5C D0 03 B3 4E 14 0C 78 35 20 A0 07 53 71 40 86 91 4C 22 98 0D C5 18 A6 49 20 15 20 14 C4 7A 4C 6F 56 95 AA 44 4E A6 A5 06 98 0B 9A 50 D4 0C 91 5A A6 56 A0 44 EA D5 32 9A 62 24 06 9E 0D 00 2D 44 E6 80 2B B9 AA B2 1A 00 A5 29 AA 13 9A 00 CA B9 AC 7B 8A 06 65 5C D6 4C BD 69 14 41 45 49 41 4B 40 0B 4E A0 07 53 85 00 3C 53 C5 03 25 14 B4 00 D3 4C 34 C4 37 14 01 4C 92 45 15 28 1C 53 11 DF 44 D5 71 1A A0 44 CA F5 27 99 4C 61 E6 52 89 29 81 22 C9 53 AB D0 04 EA F5 2A BD 31 12 87 A9 03 D0 21 4B D4 4E F4 08 AC EF 55 A4 7A 06 52 95 EB 3E 67 A0 0C BB 87 AC A9 9A 82 8C CB 83 59 53 75 A4 32 0A 2A 4A 0A 5A 00 5A 75 00 3A 9D 40 0F 14 F1 40 C9 56 96 80 10 D3 28 10 DA 51 54 49 2A D4 A3 A5 31 1D A4 4F 56 95 EA 00 78 92 9D E6 D3 00 F3 68 F3 A9 8C 95 26 AB 2B 2D 02 27 59 6A 51 2D 31 12 09 69 E2 5A 04 3B CD A8 9A 5A 00 81 A5 AA D2 49 40 14 A5 92 B3 E6 92 80 33 27 92 B3 E5 6A 0A 33 67 6A CD 94 F3 48 64 34 B5 25 0B 4B 40 0B 4A 28 01 D4 EA 00 78 A7 8A 06 4A B4 EA 00 69 A6 50 21 31 4A 2A 89 25 02 A5 14 C4 CE B5 2A CA 9A 80 1D 9A 69 6A 63 23 F3 69 3C EA 00 95 25 AB 49 2D 30 26 59 AA 61 35 31 12 09 A9 C2 6A 04 2F 9D 4C 69 A8 02 16 9A AA C9 35 00 52 96 6A CF 9A 6A 00 A1 24 95 46 59 28 28 A1 33 55 16 A9 18 98 A5 C5 21 8B 8A 5C 50 02 E2 9D 8A 00 5C 52 81 40 0F 14 F1 40 C9 05 2D 00 25 36 81 09 4A 2A 89 25 5A 98 0E 29 88 EB 10 54 C0 54 0C 5A 63 F4 A0 0A 8C 79 A4 06 98 C9 D0 D5 85 34 C4 48 1A 9F BE 98 87 79 94 EF 3A 80 0F 3E 98 D3 D0 22 06 9E AB 49 71 40 14 A5 9E A9 C9 2D 03 2A 49 25 51 96 4A 43 2A B9 A8 31 CD 22 85 DB 4E DB 48 07 6D A5 D9 40 0B B6 97 6D 00 2E DA 5D B4 00 B8 A5 02 81 92 2D 2E 28 01 31 49 8A 04 25 38 0A 64 92 A8 A9 80 AA 11 D7 2A D4 C1 6A 00 5D B4 C6 4A 63 2A 3C 74 D1 1D 03 26 55 A9 54 53 11 26 28 A6 02 53 0B 50 22 32 F5 13 49 40 15 DE 5A AB 24 B4 01 55 E4 AA B2 4B 40 CA 92 4B 55 9D EA 40 88 9C D1 48 A1 E2 9C 05 00 3F 14 EC 50 02 ED A5 C5 00 2E DA 36 D0 01 B6 97 6D 03 1E 16 9D B6 81 09 B6 93 6D 00 26 DA 00 A6 49 32 8A 94 0E 2A 84 76 68 95 3A C5 52 22 4F 26 90 C3 41 44 0F 6F 51 79 34 00 E1 1D 48 22 A6 03 BC BA 69 8E 81 11 B2 54 25 29 81 13 21 A8 1C 62 80 29 C9 55 1E 81 95 64 6A A7 2B 52 02 A3 B5 47 48 60 29 C0 52 18 F0 29 D8 A0 07 8A 75 00 2D 3B 14 00 B8 A7 62 98 0B B6 9D B6 90 0E 0B 4F DB 40 0B B2 9A 52 98 86 ED A3 6D 31 0F 55 A9 40 A6 23 BA 8A 3A B6 91 54 88 94 43 4E F2 28 19 1B 5B D4 2D 6D 40 09 F6 7F 6A 5F 22 98 0E F2 69 A6 0A 60 46 60 A8 8D BD 02 21 78 2A 9C B0 D0 33 3E 68 AA 84 8A 68 19 4A 50 6A 94 8B 48 0A EC 94 CC 52 18 B8 A7 01 48 63 F1 4E C5 00 3B 14 B8 A0 05 A7 D0 02 8A 75 00 3C 0A 78 14 C0 7E DA 90 2D 00 2E DA 69 5A 04 33 6D 1B 69 88 78 5A 7E DE 29 88 F4 38 A2 AB 89 15 49 25 85 86 A5 F2 28 18 D3 6F 51 35 BD 30 19 F6 7A 5F 22 80 0F 22 93 C8 A6 03 0D BD 31 A0 A0 0A D2 41 54 A5 82 80 33 E6 82 B2 EE 20 A0 66 74 B1 D5 29 23 A0 65 57 4A 84 8A 91 88 05 3F 14 86 3B 14 EA 00 5C 52 E2 80 1D 8A 70 A6 03 A9 C0 52 01 E0 54 80 50 21 EA 2A 60 B4 C6 04 53 71 40 86 ED A3 6D 31 0F 0B 4F DB C5 31 1E 97 14 55 76 38 AA 49 2C 05 A7 62 A8 61 8A 6E C1 40 C4 F2 C5 1E 58 A0 41 E5 8A 3C B1 40 86 F9 42 A3 78 68 02 A4 91 55 19 62 A0 0A 13 45 59 B3 C5 40 CC 99 E1 AC E9 12 82 8A 72 25 57 65 A9 18 CC 52 E2 81 8E A5 A0 05 A7 50 02 D3 A8 01 C2 9E 28 10 F1 52 0A 00 95 45 4C 07 14 0C 31 49 B6 80 13 65 38 25 32 49 02 54 9E 5F 14 C4 CF 50 8E 2C 54 E0 52 25 0B 45 32 C2 8A 00 28 A0 02 8A 00 28 34 08 AF 2A 55 19 63 A0 92 84 D1 D6 74 F1 D0 33 2A E2 2A CA 99 28 19 4A 44 AA 6E B4 86 47 B6 97 6D 21 8B 8A 5C 50 31 71 46 28 01 69 D4 00 E1 4E 14 08 90 54 82 80 27 4A 99 45 03 1F B6 8D 94 00 BB 29 C1 29 92 4A 12 9F B3 E5 A6 23 D3 85 2D 00 82 8A 06 14 50 01 45 00 14 50 01 45 00 21 15 5A 58 E8 20 A3 2C 75 9F 34 54 01 97 71 0D 63 DC 43 41 46 6C 89 54 E4 14 86 47 B2 8D B4 86 1B 69 71 40 06 DA 31 40 06 29 71 40 0B 8A 70 A0 09 05 48 B4 01 61 2A CA 2D 03 25 D9 4E D9 40 83 6D 38 25 31 13 2A 53 FC BF 96 98 99 E8 D4 50 30 A2 80 0A 28 00 A2 80 0A 28 00 A2 80 0A 42 28 13 2A CB 15 67 CD 15 04 99 D3 C3 59 77 36 F4 0C C5 B9 83 15 9A EB CD 22 86 6D A5 DB 48 04 DB 46 DA 00 4C 51 8A 00 31 49 8A 06 2E 29 71 40 0F 15 22 D0 05 98 C5 5D 8D 28 19 60 25 3B 65 02 0F 2E A5 48 69 88 98 45 4E 31 FC B4 C9 67 77 45 05 05 14 00 51 40 05 14 00 51 40 05 14 00 51 40 0D 65 AA 92 C7 41 06 7C D1 D6 6D C4 54 0C C7 BA 8A B1 A5 87 06 91 44 1B 29 36 D2 18 6D A4 DB 40 84 DB 49 8A 00 6E 28 C5 00 18 A5 02 81 8F C5 48 A2 80 2E C2 95 A3 0C 54 0C 9F 65 3B 65 32 47 AC 55 60 26 29 80 E0 94 32 7C B4 10 76 34 50 58 51 40 05 14 00 51 40 05 14 00 51 40 05 14 00 53 1D 68 13 28 4C 95 9B 3A 50 23 26 E6 3A CA 9A 2A 45 14 9E 3A 8B 6D 21 89 B6 93 6D 00 26 DA 4D B4 00 DD B4 6C A0 03 65 2E CA 00 78 4A 95 23 A0 66 9D BC 35 7D 52 81 12 04 A9 04 74 C4 4A B1 D4 A2 3A 62 1D B2 87 4F 90 D0 49 D4 51 41 61 45 00 14 50 01 45 00 14 50 01 45 00 14 50 01 41 A0 0A B3 2D 66 CC B4 12 66 CE 95 99 3C 74 8A 33 A4 4A AE 56 A4 A1 B8 A4 C5 00 26 DA 4D B4 C0 36 D2 EC A0 05 11 53 C4 34 01 2A DB D5 98 AD A8 03 4A 28 6A DA C3 4C 92 75 82 A5 10 53 02 41 0D 3B CA A0 41 E5 D3 64 4F 90 D0 49 BF 45 05 85 14 00 51 40 05 14 00 51 40 05 14 00 51 40 05 14 01 1C 83 22 B3 A6 5A 09 33 E6 5A CD 9D 69 14 66 4C B5 4D 85 48 C8 E9 28 18 94 B8 A0 07 05 A9 02 D0 04 CB 1D 4E 90 D3 02 C2 43 56 A3 86 98 8B D1 C3 56 92 2A 62 27 58 AA 51 15 02 1F E5 51 E5 50 21 3C AA 8E 48 FF 00 76 68 11 FF D9*/
....................     // char cam_response; 
....................     // fprintf(CAM, "f247");
....................     // fprintf(EXT, "CAM1 RETREAT COMMAND SENT\n");
....................     // fprintf(EXT, "Waiting for CAM response...\n");
....................     // //take the response from the camera and print it to EXT
....................     // cam_response = fgetc(CAM);
....................     // while(cam_response != 'K') {
....................     //     cam_response = fgetc(CAM);
....................     // }
....................     CAM_MISSION_MAIN(1, 247);
04B20:  MOVLW  01
04B22:  MOVLB  1
04B24:  MOVWF  xC0
04B26:  MOVLW  F7
04B28:  MOVWF  xC1
04B2A:  MOVLB  0
04B2C:  GOTO   22D0
.................... 
....................     
.................... 
.................... 
.................... 
....................     //------------------------MAIN_MENU-------------------------------
....................     while (TRUE) {
....................         if (kbhit(EXT)) {
04B30:  BTFSC  F82.7
04B32:  BRA    4B36
....................             main_menu();
04B34:  BRA    4666
....................             //  LOOP_DC_STATUS_ADDRESS();
....................             // fprintf(EXT, "%d\n",FLAG_DATA_ADDRESS_END);
....................         }
04B36:  BRA    4B30
....................     }
.................... }
04B38:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF02   PR SOSC_DIG NOCLOCKOUT NOIESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT_ DSWDT DSWDTOSC_INT
