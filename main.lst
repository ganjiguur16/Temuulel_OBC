CCS PCH C Compiler, Version 5.112, 5967               29-Apr-25 21:37

               Filename:   C:\Users\ganga\OneDrive\Documents\------TEMUULEL------\TEST_REPORT\Enginering model\CODE\VSbased development\OBC\main.lst

               ROM used:   18402 bytes (14%)
                           Largest free fragment is 65520
               RAM used:   434 (12%) at main() level
                           764 (21%) worst case
               Stack used: 4 locations
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   44EC
.................... #include <main.h>
.................... /* 
....................  * File:   main.h
....................  * Author: Ganji
....................  *
....................  * Created on October 22, 2024, 3:31 PM
....................  */
.................... 
....................  #ifndef MAIN_H
....................  #define	MAIN_H
....................  
....................  #ifdef	__cplusplus
....................  extern "C" {
....................  #endif
.................... 
....................  #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
00006:  DATA 57,52
00008:  DATA 49,54
0000A:  DATA 45,20
0000C:  DATA 41,44
0000E:  DATA 44,52
00010:  DATA 45,53
00012:  DATA 53,3A
00014:  DATA 20,30
00016:  DATA 78,25
00018:  DATA 30,38
0001A:  DATA 6C,78
0001C:  DATA 0A,00
0001E:  DATA 0A,25
00020:  DATA 64,20
00022:  DATA 42,59
00024:  DATA 54,45
00026:  DATA 53,20
00028:  DATA 57,52
0002A:  DATA 49,54
0002C:  DATA 54,45
0002E:  DATA 4E,20
00030:  DATA 49,4E
00032:  DATA 20,4D
00034:  DATA 41,49
00036:  DATA 4E,21
00038:  DATA 0A,00
0003A:  DATA 57,52
0003C:  DATA 49,54
0003E:  DATA 45,20
00040:  DATA 41,44
00042:  DATA 44,52
00044:  DATA 45,53
00046:  DATA 53,20
00048:  DATA 49,4E
0004A:  DATA 20,43
0004C:  DATA 4F,4D
0004E:  DATA 3A,20
00050:  DATA 30,78
00052:  DATA 25,30
00054:  DATA 38,6C
00056:  DATA 78,0A
00058:  DATA 00,00
0005A:  DATA 0A,25
0005C:  DATA 64,20
0005E:  DATA 42,59
00060:  DATA 54,45
00062:  DATA 53,20
00064:  DATA 57,52
00066:  DATA 49,54
00068:  DATA 54,45
0006A:  DATA 4E,20
0006C:  DATA 49,4E
0006E:  DATA 20,43
00070:  DATA 4F,4D
00072:  DATA 21,0A
00074:  DATA 00,00
00076:  DATA 57,52
00078:  DATA 49,54
0007A:  DATA 45,20
0007C:  DATA 41,44
0007E:  DATA 44,52
00080:  DATA 45,53
00082:  DATA 53,20
00084:  DATA 49,4E
00086:  DATA 20,41
00088:  DATA 44,43
0008A:  DATA 53,3A
0008C:  DATA 20,30
0008E:  DATA 78,25
00090:  DATA 30,38
00092:  DATA 6C,78
00094:  DATA 0A,00
00096:  DATA 0A,25
00098:  DATA 64,20
0009A:  DATA 42,59
0009C:  DATA 54,45
0009E:  DATA 53,20
000A0:  DATA 57,52
000A2:  DATA 49,54
000A4:  DATA 54,45
000A6:  DATA 4E,20
000A8:  DATA 49,4E
000AA:  DATA 20,41
000AC:  DATA 44,43
000AE:  DATA 53,21
000B0:  DATA 0A,00
000B2:  DATA 20,20
000B4:  DATA 30,78
000B6:  DATA 25,30
000B8:  DATA 32,78
000BA:  DATA 00,00
000BC:  DATA 50,4F
000BE:  DATA 57,45
000C0:  DATA 52,20
000C2:  DATA 4F,4E
000C4:  DATA 21,0A
000C6:  DATA 00,00
000C8:  DATA 44,69
000CA:  DATA 67,69
000CC:  DATA 74,61
000CE:  DATA 6C,20
000D0:  DATA 70,69
000D2:  DATA 6E,20
000D4:  DATA 6F,75
000D6:  DATA 74,20
000D8:  DATA 63,6F
000DA:  DATA 6E,66
000DC:  DATA 69,67
000DE:  DATA 75,72
000E0:  DATA 65,64
000E2:  DATA 20,0A
000E4:  DATA 00,00
000E6:  DATA 0D,25
000E8:  DATA 30,32
000EA:  DATA 75,2F
000EC:  DATA 25,30
000EE:  DATA 32,75
000F0:  DATA 2F,32
000F2:  DATA 30,25
000F4:  DATA 30,32
000F6:  DATA 75,20
000F8:  DATA 25,30
000FA:  DATA 32,75
000FC:  DATA 3A,25
000FE:  DATA 30,32
00100:  DATA 75,3A
00102:  DATA 25,30
00104:  DATA 32,75
00106:  DATA 00,00
00108:  DATA 52,54
0010A:  DATA 43,43
0010C:  DATA 20,73
0010E:  DATA 65,74
00110:  DATA 75,70
00112:  DATA 20,66
00114:  DATA 69,6E
00116:  DATA 69,73
00118:  DATA 68,65
0011A:  DATA 64,21
0011C:  DATA 0A,00
0011E:  DATA 52,54
00120:  DATA 43,43
00122:  DATA 20,73
00124:  DATA 65,74
00126:  DATA 75,70
00128:  DATA 20,66
0012A:  DATA 69,6E
0012C:  DATA 69,73
0012E:  DATA 68,65
00130:  DATA 64,21
00132:  DATA 0A,00
00134:  DATA 64,65
00136:  DATA 6C,65
00138:  DATA 74,69
0013A:  DATA 6E,67
0013C:  DATA 20,63
0013E:  DATA 6F,6D
00140:  DATA 6D,61
00142:  DATA 6E,64
00144:  DATA 20,61
00146:  DATA 64,64
00148:  DATA 72,65
0014A:  DATA 73,73
0014C:  DATA 20,6F
0014E:  DATA 66,20
00150:  DATA 74,68
00152:  DATA 65,20
00154:  DATA 61,64
00156:  DATA 63,73
00158:  DATA 0A,00
0015A:  DATA 43,6F
0015C:  DATA 6D,6D
0015E:  DATA 61,6E
00160:  DATA 64,20
00162:  DATA 61,64
00164:  DATA 64,72
00166:  DATA 65,73
00168:  DATA 73,20
0016A:  DATA 6F,66
0016C:  DATA 20,74
0016E:  DATA 68,65
00170:  DATA 20,61
00172:  DATA 64,63
00174:  DATA 73,20
00176:  DATA 69,73
00178:  DATA 20,64
0017A:  DATA 65,6C
0017C:  DATA 65,74
0017E:  DATA 65,64
00180:  DATA 21,0A
00182:  DATA 00,00
00184:  DATA 53,65
00186:  DATA 6E,64
00188:  DATA 69,6E
0018A:  DATA 67,20
0018C:  DATA 63,6F
0018E:  DATA 6D,6D
00190:  DATA 61,6E
00192:  DATA 64,20
00194:  DATA 74,6F
00196:  DATA 20,74
00198:  DATA 68,65
0019A:  DATA 20,61
0019C:  DATA 64,63
0019E:  DATA 73,0A
001A0:  DATA 00,00
001A2:  DATA 53,74
001A4:  DATA 61,72
001A6:  DATA 74,69
001A8:  DATA 6E,67
001AA:  DATA 20,74
001AC:  DATA 6F,20
001AE:  DATA 77,72
001B0:  DATA 69,74
001B2:  DATA 65,20
001B4:  DATA 64,61
001B6:  DATA 74,61
001B8:  DATA 20,69
001BA:  DATA 6E,20
001BC:  DATA 41,44
001BE:  DATA 43,53
001C0:  DATA 20,66
001C2:  DATA 6C,61
001C4:  DATA 73,68
001C6:  DATA 20,6D
001C8:  DATA 65,6D
001CA:  DATA 6F,72
001CC:  DATA 79,0A
001CE:  DATA 00,00
001D0:  DATA 41,44
001D2:  DATA 43,53
001D4:  DATA 20,63
001D6:  DATA 6F,6D
001D8:  DATA 6D,61
001DA:  DATA 6E,64
001DC:  DATA 20,69
001DE:  DATA 73,20
001E0:  DATA 77,72
001E2:  DATA 69,74
001E4:  DATA 74,65
001E6:  DATA 6E,21
001E8:  DATA 0A,00
001EA:  DATA 77,61
001EC:  DATA 69,74
001EE:  DATA 69,6E
001F0:  DATA 67,20
001F2:  DATA 66,6F
001F4:  DATA 72,20
001F6:  DATA 61,64
001F8:  DATA 63,73
001FA:  DATA 20,74
001FC:  DATA 6F,20
001FE:  DATA 66,69
00200:  DATA 6E,69
00202:  DATA 73,68
00204:  DATA 20,37
00206:  DATA 30,73
00208:  DATA 2F,25
0020A:  DATA 64,30
0020C:  DATA 73,0A
0020E:  DATA 00,00
00210:  DATA 41,44
00212:  DATA 43,53
00214:  DATA 20,63
00216:  DATA 6F,6D
00218:  DATA 6D,61
0021A:  DATA 6E,64
0021C:  DATA 20,69
0021E:  DATA 73,20
00220:  DATA 66,69
00222:  DATA 6E,69
00224:  DATA 73,68
00226:  DATA 65,64
00228:  DATA 21,0A
0022A:  DATA 00,00
0022C:  DATA 72,65
0022E:  DATA 61,64
00230:  DATA 69,6E
00232:  DATA 67,20
00234:  DATA 74,68
00236:  DATA 65,20
00238:  DATA 73,74
0023A:  DATA 61,74
0023C:  DATA 75,73
0023E:  DATA 20,61
00240:  DATA 64,64
00242:  DATA 72,65
00244:  DATA 73,73
00246:  DATA 20,6F
00248:  DATA 66,20
0024A:  DATA 74,68
0024C:  DATA 65,20
0024E:  DATA 61,64
00250:  DATA 63,73
00252:  DATA 21,0A
00254:  DATA 00,00
00256:  DATA 41,44
00258:  DATA 43,53
0025A:  DATA 20,73
0025C:  DATA 74,61
0025E:  DATA 74,75
00260:  DATA 73,3A
00262:  DATA 20,25
00264:  DATA 64,2C
00266:  DATA 20,6C
00268:  DATA 61,73
0026A:  DATA 74,20
0026C:  DATA 61,64
0026E:  DATA 64,72
00270:  DATA 65,73
00272:  DATA 73,3A
00274:  DATA 20,30
00276:  DATA 78,25
00278:  DATA 30,38
0027A:  DATA 78,0A
0027C:  DATA 00,00
0027E:  DATA 41,44
00280:  DATA 43,53
00282:  DATA 20,6D
00284:  DATA 69,73
00286:  DATA 73,69
00288:  DATA 6F,6E
0028A:  DATA 20,66
0028C:  DATA 61,69
0028E:  DATA 6C,65
00290:  DATA 64,21
00292:  DATA 0A,00
00294:  DATA 41,44
00296:  DATA 43,53
00298:  DATA 20,6D
0029A:  DATA 69,73
0029C:  DATA 73,69
0029E:  DATA 6F,6E
002A0:  DATA 20,66
002A2:  DATA 61,69
002A4:  DATA 6C,65
002A6:  DATA 64,21
002A8:  DATA 0A,00
002AA:  DATA 41,44
002AC:  DATA 43,53
002AE:  DATA 20,6D
002B0:  DATA 69,73
002B2:  DATA 73,69
002B4:  DATA 6F,6E
002B6:  DATA 20,73
002B8:  DATA 75,63
002BA:  DATA 63,65
002BC:  DATA 73,73
002BE:  DATA 20,77
002C0:  DATA 69,74
002C2:  DATA 68,20
002C4:  DATA 25,64
002C6:  DATA 20,6D
002C8:  DATA 65,61
002CA:  DATA 73,75
002CC:  DATA 72,65
002CE:  DATA 6D,65
002D0:  DATA 6E,74
002D2:  DATA 73,21
002D4:  DATA 0A,00
002D6:  DATA 46,69
002D8:  DATA 72,73
002DA:  DATA 74,20
002DC:  DATA 64,61
002DE:  DATA 74,61
002E0:  DATA 20,61
002E2:  DATA 64,64
002E4:  DATA 72,65
002E6:  DATA 73,73
002E8:  DATA 3A,20
002EA:  DATA 30,78
002EC:  DATA 25,30
002EE:  DATA 38,78
002F0:  DATA 0A,00
002F2:  DATA 4D,65
002F4:  DATA 61,73
002F6:  DATA 75,72
002F8:  DATA 65,6D
002FA:  DATA 65,6E
002FC:  DATA 74,20
002FE:  DATA 25,64
00300:  DATA 20,61
00302:  DATA 74,20
00304:  DATA 61,64
00306:  DATA 64,72
00308:  DATA 65,73
0030A:  DATA 73,20
0030C:  DATA 30,78
0030E:  DATA 25,30
00310:  DATA 38,78
00312:  DATA 3A,20
00314:  DATA 00,00
00316:  DATA 53,68
00318:  DATA 75,74
0031A:  DATA 64,6F
0031C:  DATA 77,6E
0031E:  DATA 20,63
00320:  DATA 6F,75
00322:  DATA 6E,74
00324:  DATA 20,73
00326:  DATA 74,61
00328:  DATA 72,74
0032A:  DATA 65,64
0032C:  DATA 0A,00
0032E:  DATA 52,65
00330:  DATA 61,64
00332:  DATA 20,73
00334:  DATA 68,75
00336:  DATA 74,64
00338:  DATA 6F,77
0033A:  DATA 6E,20
0033C:  DATA 63,6F
0033E:  DATA 75,6E
00340:  DATA 74,3A
00342:  DATA 20,25
00344:  DATA 75,0A
00346:  DATA 00,00
00348:  DATA 49,6E
0034A:  DATA 63,72
0034C:  DATA 65,6D
0034E:  DATA 65,6E
00350:  DATA 74,65
00352:  DATA 64,20
00354:  DATA 73,68
00356:  DATA 75,74
00358:  DATA 64,6F
0035A:  DATA 77,6E
0035C:  DATA 20,63
0035E:  DATA 6F,75
00360:  DATA 6E,74
00362:  DATA 3A,20
00364:  DATA 25,75
00366:  DATA 0A,00
00368:  DATA 4E,6F
0036A:  DATA 77,20
0036C:  DATA 73,68
0036E:  DATA 75,74
00370:  DATA 64,6F
00372:  DATA 77,6E
00374:  DATA 20,63
00376:  DATA 6F,75
00378:  DATA 6E,74
0037A:  DATA 20,69
0037C:  DATA 73,20
0037E:  DATA 3A,20
00380:  DATA 25,75
00382:  DATA 0A,0A
00384:  DATA 00,00
00386:  DATA 0A,45
00388:  DATA 6E,74
0038A:  DATA 65,72
0038C:  DATA 20,41
0038E:  DATA 64,64
00390:  DATA 72,65
00392:  DATA 73,73
00394:  DATA 20,28
00396:  DATA 68,65
00398:  DATA 78,2C
0039A:  DATA 20,30
0039C:  DATA 78,31
0039E:  DATA 32,33
003A0:  DATA 34,29
003A2:  DATA 3A,20
003A4:  DATA 30,78
003A6:  DATA 00,00
003A8:  DATA 0A,45
003AA:  DATA 6E,74
003AC:  DATA 65,72
003AE:  DATA 20,6E
003B0:  DATA 75,6D
003B2:  DATA 62,65
003B4:  DATA 72,20
003B6:  DATA 6F,66
003B8:  DATA 20,62
003BA:  DATA 79,74
003BC:  DATA 65,73
003BE:  DATA 20,74
003C0:  DATA 6F,20
003C2:  DATA 77,72
003C4:  DATA 69,74
003C6:  DATA 65,20
003C8:  DATA 28,6D
003CA:  DATA 61,78
003CC:  DATA 20,32
003CE:  DATA 35,36
003D0:  DATA 29,3A
003D2:  DATA 20,00
003D4:  DATA 45,6E
003D6:  DATA 74,65
003D8:  DATA 72,20
003DA:  DATA 25,64
003DC:  DATA 20,62
003DE:  DATA 79,74
003E0:  DATA 65,73
003E2:  DATA 20,6F
003E4:  DATA 66,20
003E6:  DATA 64,61
003E8:  DATA 74,61
003EA:  DATA 20,28
003EC:  DATA 69,6E
003EE:  DATA 20,68
003F0:  DATA 65,78
003F2:  DATA 29,3A
003F4:  DATA 0A,00
003F6:  DATA 42,79
003F8:  DATA 74,65
003FA:  DATA 20,25
003FC:  DATA 64,3A
003FE:  DATA 20,30
00400:  DATA 78,00
00402:  DATA 0A,44
00404:  DATA 61,74
00406:  DATA 61,20
00408:  DATA 73,75
0040A:  DATA 63,63
0040C:  DATA 65,73
0040E:  DATA 73,66
00410:  DATA 75,6C
00412:  DATA 6C,79
00414:  DATA 20,77
00416:  DATA 72,69
00418:  DATA 74,74
0041A:  DATA 65,6E
0041C:  DATA 2E,0A
0041E:  DATA 00,00
00420:  DATA 4D,41
00422:  DATA 49,4E
00424:  DATA 20,66
00426:  DATA 6C,61
00428:  DATA 73,68
0042A:  DATA 20,6D
0042C:  DATA 65,6D
0042E:  DATA 6F,72
00430:  DATA 79,20
00432:  DATA 63,68
00434:  DATA 6F,73
00436:  DATA 65,6E
00438:  DATA 0A,00
0043A:  DATA 70,72
0043C:  DATA 65,73
0043E:  DATA 73,20
00440:  DATA 61,3A
00442:  DATA 20,52
00444:  DATA 65,61
00446:  DATA 64,20
00448:  DATA 49,44
0044A:  DATA 20,6F
0044C:  DATA 66,20
0044E:  DATA 74,68
00450:  DATA 65,20
00452:  DATA 63,68
00454:  DATA 69,70
00456:  DATA 0A,00
00458:  DATA 70,72
0045A:  DATA 65,73
0045C:  DATA 73,20
0045E:  DATA 62,3A
00460:  DATA 20,57
00462:  DATA 72,69
00464:  DATA 74,65
00466:  DATA 20,64
00468:  DATA 61,74
0046A:  DATA 61,20
0046C:  DATA 73,65
0046E:  DATA 74,20
00470:  DATA 69,6E
00472:  DATA 20,73
00474:  DATA 70,65
00476:  DATA 63,69
00478:  DATA 66,69
0047A:  DATA 65,64
0047C:  DATA 20,61
0047E:  DATA 64,64
00480:  DATA 72,65
00482:  DATA 73,73
00484:  DATA 0A,00
00486:  DATA 70,72
00488:  DATA 65,73
0048A:  DATA 73,20
0048C:  DATA 63,3A
0048E:  DATA 20,52
00490:  DATA 65,61
00492:  DATA 64,20
00494:  DATA 64,61
00496:  DATA 74,61
00498:  DATA 20,73
0049A:  DATA 65,74
0049C:  DATA 20,69
0049E:  DATA 6E,20
004A0:  DATA 73,70
004A2:  DATA 65,63
004A4:  DATA 69,66
004A6:  DATA 69,65
004A8:  DATA 64,20
004AA:  DATA 61,64
004AC:  DATA 64,72
004AE:  DATA 65,73
004B0:  DATA 73,0A
004B2:  DATA 00,00
004B4:  DATA 70,72
004B6:  DATA 65,73
004B8:  DATA 73,20
004BA:  DATA 78,3A
004BC:  DATA 20,52
004BE:  DATA 65,74
004C0:  DATA 75,72
004C2:  DATA 6E,20
004C4:  DATA 74,6F
004C6:  DATA 20,4D
004C8:  DATA 41,49
004CA:  DATA 4E,20
004CC:  DATA 4D,45
004CE:  DATA 4E,55
004D0:  DATA 0A,00
004D2:  DATA 53,74
004D4:  DATA 61,72
004D6:  DATA 74,65
004D8:  DATA 64,20
004DA:  DATA 72,65
004DC:  DATA 61,64
004DE:  DATA 69,6E
004E0:  DATA 67,20
004E2:  DATA 63,68
004E4:  DATA 69,70
004E6:  DATA 20,49
004E8:  DATA 44,20
004EA:  DATA 6F,66
004EC:  DATA 20,4D
004EE:  DATA 41,49
004F0:  DATA 4E,20
004F2:  DATA 66,6C
004F4:  DATA 61,73
004F6:  DATA 68,20
004F8:  DATA 6D,65
004FA:  DATA 6D,6F
004FC:  DATA 72,79
004FE:  DATA 0A,00
00500:  DATA 52,65
00502:  DATA 61,64
00504:  DATA 20,64
00506:  DATA 61,74
00508:  DATA 61,20
0050A:  DATA 73,65
0050C:  DATA 74,20
0050E:  DATA 69,6E
00510:  DATA 20,73
00512:  DATA 70,65
00514:  DATA 63,69
00516:  DATA 66,69
00518:  DATA 65,64
0051A:  DATA 20,61
0051C:  DATA 64,64
0051E:  DATA 72,65
00520:  DATA 73,73
00522:  DATA 0A,00
00524:  DATA 45,6E
00526:  DATA 74,65
00528:  DATA 72,20
0052A:  DATA 79,6F
0052C:  DATA 75,72
0052E:  DATA 20,73
00530:  DATA 70,65
00532:  DATA 63,69
00534:  DATA 66,69
00536:  DATA 65,64
00538:  DATA 20,61
0053A:  DATA 64,64
0053C:  DATA 72,65
0053E:  DATA 73,73
00540:  DATA 20,61
00542:  DATA 6E,64
00544:  DATA 20,6C
00546:  DATA 65,6E
00548:  DATA 67,74
0054A:  DATA 68,20
0054C:  DATA 28,65
0054E:  DATA 2E,67
00550:  DATA 2E,2C
00552:  DATA 20,30
00554:  DATA 78,31
00556:  DATA 32,33
00558:  DATA 34,20
0055A:  DATA 31,30
0055C:  DATA 29,3A
0055E:  DATA 20,00
00560:  DATA 41,64
00562:  DATA 64,72
00564:  DATA 65,73
00566:  DATA 73,3A
00568:  DATA 20,30
0056A:  DATA 78,25
0056C:  DATA 30,39
0056E:  DATA 78,2C
00570:  DATA 20,4C
00572:  DATA 65,6E
00574:  DATA 67,74
00576:  DATA 68,3A
00578:  DATA 20,25
0057A:  DATA 64,0A
0057C:  DATA 00,00
0057E:  DATA 49,6E
00580:  DATA 76,61
00582:  DATA 6C,69
00584:  DATA 64,20
00586:  DATA 69,6E
00588:  DATA 70,75
0058A:  DATA 74,2E
0058C:  DATA 20,50
0058E:  DATA 6C,65
00590:  DATA 61,73
00592:  DATA 65,20
00594:  DATA 65,6E
00596:  DATA 74,65
00598:  DATA 72,20
0059A:  DATA 61,20
0059C:  DATA 76,61
0059E:  DATA 6C,69
005A0:  DATA 64,20
005A2:  DATA 61,64
005A4:  DATA 64,72
005A6:  DATA 65,73
005A8:  DATA 73,20
005AA:  DATA 61,6E
005AC:  DATA 64,20
005AE:  DATA 6C,65
005B0:  DATA 6E,67
005B2:  DATA 74,68
005B4:  DATA 2E,0A
005B6:  DATA 00,00
005B8:  DATA 49,6E
005BA:  DATA 76,61
005BC:  DATA 6C,69
005BE:  DATA 64,20
005C0:  DATA 4D,41
005C2:  DATA 49,4E
005C4:  DATA 20,66
005C6:  DATA 6C,61
005C8:  DATA 73,68
005CA:  DATA 20,6D
005CC:  DATA 65,6D
005CE:  DATA 6F,72
005D0:  DATA 79,20
005D2:  DATA 6F,70
005D4:  DATA 74,69
005D6:  DATA 6F,6E
005D8:  DATA 2E,20
005DA:  DATA 50,6C
005DC:  DATA 65,61
005DE:  DATA 73,65
005E0:  DATA 20,74
005E2:  DATA 72,79
005E4:  DATA 20,61
005E6:  DATA 67,61
005E8:  DATA 69,6E
005EA:  DATA 2E,0A
005EC:  DATA 00,00
005EE:  DATA 70,72
005F0:  DATA 65,73
005F2:  DATA 73,65
005F4:  DATA 64,20
005F6:  DATA 6F,70
005F8:  DATA 74,69
005FA:  DATA 6F,6E
005FC:  DATA 20,64
005FE:  DATA 3A,20
00600:  DATA 43,68
00602:  DATA 65,63
00604:  DATA 6B,20
00606:  DATA 46,6C
00608:  DATA 61,73
0060A:  DATA 68,20
0060C:  DATA 4D,65
0060E:  DATA 6D,6F
00610:  DATA 72,69
00612:  DATA 65,73
00614:  DATA 0A,0A
00616:  DATA 00,00
00618:  DATA 50,6C
0061A:  DATA 65,61
0061C:  DATA 73,65
0061E:  DATA 20,63
00620:  DATA 68,6F
00622:  DATA 6F,73
00624:  DATA 65,20
00626:  DATA 77,68
00628:  DATA 69,63
0062A:  DATA 68,20
0062C:  DATA 66,6C
0062E:  DATA 61,73
00630:  DATA 68,20
00632:  DATA 6D,65
00634:  DATA 6D,6F
00636:  DATA 72,79
00638:  DATA 20,74
0063A:  DATA 6F,20
0063C:  DATA 77,6F
0063E:  DATA 72,6B
00640:  DATA 20,6F
00642:  DATA 6E,20
00644:  DATA 28,61
00646:  DATA 2C,20
00648:  DATA 62,2C
0064A:  DATA 20,63
0064C:  DATA 2C,20
0064E:  DATA 64,2C
00650:  DATA 20,65
00652:  DATA 29,3A
00654:  DATA 0A,00
00656:  DATA 70,72
00658:  DATA 65,73
0065A:  DATA 73,20
0065C:  DATA 61,3A
0065E:  DATA 20,4D
00660:  DATA 41,49
00662:  DATA 4E,20
00664:  DATA 66,6C
00666:  DATA 61,73
00668:  DATA 68,20
0066A:  DATA 6D,65
0066C:  DATA 6D,6F
0066E:  DATA 72,79
00670:  DATA 0A,00
00672:  DATA 70,72
00674:  DATA 65,73
00676:  DATA 73,20
00678:  DATA 62,3A
0067A:  DATA 20,43
0067C:  DATA 4F,4D
0067E:  DATA 20,73
00680:  DATA 68,61
00682:  DATA 72,65
00684:  DATA 64,20
00686:  DATA 66,6C
00688:  DATA 61,73
0068A:  DATA 68,20
0068C:  DATA 6D,65
0068E:  DATA 6D,6F
00690:  DATA 72,79
00692:  DATA 0A,00
00694:  DATA 70,72
00696:  DATA 65,73
00698:  DATA 73,20
0069A:  DATA 63,3A
0069C:  DATA 20,41
0069E:  DATA 44,43
006A0:  DATA 53,20
006A2:  DATA 73,68
006A4:  DATA 61,72
006A6:  DATA 65,64
006A8:  DATA 20,66
006AA:  DATA 6C,61
006AC:  DATA 73,68
006AE:  DATA 20,6D
006B0:  DATA 65,6D
006B2:  DATA 6F,72
006B4:  DATA 79,0A
006B6:  DATA 00,00
006B8:  DATA 70,72
006BA:  DATA 65,73
006BC:  DATA 73,20
006BE:  DATA 64,3A
006C0:  DATA 20,4F
006C2:  DATA 56,43
006C4:  DATA 41,4D
006C6:  DATA 20,73
006C8:  DATA 68,61
006CA:  DATA 72,65
006CC:  DATA 64,20
006CE:  DATA 66,6C
006D0:  DATA 61,73
006D2:  DATA 68,20
006D4:  DATA 6D,65
006D6:  DATA 6D,6F
006D8:  DATA 72,79
006DA:  DATA 0A,00
006DC:  DATA 70,72
006DE:  DATA 65,73
006E0:  DATA 73,20
006E2:  DATA 65,3A
006E4:  DATA 20,4D
006E6:  DATA 56,43
006E8:  DATA 41,4D
006EA:  DATA 20,73
006EC:  DATA 68,61
006EE:  DATA 72,65
006F0:  DATA 64,20
006F2:  DATA 66,6C
006F4:  DATA 61,73
006F6:  DATA 68,20
006F8:  DATA 6D,65
006FA:  DATA 6D,6F
006FC:  DATA 72,79
006FE:  DATA 0A,00
00700:  DATA 70,72
00702:  DATA 65,73
00704:  DATA 73,20
00706:  DATA 78,3A
00708:  DATA 20,52
0070A:  DATA 65,74
0070C:  DATA 75,72
0070E:  DATA 6E,20
00710:  DATA 74,6F
00712:  DATA 20,4D
00714:  DATA 41,49
00716:  DATA 4E,20
00718:  DATA 4D,45
0071A:  DATA 4E,55
0071C:  DATA 0A,00
0071E:  DATA 4D,41
00720:  DATA 49,4E
00722:  DATA 20,73
00724:  DATA 68,61
00726:  DATA 72,65
00728:  DATA 64,20
0072A:  DATA 66,6C
0072C:  DATA 61,73
0072E:  DATA 68,20
00730:  DATA 6D,65
00732:  DATA 6D,6F
00734:  DATA 72,79
00736:  DATA 20,63
00738:  DATA 68,6F
0073A:  DATA 73,65
0073C:  DATA 6E,0A
0073E:  DATA 00,00
00740:  DATA 43,4F
00742:  DATA 4D,20
00744:  DATA 73,68
00746:  DATA 61,72
00748:  DATA 65,64
0074A:  DATA 20,66
0074C:  DATA 6C,61
0074E:  DATA 73,68
00750:  DATA 20,6D
00752:  DATA 65,6D
00754:  DATA 6F,72
00756:  DATA 79,20
00758:  DATA 63,68
0075A:  DATA 6F,73
0075C:  DATA 65,6E
0075E:  DATA 0A,00
00760:  DATA 41,44
00762:  DATA 43,53
00764:  DATA 20,73
00766:  DATA 68,61
00768:  DATA 72,65
0076A:  DATA 64,20
0076C:  DATA 66,6C
0076E:  DATA 61,73
00770:  DATA 68,20
00772:  DATA 6D,65
00774:  DATA 6D,6F
00776:  DATA 72,79
00778:  DATA 20,63
0077A:  DATA 68,6F
0077C:  DATA 73,65
0077E:  DATA 6E,0A
00780:  DATA 00,00
00782:  DATA 4F,56
00784:  DATA 43,41
00786:  DATA 4D,20
00788:  DATA 73,68
0078A:  DATA 61,72
0078C:  DATA 65,64
0078E:  DATA 20,66
00790:  DATA 6C,61
00792:  DATA 73,68
00794:  DATA 20,6D
00796:  DATA 65,6D
00798:  DATA 6F,72
0079A:  DATA 79,20
0079C:  DATA 63,68
0079E:  DATA 6F,73
007A0:  DATA 65,6E
007A2:  DATA 0A,00
007A4:  DATA 4D,56
007A6:  DATA 43,41
007A8:  DATA 4D,20
007AA:  DATA 73,68
007AC:  DATA 61,72
007AE:  DATA 65,64
007B0:  DATA 20,66
007B2:  DATA 6C,61
007B4:  DATA 73,68
007B6:  DATA 20,6D
007B8:  DATA 65,6D
007BA:  DATA 6F,72
007BC:  DATA 79,20
007BE:  DATA 63,68
007C0:  DATA 6F,73
007C2:  DATA 65,6E
007C4:  DATA 0A,00
007C6:  DATA 49,6E
007C8:  DATA 76,61
007CA:  DATA 6C,69
007CC:  DATA 64,20
007CE:  DATA 66,6C
007D0:  DATA 61,73
007D2:  DATA 68,20
007D4:  DATA 6D,65
007D6:  DATA 6D,6F
007D8:  DATA 72,79
007DA:  DATA 20,6F
007DC:  DATA 70,74
007DE:  DATA 69,6F
007E0:  DATA 6E,2E
007E2:  DATA 20,50
007E4:  DATA 6C,65
007E6:  DATA 61,73
007E8:  DATA 65,20
007EA:  DATA 74,72
007EC:  DATA 79,20
007EE:  DATA 61,67
007F0:  DATA 61,69
007F2:  DATA 6E,2E
007F4:  DATA 0A,00
007F6:  DATA 53,65
007F8:  DATA 74,74
007FA:  DATA 69,6E
007FC:  DATA 67,73
007FE:  DATA 20,6F
00800:  DATA 66,20
00802:  DATA 52,54
00804:  DATA 43,20
00806:  DATA 63,68
00808:  DATA 6F,73
0080A:  DATA 65,6E
0080C:  DATA 0A,00
0080E:  DATA 20,20
00810:  DATA 20,20
00812:  DATA 70,72
00814:  DATA 65,73
00816:  DATA 73,20
00818:  DATA 61,3A
0081A:  DATA 20,74
0081C:  DATA 6F,20
0081E:  DATA 72,65
00820:  DATA 73,65
00822:  DATA 74,20
00824:  DATA 74,68
00826:  DATA 65,20
00828:  DATA 52,54
0082A:  DATA 43,20
0082C:  DATA 2F,61
0082E:  DATA 6C,6C
00830:  DATA 20,63
00832:  DATA 75,72
00834:  DATA 72,65
00836:  DATA 6E,74
00838:  DATA 20,74
0083A:  DATA 69,6D
0083C:  DATA 65,20
0083E:  DATA 77,69
00840:  DATA 6C,6C
00842:  DATA 20,62
00844:  DATA 65,20
00846:  DATA 73,65
00848:  DATA 74,20
0084A:  DATA 7A,65
0084C:  DATA 72,6F
0084E:  DATA 2F,0A
00850:  DATA 00,00
00852:  DATA 20,20
00854:  DATA 20,20
00856:  DATA 70,72
00858:  DATA 65,73
0085A:  DATA 73,20
0085C:  DATA 62,3A
0085E:  DATA 20,64
00860:  DATA 69,73
00862:  DATA 70,6C
00864:  DATA 61,79
00866:  DATA 20,63
00868:  DATA 75,72
0086A:  DATA 72,65
0086C:  DATA 6E,74
0086E:  DATA 20,74
00870:  DATA 69,6D
00872:  DATA 65,0A
00874:  DATA 00,00
00876:  DATA 20,20
00878:  DATA 20,20
0087A:  DATA 70,72
0087C:  DATA 65,73
0087E:  DATA 73,20
00880:  DATA 63,3A
00882:  DATA 20,64
00884:  DATA 69,73
00886:  DATA 70,6C
00888:  DATA 61,79
0088A:  DATA 20,63
0088C:  DATA 75,72
0088E:  DATA 72,65
00890:  DATA 6E,74
00892:  DATA 20,74
00894:  DATA 69,6D
00896:  DATA 65,20
00898:  DATA 6E,6F
0089A:  DATA 6E,73
0089C:  DATA 74,6F
0089E:  DATA 70,0A
008A0:  DATA 00,00
008A2:  DATA 4E,6F
008A4:  DATA 77,20
008A6:  DATA 74,69
008A8:  DATA 6D,65
008AA:  DATA 20,69
008AC:  DATA 73,0A
008AE:  DATA 00,00
008B0:  DATA 0D,25
008B2:  DATA 30,32
008B4:  DATA 75,2F
008B6:  DATA 25,30
008B8:  DATA 32,75
008BA:  DATA 2F,32
008BC:  DATA 30,25
008BE:  DATA 30,32
008C0:  DATA 75,20
008C2:  DATA 25,30
008C4:  DATA 32,75
008C6:  DATA 3A,25
008C8:  DATA 30,32
008CA:  DATA 75,3A
008CC:  DATA 25,30
008CE:  DATA 32,75
008D0:  DATA 00,00
008D2:  DATA 54,69
008D4:  DATA 6D,65
008D6:  DATA 20,63
008D8:  DATA 68,61
008DA:  DATA 6E,67
008DC:  DATA 69,6E
008DE:  DATA 67,20
008E0:  DATA 66,75
008E2:  DATA 6E,63
008E4:  DATA 74,69
008E6:  DATA 6F,6E
008E8:  DATA 20,61
008EA:  DATA 63,74
008EC:  DATA 69,76
008EE:  DATA 61,74
008F0:  DATA 65,64
008F2:  DATA 0A,00
008F4:  DATA 54,69
008F6:  DATA 6D,65
008F8:  DATA 20,73
008FA:  DATA 75,63
008FC:  DATA 63,65
008FE:  DATA 73,73
00900:  DATA 66,75
00902:  DATA 6C,6C
00904:  DATA 79,20
00906:  DATA 63,68
00908:  DATA 61,6E
0090A:  DATA 67,65
0090C:  DATA 64,2E
0090E:  DATA 20,43
00910:  DATA 75,72
00912:  DATA 72,65
00914:  DATA 6E,74
00916:  DATA 20,74
00918:  DATA 69,6D
0091A:  DATA 65,20
0091C:  DATA 69,73
0091E:  DATA 3A,0A
00920:  DATA 00,00
00922:  DATA 0D,25
00924:  DATA 30,32
00926:  DATA 75,2F
00928:  DATA 25,30
0092A:  DATA 32,75
0092C:  DATA 2F,32
0092E:  DATA 30,25
00930:  DATA 30,32
00932:  DATA 75,20
00934:  DATA 25,30
00936:  DATA 32,75
00938:  DATA 3A,25
0093A:  DATA 30,32
0093C:  DATA 75,3A
0093E:  DATA 25,30
00940:  DATA 32,75
00942:  DATA 00,00
00944:  DATA 0D,25
00946:  DATA 30,32
00948:  DATA 75,2F
0094A:  DATA 25,30
0094C:  DATA 32,75
0094E:  DATA 2F,32
00950:  DATA 30,25
00952:  DATA 30,32
00954:  DATA 75,20
00956:  DATA 25,30
00958:  DATA 32,75
0095A:  DATA 3A,25
0095C:  DATA 30,32
0095E:  DATA 75,3A
00960:  DATA 25,30
00962:  DATA 32,75
00964:  DATA 00,00
00966:  DATA 4E,6F
00968:  DATA 77,20
0096A:  DATA 74,69
0096C:  DATA 6D,65
0096E:  DATA 20,69
00970:  DATA 73,0A
00972:  DATA 00,00
00974:  DATA 0D,25
00976:  DATA 30,32
00978:  DATA 75,2F
0097A:  DATA 25,30
0097C:  DATA 32,75
0097E:  DATA 2F,32
00980:  DATA 30,25
00982:  DATA 30,32
00984:  DATA 75,20
00986:  DATA 25,30
00988:  DATA 32,75
0098A:  DATA 3A,25
0098C:  DATA 30,32
0098E:  DATA 75,3A
00990:  DATA 25,30
00992:  DATA 32,75
00994:  DATA 0A,00
00996:  DATA 49,6E
00998:  DATA 76,61
0099A:  DATA 6C,69
0099C:  DATA 64,20
0099E:  DATA 49,4F
009A0:  DATA 20,6F
009A2:  DATA 70,74
009A4:  DATA 69,6F
009A6:  DATA 6E,2E
009A8:  DATA 20,50
009AA:  DATA 6C,65
009AC:  DATA 61,73
009AE:  DATA 65,20
009B0:  DATA 74,72
009B2:  DATA 79,20
009B4:  DATA 61,67
009B6:  DATA 61,69
009B8:  DATA 6E,2E
009BA:  DATA 0A,00
009BC:  DATA 49,4F
009BE:  DATA 20,63
009C0:  DATA 6F,6E
009C2:  DATA 74,72
009C4:  DATA 6F,6C
009C6:  DATA 20,63
009C8:  DATA 68,6F
009CA:  DATA 73,65
009CC:  DATA 6E,0A
009CE:  DATA 00,00
009D0:  DATA 20,20
009D2:  DATA 20,20
009D4:  DATA 70,72
009D6:  DATA 65,73
009D8:  DATA 73,20
009DA:  DATA 61,3A
009DC:  DATA 20,54
009DE:  DATA 6F,67
009E0:  DATA 67,6C
009E2:  DATA 65,20
009E4:  DATA 45,4E
009E6:  DATA 5F,53
009E8:  DATA 55,50
009EA:  DATA 5F,33
009EC:  DATA 56,33
009EE:  DATA 5F,31
009F0:  DATA 20,2F
009F2:  DATA 69,73
009F4:  DATA 20,63
009F6:  DATA 75,72
009F8:  DATA 72,65
009FA:  DATA 6E,74
009FC:  DATA 6C,79
009FE:  DATA 2F,00
00A00:  DATA 48,49
00A02:  DATA 47,48
00A04:  DATA 0A,00
00A06:  DATA 4C,4F
00A08:  DATA 57,0A
00A0A:  DATA 00,00
00A0C:  DATA 49,6E
00A0E:  DATA 76,61
00A10:  DATA 6C,69
00A12:  DATA 64,0A
00A14:  DATA 00,00
00A16:  DATA 20,20
00A18:  DATA 20,20
00A1A:  DATA 70,72
00A1C:  DATA 65,73
00A1E:  DATA 73,20
00A20:  DATA 62,3A
00A22:  DATA 20,54
00A24:  DATA 6F,67
00A26:  DATA 67,6C
00A28:  DATA 65,20
00A2A:  DATA 45,4E
00A2C:  DATA 5F,53
00A2E:  DATA 55,50
00A30:  DATA 5F,33
00A32:  DATA 56,33
00A34:  DATA 5F,32
00A36:  DATA 20,2F
00A38:  DATA 69,73
00A3A:  DATA 20,63
00A3C:  DATA 75,72
00A3E:  DATA 72,65
00A40:  DATA 6E,74
00A42:  DATA 6C,79
00A44:  DATA 2F,00
00A46:  DATA 48,49
00A48:  DATA 47,48
00A4A:  DATA 0A,00
00A4C:  DATA 4C,4F
00A4E:  DATA 57,0A
00A50:  DATA 00,00
00A52:  DATA 49,6E
00A54:  DATA 76,61
00A56:  DATA 6C,69
00A58:  DATA 64,0A
00A5A:  DATA 00,00
00A5C:  DATA 20,20
00A5E:  DATA 20,20
00A60:  DATA 70,72
00A62:  DATA 65,73
00A64:  DATA 73,20
00A66:  DATA 63,3A
00A68:  DATA 20,54
00A6A:  DATA 6F,67
00A6C:  DATA 67,6C
00A6E:  DATA 65,20
00A70:  DATA 45,4E
00A72:  DATA 5F,53
00A74:  DATA 55,50
00A76:  DATA 5F,33
00A78:  DATA 56,33
00A7A:  DATA 5F,44
00A7C:  DATA 41,51
00A7E:  DATA 20,2F
00A80:  DATA 69,73
00A82:  DATA 20,63
00A84:  DATA 75,72
00A86:  DATA 72,65
00A88:  DATA 6E,74
00A8A:  DATA 6C,79
00A8C:  DATA 2F,00
00A8E:  DATA 48,49
00A90:  DATA 47,48
00A92:  DATA 0A,00
00A94:  DATA 4C,4F
00A96:  DATA 57,0A
00A98:  DATA 00,00
00A9A:  DATA 49,6E
00A9C:  DATA 76,61
00A9E:  DATA 6C,69
00AA0:  DATA 64,0A
00AA2:  DATA 00,00
00AA4:  DATA 20,20
00AA6:  DATA 20,20
00AA8:  DATA 70,72
00AAA:  DATA 65,73
00AAC:  DATA 73,20
00AAE:  DATA 64,3A
00AB0:  DATA 20,54
00AB2:  DATA 6F,67
00AB4:  DATA 67,6C
00AB6:  DATA 65,20
00AB8:  DATA 45,4E
00ABA:  DATA 5F,53
00ABC:  DATA 55,50
00ABE:  DATA 5F,55
00AC0:  DATA 4E,52
00AC2:  DATA 45,47
00AC4:  DATA 20,2F
00AC6:  DATA 69,73
00AC8:  DATA 20,63
00ACA:  DATA 75,72
00ACC:  DATA 72,65
00ACE:  DATA 6E,74
00AD0:  DATA 6C,79
00AD2:  DATA 2F,00
00AD4:  DATA 48,49
00AD6:  DATA 47,48
00AD8:  DATA 0A,00
00ADA:  DATA 4C,4F
00ADC:  DATA 57,0A
00ADE:  DATA 00,00
00AE0:  DATA 49,6E
00AE2:  DATA 76,61
00AE4:  DATA 6C,69
00AE6:  DATA 64,0A
00AE8:  DATA 00,00
00AEA:  DATA 20,20
00AEC:  DATA 20,20
00AEE:  DATA 70,72
00AF0:  DATA 65,73
00AF2:  DATA 73,20
00AF4:  DATA 65,3A
00AF6:  DATA 20,54
00AF8:  DATA 6F,67
00AFA:  DATA 67,6C
00AFC:  DATA 65,20
00AFE:  DATA 45,4E
00B00:  DATA 5F,53
00B02:  DATA 55,50
00B04:  DATA 5F,35
00B06:  DATA 56,30
00B08:  DATA 20,2F
00B0A:  DATA 69,73
00B0C:  DATA 20,63
00B0E:  DATA 75,72
00B10:  DATA 72,65
00B12:  DATA 6E,74
00B14:  DATA 6C,79
00B16:  DATA 2F,00
00B18:  DATA 48,49
00B1A:  DATA 47,48
00B1C:  DATA 0A,00
00B1E:  DATA 4C,4F
00B20:  DATA 57,0A
00B22:  DATA 00,00
00B24:  DATA 49,6E
00B26:  DATA 76,61
00B28:  DATA 6C,69
00B2A:  DATA 64,0A
00B2C:  DATA 00,00
00B2E:  DATA 20,20
00B30:  DATA 20,20
00B32:  DATA 70,72
00B34:  DATA 65,73
00B36:  DATA 73,20
00B38:  DATA 66,3A
00B3A:  DATA 20,54
00B3C:  DATA 6F,67
00B3E:  DATA 67,6C
00B40:  DATA 65,20
00B42:  DATA 4B,49
00B44:  DATA 4C,4C
00B46:  DATA 5F,53
00B48:  DATA 57,49
00B4A:  DATA 54,43
00B4C:  DATA 48,20
00B4E:  DATA 2F,69
00B50:  DATA 73,20
00B52:  DATA 63,75
00B54:  DATA 72,72
00B56:  DATA 65,6E
00B58:  DATA 74,6C
00B5A:  DATA 79,2F
00B5C:  DATA 00,00
00B5E:  DATA 48,49
00B60:  DATA 47,48
00B62:  DATA 0A,00
00B64:  DATA 4C,4F
00B66:  DATA 57,0A
00B68:  DATA 00,00
00B6A:  DATA 49,6E
00B6C:  DATA 76,61
00B6E:  DATA 6C,69
00B70:  DATA 64,0A
00B72:  DATA 00,00
00B74:  DATA 20,20
00B76:  DATA 20,20
00B78:  DATA 70,72
00B7A:  DATA 65,73
00B7C:  DATA 73,20
00B7E:  DATA 67,3A
00B80:  DATA 20,54
00B82:  DATA 6F,67
00B84:  DATA 67,6C
00B86:  DATA 65,20
00B88:  DATA 4D,56
00B8A:  DATA 43,41
00B8C:  DATA 4D,5F
00B8E:  DATA 50,57
00B90:  DATA 52,20
00B92:  DATA 2F,69
00B94:  DATA 73,20
00B96:  DATA 63,75
00B98:  DATA 72,72
00B9A:  DATA 65,6E
00B9C:  DATA 74,6C
00B9E:  DATA 79,2F
00BA0:  DATA 00,00
00BA2:  DATA 48,49
00BA4:  DATA 47,48
00BA6:  DATA 0A,00
00BA8:  DATA 4C,4F
00BAA:  DATA 57,0A
00BAC:  DATA 00,00
00BAE:  DATA 49,6E
00BB0:  DATA 76,61
00BB2:  DATA 6C,69
00BB4:  DATA 64,0A
00BB6:  DATA 00,00
00BB8:  DATA 20,20
00BBA:  DATA 20,20
00BBC:  DATA 70,72
00BBE:  DATA 65,73
00BC0:  DATA 73,20
00BC2:  DATA 68,3A
00BC4:  DATA 20,54
00BC6:  DATA 6F,67
00BC8:  DATA 67,6C
00BCA:  DATA 65,20
00BCC:  DATA 4F,56
00BCE:  DATA 43,41
00BD0:  DATA 4D,5F
00BD2:  DATA 50,57
00BD4:  DATA 52,20
00BD6:  DATA 2F,69
00BD8:  DATA 73,20
00BDA:  DATA 63,75
00BDC:  DATA 72,72
00BDE:  DATA 65,6E
00BE0:  DATA 74,6C
00BE2:  DATA 79,2F
00BE4:  DATA 00,00
00BE6:  DATA 48,49
00BE8:  DATA 47,48
00BEA:  DATA 0A,00
00BEC:  DATA 4C,4F
00BEE:  DATA 57,0A
00BF0:  DATA 00,00
00BF2:  DATA 49,6E
00BF4:  DATA 76,61
00BF6:  DATA 6C,69
00BF8:  DATA 64,0A
00BFA:  DATA 00,00
00BFC:  DATA 20,20
00BFE:  DATA 20,20
00C00:  DATA 70,72
00C02:  DATA 65,73
00C04:  DATA 73,20
00C06:  DATA 69,3A
00C08:  DATA 20,54
00C0A:  DATA 6F,67
00C0C:  DATA 67,6C
00C0E:  DATA 65,20
00C10:  DATA 41,44
00C12:  DATA 43,53
00C14:  DATA 5F,50
00C16:  DATA 57,52
00C18:  DATA 20,2F
00C1A:  DATA 69,73
00C1C:  DATA 20,63
00C1E:  DATA 75,72
00C20:  DATA 72,65
00C22:  DATA 6E,74
00C24:  DATA 6C,79
00C26:  DATA 2F,00
00C28:  DATA 48,49
00C2A:  DATA 47,48
00C2C:  DATA 0A,00
00C2E:  DATA 4C,4F
00C30:  DATA 57,0A
00C32:  DATA 00,00
00C34:  DATA 49,6E
00C36:  DATA 76,61
00C38:  DATA 6C,69
00C3A:  DATA 64,0A
00C3C:  DATA 00,00
00C3E:  DATA 20,20
00C40:  DATA 20,20
00C42:  DATA 70,72
00C44:  DATA 65,73
00C46:  DATA 73,20
00C48:  DATA 6A,3A
00C4A:  DATA 20,54
00C4C:  DATA 6F,67
00C4E:  DATA 67,6C
00C50:  DATA 65,20
00C52:  DATA 61,6C
00C54:  DATA 6C,20
00C56:  DATA 50,69
00C58:  DATA 6E,73
00C5A:  DATA 00,00
00C5C:  DATA 49,6E
00C5E:  DATA 76,61
00C60:  DATA 6C,69
00C62:  DATA 64,20
00C64:  DATA 49,4F
00C66:  DATA 20,6F
00C68:  DATA 70,74
00C6A:  DATA 69,6F
00C6C:  DATA 6E,2E
00C6E:  DATA 20,50
00C70:  DATA 6C,65
00C72:  DATA 61,73
00C74:  DATA 65,20
00C76:  DATA 74,72
00C78:  DATA 79,20
00C7A:  DATA 61,67
00C7C:  DATA 61,69
00C7E:  DATA 6E,2E
00C80:  DATA 0A,00
00C82:  DATA 20,20
00C84:  DATA 20,20
00C86:  DATA 70,72
00C88:  DATA 65,73
00C8A:  DATA 73,20
00C8C:  DATA 61,3A
00C8E:  DATA 20,41
00C90:  DATA 44,43
00C92:  DATA 53,20
00C94:  DATA 6D,69
00C96:  DATA 73,73
00C98:  DATA 69,6F
00C9A:  DATA 6E,20
00C9C:  DATA 6D,6F
00C9E:  DATA 64,65
00CA0:  DATA 0A,00
00CA2:  DATA 20,20
00CA4:  DATA 20,20
00CA6:  DATA 70,72
00CA8:  DATA 65,73
00CAA:  DATA 73,20
00CAC:  DATA 62,3A
00CAE:  DATA 20,45
00CB0:  DATA 50,53
00CB2:  DATA 20,6D
00CB4:  DATA 69,73
00CB6:  DATA 73,69
00CB8:  DATA 6F,6E
00CBA:  DATA 20,6D
00CBC:  DATA 6F,64
00CBE:  DATA 65,0A
00CC0:  DATA 00,00
00CC2:  DATA 20,20
00CC4:  DATA 20,20
00CC6:  DATA 70,72
00CC8:  DATA 65,73
00CCA:  DATA 73,20
00CCC:  DATA 63,3A
00CCE:  DATA 20,43
00CD0:  DATA 68,65
00CD2:  DATA 63,6B
00CD4:  DATA 20,46
00CD6:  DATA 6C,61
00CD8:  DATA 73,68
00CDA:  DATA 20,4D
00CDC:  DATA 65,6D
00CDE:  DATA 6F,72
00CE0:  DATA 69,65
00CE2:  DATA 73,0A
00CE4:  DATA 00,00
00CE6:  DATA 41,44
00CE8:  DATA 43,53
00CEA:  DATA 20,6D
00CEC:  DATA 69,73
00CEE:  DATA 73,69
00CF0:  DATA 6F,6E
00CF2:  DATA 20,6D
00CF4:  DATA 6F,64
00CF6:  DATA 65,0A
00CF8:  DATA 00,00
00CFA:  DATA 45,50
00CFC:  DATA 53,20
00CFE:  DATA 6D,69
00D00:  DATA 73,73
00D02:  DATA 69,6F
00D04:  DATA 6E,20
00D06:  DATA 6D,6F
00D08:  DATA 64,65
00D0A:  DATA 0A,00
00D0C:  DATA 49,6E
00D0E:  DATA 76,61
00D10:  DATA 6C,69
00D12:  DATA 64,20
00D14:  DATA 49,4F
00D16:  DATA 20,6F
00D18:  DATA 70,74
00D1A:  DATA 69,6F
00D1C:  DATA 6E,2E
00D1E:  DATA 20,50
00D20:  DATA 6C,65
00D22:  DATA 61,73
00D24:  DATA 65,20
00D26:  DATA 74,72
00D28:  DATA 79,20
00D2A:  DATA 61,67
00D2C:  DATA 61,69
00D2E:  DATA 6E,2E
00D30:  DATA 0A,00
00D32:  DATA 20,5F
00D34:  DATA 5F,20
00D36:  DATA 20,5F
00D38:  DATA 5F,20
00D3A:  DATA 5F,5F
00D3C:  DATA 5F,5F
00D3E:  DATA 5F,20
00D40:  DATA 5F,20
00D42:  DATA 20,20
00D44:  DATA 5F,20
00D46:  DATA 5F,20
00D48:  DATA 20,20
00D4A:  DATA 5F,20
00D4C:  DATA 20,20
00D4E:  DATA 5F,5F
00D50:  DATA 5F,5F
00D52:  DATA 5F,20
00D54:  DATA 20,20
00D56:  DATA 20,20
00D58:  DATA 20,20
00D5A:  DATA 20,20
00D5C:  DATA 20,20
00D5E:  DATA 20,20
00D60:  DATA 20,20
00D62:  DATA 20,20
00D64:  DATA 5F,20
00D66:  DATA 20,20
00D68:  DATA 5F,20
00D6A:  DATA 20,20
00D6C:  DATA 20,20
00D6E:  DATA 20,20
00D70:  DATA 20,20
00D72:  DATA 20,20
00D74:  DATA 20,20
00D76:  DATA 0A,00
00D78:  DATA 7C,20
00D7A:  DATA 20,5C
00D7C:  DATA 2F,20
00D7E:  DATA 20,7C
00D80:  DATA 20,5F
00D82:  DATA 5F,5F
00D84:  DATA 5F,7C
00D86:  DATA 20,5C
00D88:  DATA 20,7C
00D8A:  DATA 20,7C
00D8C:  DATA 20,7C
00D8E:  DATA 20,7C
00D90:  DATA 20,7C
00D92:  DATA 20,7C
00D94:  DATA 20,20
00D96:  DATA 5F,5F
00D98:  DATA 5F,7C
00D9A:  DATA 20,20
00D9C:  DATA 20,5F
00D9E:  DATA 20,5F
00DA0:  DATA 20,5F
00DA2:  DATA 5F,20
00DA4:  DATA 20,20
00DA6:  DATA 5F,5F
00DA8:  DATA 5F,7C
00DAA:  DATA 20,7C
00DAC:  DATA 5F,28
00DAE:  DATA 5F,29
00DB0:  DATA 20,5F
00DB2:  DATA 5F,5F
00DB4:  DATA 20,20
00DB6:  DATA 5F,20
00DB8:  DATA 5F,5F
00DBA:  DATA 20,20
00DBC:  DATA 0A,00
00DBE:  DATA 7C,20
00DC0:  DATA 7C,5C
00DC2:  DATA 2F,7C
00DC4:  DATA 20,7C
00DC6:  DATA 20,20
00DC8:  DATA 5F,7C
00DCA:  DATA 20,7C
00DCC:  DATA 20,20
00DCE:  DATA 5C,7C
00DD0:  DATA 20,7C
00DD2:  DATA 20,7C
00DD4:  DATA 20,7C
00DD6:  DATA 20,7C
00DD8:  DATA 20,7C
00DDA:  DATA 20,7C
00DDC:  DATA 5F,20
00DDE:  DATA 7C,20
00DE0:  DATA 7C,20
00DE2:  DATA 7C,20
00DE4:  DATA 7C,20
00DE6:  DATA 27,5F
00DE8:  DATA 20,5C
00DEA:  DATA 20,2F
00DEC:  DATA 20,5F
00DEE:  DATA 5F,7C
00DF0:  DATA 20,5F
00DF2:  DATA 5F,7C
00DF4:  DATA 20,7C
00DF6:  DATA 2F,20
00DF8:  DATA 5F,20
00DFA:  DATA 5C,7C
00DFC:  DATA 20,27
00DFE:  DATA 5F,20
00E00:  DATA 5C,20
00E02:  DATA 0A,00
00E04:  DATA 7C,20
00E06:  DATA 7C,20
00E08:  DATA 20,7C
00E0A:  DATA 20,7C
00E0C:  DATA 20,7C
00E0E:  DATA 5F,5F
00E10:  DATA 5F,7C
00E12:  DATA 20,7C
00E14:  DATA 5C,20
00E16:  DATA 20,7C
00E18:  DATA 20,7C
00E1A:  DATA 5F,7C
00E1C:  DATA 20,7C
00E1E:  DATA 20,7C
00E20:  DATA 20,20
00E22:  DATA 5F,7C
00E24:  DATA 7C,20
00E26:  DATA 7C,5F
00E28:  DATA 7C,20
00E2A:  DATA 7C,20
00E2C:  DATA 7C,20
00E2E:  DATA 7C,20
00E30:  DATA 7C,20
00E32:  DATA 28,5F
00E34:  DATA 5F,7C
00E36:  DATA 20,7C
00E38:  DATA 5F,7C
00E3A:  DATA 20,7C
00E3C:  DATA 20,28
00E3E:  DATA 5F,29
00E40:  DATA 20,7C
00E42:  DATA 20,7C
00E44:  DATA 20,7C
00E46:  DATA 20,7C
00E48:  DATA 0A,00
00E4A:  DATA 7C,5F
00E4C:  DATA 7C,20
00E4E:  DATA 5F,7C
00E50:  DATA 5F,7C
00E52:  DATA 5F,5F
00E54:  DATA 5F,5F
00E56:  DATA 5F,7C
00E58:  DATA 5F,7C
00E5A:  DATA 20,5C
00E5C:  DATA 5F,7C
00E5E:  DATA 5C,5F
00E60:  DATA 5F,5F
00E62:  DATA 2F,20
00E64:  DATA 20,7C
00E66:  DATA 5F,7C
00E68:  DATA 5F,20
00E6A:  DATA 20,5C
00E6C:  DATA 5F,5F
00E6E:  DATA 2C,5F
00E70:  DATA 7C,5F
00E72:  DATA 7C,20
00E74:  DATA 7C,5F
00E76:  DATA 7C,5C
00E78:  DATA 5F,5F
00E7A:  DATA 5F,7C
00E7C:  DATA 5C,5F
00E7E:  DATA 5F,7C
00E80:  DATA 5F,7C
00E82:  DATA 5C,5F
00E84:  DATA 5F,5F
00E86:  DATA 2F,7C
00E88:  DATA 5F,7C
00E8A:  DATA 20,7C
00E8C:  DATA 5F,7C
00E8E:  DATA 0A,00
00E90:  DATA 20,20
00E92:  DATA 20,2F
00E94:  DATA 20,5C
00E96:  DATA 20,20
00E98:  DATA 20,5F
00E9A:  DATA 5F,5F
00E9C:  DATA 7C,20
00E9E:  DATA 7C,5F
00EA0:  DATA 28,5F
00EA2:  DATA 29,5F
00EA4:  DATA 20,20
00EA6:  DATA 20,5F
00EA8:  DATA 5F,5F
00EAA:  DATA 5F,20
00EAC:  DATA 5F,7C
00EAE:  DATA 20,7C
00EB0:  DATA 5F,20
00EB2:  DATA 5F,5F
00EB4:  DATA 5F,20
00EB6:  DATA 20,5F
00EB8:  DATA 5F,7C
00EBA:  DATA 20,7C
00EBC:  DATA 20,7C
00EBE:  DATA 20,20
00EC0:  DATA 20,20
00EC2:  DATA 20,20
00EC4:  DATA 20,20
00EC6:  DATA 20,20
00EC8:  DATA 20,20
00ECA:  DATA 20,20
00ECC:  DATA 20,20
00ECE:  DATA 20,20
00ED0:  DATA 20,20
00ED2:  DATA 20,20
00ED4:  DATA 0A,00
00ED6:  DATA 20,20
00ED8:  DATA 2F,20
00EDA:  DATA 5F,20
00EDC:  DATA 5C,20
00EDE:  DATA 2F,20
00EE0:  DATA 5F,5F
00EE2:  DATA 7C,20
00EE4:  DATA 5F,5F
00EE6:  DATA 7C,20
00EE8:  DATA 5C,20
00EEA:  DATA 5C,20
00EEC:  DATA 2F,20
00EEE:  DATA 2F,20
00EF0:  DATA 5F,60
00EF2:  DATA 20,7C
00EF4:  DATA 20,5F
00EF6:  DATA 5F,2F
00EF8:  DATA 20,5F
00EFA:  DATA 20,5C
00EFC:  DATA 2F,20
00EFE:  DATA 5F,60
00F00:  DATA 20,7C
00F02:  DATA 20,7C
00F04:  DATA 20,20
00F06:  DATA 20,20
00F08:  DATA 20,20
00F0A:  DATA 20,20
00F0C:  DATA 20,20
00F0E:  DATA 20,20
00F10:  DATA 20,20
00F12:  DATA 20,20
00F14:  DATA 20,20
00F16:  DATA 20,20
00F18:  DATA 20,20
00F1A:  DATA 0A,00
00F1C:  DATA 20,2F
00F1E:  DATA 20,5F
00F20:  DATA 5F,5F
00F22:  DATA 20,5C
00F24:  DATA 20,28
00F26:  DATA 5F,5F
00F28:  DATA 7C,20
00F2A:  DATA 7C,5F
00F2C:  DATA 7C,20
00F2E:  DATA 7C,5C
00F30:  DATA 20,56
00F32:  DATA 20,2F
00F34:  DATA 20,28
00F36:  DATA 5F,7C
00F38:  DATA 20,7C
00F3A:  DATA 20,7C
00F3C:  DATA 7C,20
00F3E:  DATA 20,5F
00F40:  DATA 5F,2F
00F42:  DATA 20,28
00F44:  DATA 5F,7C
00F46:  DATA 20,7C
00F48:  DATA 5F,7C
00F4A:  DATA 20,20
00F4C:  DATA 20,20
00F4E:  DATA 20,20
00F50:  DATA 20,20
00F52:  DATA 20,20
00F54:  DATA 20,20
00F56:  DATA 20,20
00F58:  DATA 20,20
00F5A:  DATA 20,20
00F5C:  DATA 20,20
00F5E:  DATA 20,20
00F60:  DATA 0A,00
00F62:  DATA 2F,5F
00F64:  DATA 2F,20
00F66:  DATA 20,20
00F68:  DATA 5C,5F
00F6A:  DATA 5C,5F
00F6C:  DATA 5F,5F
00F6E:  DATA 7C,5C
00F70:  DATA 5F,5F
00F72:  DATA 7C,5F
00F74:  DATA 7C,20
00F76:  DATA 5C,5F
00F78:  DATA 2F,20
00F7A:  DATA 5C,5F
00F7C:  DATA 5F,2C
00F7E:  DATA 5F,7C
00F80:  DATA 5C,5F
00F82:  DATA 5F,5C
00F84:  DATA 5F,5F
00F86:  DATA 5F,7C
00F88:  DATA 5C,5F
00F8A:  DATA 5F,2C
00F8C:  DATA 5F,28
00F8E:  DATA 5F,29
00F90:  DATA 20,20
00F92:  DATA 20,20
00F94:  DATA 20,20
00F96:  DATA 20,20
00F98:  DATA 20,20
00F9A:  DATA 20,20
00F9C:  DATA 20,20
00F9E:  DATA 20,20
00FA0:  DATA 20,20
00FA2:  DATA 20,20
00FA4:  DATA 20,20
00FA6:  DATA 0A,00
00FA8:  DATA 0A,2D
00FAA:  DATA 2D,2D
00FAC:  DATA 2D,2D
00FAE:  DATA 2D,2D
00FB0:  DATA 2D,2D
00FB2:  DATA 2D,2D
00FB4:  DATA 2D,2D
00FB6:  DATA 2D,2D
00FB8:  DATA 2D,2D
00FBA:  DATA 4D,61
00FBC:  DATA 69,6E
00FBE:  DATA 20,4D
00FC0:  DATA 65,6E
00FC2:  DATA 75,2D
00FC4:  DATA 2D,2D
00FC6:  DATA 2D,2D
00FC8:  DATA 2D,2D
00FCA:  DATA 2D,2D
00FCC:  DATA 2D,2D
00FCE:  DATA 2D,2D
00FD0:  DATA 2D,2D
00FD2:  DATA 2D,2D
00FD4:  DATA 0A,00
00FD6:  DATA 20,20
00FD8:  DATA 20,20
00FDA:  DATA 70,72
00FDC:  DATA 65,73
00FDE:  DATA 73,20
00FE0:  DATA 62,3A
00FE2:  DATA 20,45
00FE4:  DATA 50,53
00FE6:  DATA 20,50
00FE8:  DATA 6F,77
00FEA:  DATA 65,72
00FEC:  DATA 20,6F
00FEE:  DATA 75,74
00FF0:  DATA 70,75
00FF2:  DATA 74,20
00FF4:  DATA 63,6F
00FF6:  DATA 6E,74
00FF8:  DATA 72,6F
00FFA:  DATA 6C,0A
00FFC:  DATA 00,00
00FFE:  DATA 20,20
01000:  DATA 20,20
01002:  DATA 70,72
01004:  DATA 65,73
01006:  DATA 73,20
01008:  DATA 63,3A
0100A:  DATA 20,48
0100C:  DATA 6F,75
0100E:  DATA 73,65
01010:  DATA 20,6B
01012:  DATA 65,65
01014:  DATA 70,69
01016:  DATA 6E,67
01018:  DATA 20,64
0101A:  DATA 61,74
0101C:  DATA 61,20
0101E:  DATA 63,6F
01020:  DATA 6C,6C
01022:  DATA 65,63
01024:  DATA 74,69
01026:  DATA 6F,6E
01028:  DATA 0A,00
0102A:  DATA 20,20
0102C:  DATA 20,20
0102E:  DATA 70,72
01030:  DATA 65,73
01032:  DATA 73,20
01034:  DATA 64,3A
01036:  DATA 20,43
01038:  DATA 68,65
0103A:  DATA 63,6B
0103C:  DATA 20,46
0103E:  DATA 6C,61
01040:  DATA 73,68
01042:  DATA 20,4D
01044:  DATA 65,6D
01046:  DATA 6F,72
01048:  DATA 69,65
0104A:  DATA 73,0A
0104C:  DATA 00,00
0104E:  DATA 20,20
01050:  DATA 20,20
01052:  DATA 70,72
01054:  DATA 65,73
01056:  DATA 73,20
01058:  DATA 66,3A
0105A:  DATA 20,53
0105C:  DATA 65,74
0105E:  DATA 74,69
01060:  DATA 6E,67
01062:  DATA 73,20
01064:  DATA 6F,66
01066:  DATA 20,52
01068:  DATA 54,43
0106A:  DATA 0A,00
0106C:  DATA 20,20
0106E:  DATA 20,20
01070:  DATA 70,72
01072:  DATA 65,73
01074:  DATA 73,20
01076:  DATA 6B,3A
01078:  DATA 20,55
0107A:  DATA 41,52
0107C:  DATA 54,20
0107E:  DATA 72,65
01080:  DATA 70,65
01082:  DATA 61,74
01084:  DATA 65,72
01086:  DATA 20,6F
01088:  DATA 66,20
0108A:  DATA 45,50
0108C:  DATA 53,0A
0108E:  DATA 00,00
01090:  DATA 20,20
01092:  DATA 20,20
01094:  DATA 70,72
01096:  DATA 65,73
01098:  DATA 73,20
0109A:  DATA 6C,3A
0109C:  DATA 20,74
0109E:  DATA 65,73
010A0:  DATA 74,6D
010A2:  DATA 6F,64
010A4:  DATA 65,20
010A6:  DATA 0A,00
010A8:  DATA 20,20
010AA:  DATA 20,20
010AC:  DATA 70,72
010AE:  DATA 65,73
010B0:  DATA 73,20
010B2:  DATA 78,3A
010B4:  DATA 20,45
010B6:  DATA 78,69
010B8:  DATA 74,20
010BA:  DATA 4D,61
010BC:  DATA 69,6E
010BE:  DATA 20,4D
010C0:  DATA 65,6E
010C2:  DATA 75,0A
010C4:  DATA 00,00
010C6:  DATA 20,20
010C8:  DATA 20,20
010CA:  DATA 44,4F
010CC:  DATA 20,4E
010CE:  DATA 4F,54
010D0:  DATA 20,55
010D2:  DATA 53,45
010D4:  DATA 20,43
010D6:  DATA 41,50
010D8:  DATA 49,54
010DA:  DATA 41,4C
010DC:  DATA 20,43
010DE:  DATA 48,41
010E0:  DATA 52,41
010E2:  DATA 43,54
010E4:  DATA 45,52
010E6:  DATA 53,20
010E8:  DATA 54,4F
010EA:  DATA 20,57
010EC:  DATA 52,49
010EE:  DATA 54,45
010F0:  DATA 21,0A
010F2:  DATA 0A,00
010F4:  DATA 55,41
010F6:  DATA 52,54
010F8:  DATA 20,52
010FA:  DATA 65,70
010FC:  DATA 65,61
010FE:  DATA 74,65
01100:  DATA 72,20
01102:  DATA 49,6E
01104:  DATA 69,74
01106:  DATA 69,61
01108:  DATA 6C,69
0110A:  DATA 7A,65
0110C:  DATA 64,2E
0110E:  DATA 0A,00
01110:  DATA 54,65
01112:  DATA 73,74
01114:  DATA 6D,6F
01116:  DATA 64,65
01118:  DATA 20,69
0111A:  DATA 6E,69
0111C:  DATA 74,69
0111E:  DATA 61,6C
01120:  DATA 69,7A
01122:  DATA 65,64
01124:  DATA 0A,00
01126:  DATA 49,6E
01128:  DATA 76,61
0112A:  DATA 6C,69
0112C:  DATA 64,20
0112E:  DATA 6F,70
01130:  DATA 74,69
01132:  DATA 6F,6E
01134:  DATA 2E,20
01136:  DATA 50,6C
01138:  DATA 65,61
0113A:  DATA 73,65
0113C:  DATA 20,74
0113E:  DATA 72,79
01140:  DATA 20,61
01142:  DATA 67,61
01144:  DATA 69,6E
01146:  DATA 2E,0A
01148:  DATA 00,00
0114A:  DATA 52,65
0114C:  DATA 61,64
0114E:  DATA 69,6E
01150:  DATA 67,20
01152:  DATA 63,68
01154:  DATA 69,70
01156:  DATA 20,49
01158:  DATA 44,20
0115A:  DATA 6F,66
0115C:  DATA 20,6D
0115E:  DATA 61,69
01160:  DATA 6E,0A
01162:  DATA 00,00
01164:  DATA 52,65
01166:  DATA 61,64
01168:  DATA 69,6E
0116A:  DATA 67,20
0116C:  DATA 63,68
0116E:  DATA 69,70
01170:  DATA 20,49
01172:  DATA 44,20
01174:  DATA 6F,66
01176:  DATA 20,43
01178:  DATA 4F,4D
0117A:  DATA 0A,00
0117C:  DATA 52,65
0117E:  DATA 61,64
01180:  DATA 69,6E
01182:  DATA 67,20
01184:  DATA 63,68
01186:  DATA 69,70
01188:  DATA 20,49
0118A:  DATA 44,20
0118C:  DATA 6F,66
0118E:  DATA 20,43
01190:  DATA 4F,4D
01192:  DATA 0A,00
01194:  DATA 52,65
01196:  DATA 61,64
01198:  DATA 69,6E
0119A:  DATA 67,20
0119C:  DATA 63,68
0119E:  DATA 69,70
011A0:  DATA 20,49
011A2:  DATA 44,20
011A4:  DATA 6F,66
011A6:  DATA 20,41
011A8:  DATA 44,43
011AA:  DATA 53,0A
011AC:  DATA 00,00
011AE:  DATA 44,6F
011B0:  DATA 6E,65
011B2:  DATA 20,72
011B4:  DATA 65,61
011B6:  DATA 64,69
011B8:  DATA 6E,67
011BA:  DATA 20,63
011BC:  DATA 68,69
011BE:  DATA 70,20
011C0:  DATA 49,44
011C2:  DATA 0A,00
011C4:  DATA 53,74
011C6:  DATA 61,72
011C8:  DATA 74,69
011CA:  DATA 6E,67
011CC:  DATA 20,74
011CE:  DATA 6F,20
011D0:  DATA 77,72
011D2:  DATA 69,74
011D4:  DATA 65,20
011D6:  DATA 64,61
011D8:  DATA 74,61
011DA:  DATA 20,69
011DC:  DATA 6E,20
011DE:  DATA 4D,41
011E0:  DATA 49,4E
011E2:  DATA 20,66
011E4:  DATA 6C,61
011E6:  DATA 73,68
011E8:  DATA 20,6D
011EA:  DATA 65,6D
011EC:  DATA 6F,72
011EE:  DATA 79,0A
011F0:  DATA 00,00
011F2:  DATA 53,74
011F4:  DATA 61,72
011F6:  DATA 74,69
011F8:  DATA 6E,67
011FA:  DATA 20,74
011FC:  DATA 6F,20
011FE:  DATA 77,72
01200:  DATA 69,74
01202:  DATA 65,20
01204:  DATA 64,61
01206:  DATA 74,61
01208:  DATA 20,69
0120A:  DATA 6E,20
0120C:  DATA 43,4F
0120E:  DATA 4D,20
01210:  DATA 66,6C
01212:  DATA 61,73
01214:  DATA 68,20
01216:  DATA 6D,65
01218:  DATA 6D,6F
0121A:  DATA 72,79
0121C:  DATA 0A,00
0121E:  DATA 4D,41
01220:  DATA 49,4E
01222:  DATA 20,54
01224:  DATA 45,53
01226:  DATA 54,20
01228:  DATA 49,53
0122A:  DATA 20,46
0122C:  DATA 49,4E
0122E:  DATA 49,53
01230:  DATA 48,45
01232:  DATA 44,21
01234:  DATA 0A,00
*
012A6:  TBLRD*+
012A8:  MOVF   FF5,F
012AA:  BZ    12CC
012AC:  MOVFF  FF6,2E1
012B0:  MOVFF  FF7,2E2
012B4:  MOVFF  FF8,2E3
012B8:  MOVFF  FF5,2F3
012BC:  RCALL  1260
012BE:  MOVFF  2E1,FF6
012C2:  MOVFF  2E2,FF7
012C6:  MOVFF  2E3,FF8
012CA:  BRA    12A6
012CC:  RETURN 0
*
01340:  MOVWF  00
01342:  SWAPF  00,W
01344:  ADDWF  00,W
01346:  ANDLW  0F
01348:  BTFSC  FD8.1
0134A:  ADDLW  16
0134C:  DAW   
0134E:  BTFSC  00.4
01350:  ADDLW  15
01352:  BTFSC  00.5
01354:  ADDLW  30
01356:  BTFSC  00.6
01358:  ADDLW  60
0135A:  BTFSC  00.7
0135C:  ADDLW  20
0135E:  DAW   
01360:  RETURN 0
01362:  RETURN 0
01364:  MOVWF  00
01366:  SWAPF  00,W
01368:  ANDLW  0F
0136A:  MULLW  0A
0136C:  MOVF   00,W
0136E:  ANDLW  0F
01370:  ADDWF  FF3,W
01372:  RETURN 0
01374:  RETURN 0
01376:  MOVLB  2
01378:  MOVF   xF4,W
0137A:  CLRF   01
0137C:  SUBWF  xF3,W
0137E:  BC    1386
01380:  MOVFF  2F3,00
01384:  BRA    139E
01386:  CLRF   00
01388:  MOVLW  08
0138A:  MOVWF  xF5
0138C:  RLCF   xF3,F
0138E:  RLCF   00,F
01390:  MOVF   xF4,W
01392:  SUBWF  00,W
01394:  BTFSC  FD8.0
01396:  MOVWF  00
01398:  RLCF   01,F
0139A:  DECFSZ xF5,F
0139C:  BRA    138C
0139E:  MOVLB  0
013A0:  RETURN 0
013A2:  MOVF   01,W
013A4:  MOVFF  1C5,2F3
013A8:  MOVLW  64
013AA:  MOVLB  2
013AC:  MOVWF  xF4
013AE:  MOVLB  0
013B0:  RCALL  1376
013B2:  MOVFF  00,1C5
013B6:  MOVF   01,W
013B8:  MOVLW  30
013BA:  BNZ   13CC
013BC:  MOVLB  1
013BE:  BTFSS  xC6.1
013C0:  BRA    13DE
013C2:  BTFSC  xC6.3
013C4:  BRA    13DE
013C6:  BTFSC  xC6.4
013C8:  MOVLW  20
013CA:  BRA    13D4
013CC:  MOVLB  1
013CE:  BCF    xC6.3
013D0:  BCF    xC6.4
013D2:  BSF    xC6.0
013D4:  ADDWF  01,F
013D6:  MOVFF  01,2F3
013DA:  MOVLB  0
013DC:  RCALL  1260
013DE:  MOVFF  1C5,2F3
013E2:  MOVLW  0A
013E4:  MOVLB  2
013E6:  MOVWF  xF4
013E8:  MOVLB  0
013EA:  RCALL  1376
013EC:  MOVFF  00,1C5
013F0:  MOVF   01,W
013F2:  MOVLW  30
013F4:  BNZ   1406
013F6:  MOVLB  1
013F8:  BTFSC  xC6.3
013FA:  BRA    1410
013FC:  BTFSS  xC6.0
013FE:  BRA    1410
01400:  BTFSC  xC6.4
01402:  MOVLW  20
01404:  MOVLB  0
01406:  ADDWF  01,F
01408:  MOVFF  01,2F3
0140C:  RCALL  1260
0140E:  MOVLB  1
01410:  MOVLW  30
01412:  ADDWF  xC5,F
01414:  MOVFF  1C5,2F3
01418:  MOVLB  0
0141A:  RCALL  1260
0141C:  RETURN 0
0141E:  TBLRD*+
01420:  MOVFF  FF6,2EE
01424:  MOVFF  FF7,2EF
01428:  MOVFF  FF8,2F0
0142C:  MOVFF  FF5,2F3
01430:  RCALL  1260
01432:  MOVFF  2EE,FF6
01436:  MOVFF  2EF,FF7
0143A:  MOVFF  2F0,FF8
0143E:  MOVLB  2
01440:  DECFSZ xED,F
01442:  BRA    1446
01444:  BRA    144A
01446:  MOVLB  0
01448:  BRA    141E
0144A:  MOVLB  0
0144C:  RETURN 0
*
016DE:  MOVLB  2
016E0:  BTFSC  xEE.7
016E2:  BRA    1706
016E4:  MOVLW  0F
016E6:  MOVWF  00
016E8:  SWAPF  xED,W
016EA:  ANDWF  00,F
016EC:  MOVLW  0A
016EE:  SUBWF  00,W
016F0:  BC    16F8
016F2:  MOVLW  30
016F4:  ADDWF  00,F
016F6:  BRA    16FC
016F8:  MOVF   xEE,W
016FA:  ADDWF  00,F
016FC:  MOVFF  00,2F3
01700:  MOVLB  0
01702:  RCALL  1260
01704:  MOVLB  2
01706:  MOVLW  0F
01708:  ANDWF  xED,F
0170A:  MOVLW  0A
0170C:  SUBWF  xED,W
0170E:  BC    1714
01710:  MOVLW  30
01712:  BRA    1718
01714:  BCF    xEE.7
01716:  MOVF   xEE,W
01718:  ADDWF  xED,F
0171A:  MOVFF  2ED,2F3
0171E:  MOVLB  0
01720:  RCALL  1260
01722:  RETURN 0
*
01742:  MOVLW  20
01744:  MOVLB  2
01746:  BTFSS  xEE.4
01748:  MOVLW  30
0174A:  MOVWF  xEF
0174C:  MOVFF  2ED,00
01750:  BTFSS  00.7
01752:  BRA    1764
01754:  COMF   00,F
01756:  INCF   00,F
01758:  MOVFF  00,2ED
0175C:  MOVLW  2D
0175E:  MOVWF  xEF
01760:  BSF    xEE.7
01762:  BSF    xEE.0
01764:  MOVF   01,W
01766:  MOVFF  2ED,2F3
0176A:  MOVLW  64
0176C:  MOVWF  xF4
0176E:  MOVLB  0
01770:  RCALL  1376
01772:  MOVFF  00,2ED
01776:  MOVLW  30
01778:  ADDWF  01,W
0177A:  MOVLB  2
0177C:  MOVWF  xF0
0177E:  MOVFF  2ED,2F3
01782:  MOVLW  0A
01784:  MOVWF  xF4
01786:  MOVLB  0
01788:  RCALL  1376
0178A:  MOVLW  30
0178C:  ADDWF  00,W
0178E:  MOVLB  2
01790:  MOVWF  xF2
01792:  MOVLW  30
01794:  ADDWF  01,W
01796:  MOVWF  xF1
01798:  MOVFF  2EF,00
0179C:  MOVLW  30
0179E:  SUBWF  xF0,W
017A0:  BZ    17AA
017A2:  BSF    xEE.1
017A4:  BTFSC  xEE.7
017A6:  BSF    xEE.2
017A8:  BRA    17CE
017AA:  MOVFF  2EF,2F0
017AE:  MOVLW  20
017B0:  MOVWF  xEF
017B2:  MOVLW  30
017B4:  SUBWF  xF1,W
017B6:  BZ    17C0
017B8:  BSF    xEE.0
017BA:  BTFSC  xEE.7
017BC:  BSF    xEE.1
017BE:  BRA    17CE
017C0:  BTFSS  FD8.2
017C2:  BSF    xEE.0
017C4:  BNZ   17CE
017C6:  MOVFF  2F0,2F1
017CA:  MOVLW  20
017CC:  MOVWF  xF0
017CE:  BTFSC  xEE.2
017D0:  BRA    17DC
017D2:  BTFSC  xEE.1
017D4:  BRA    17E4
017D6:  BTFSC  xEE.0
017D8:  BRA    17EC
017DA:  BRA    17F4
017DC:  MOVFF  2EF,2F3
017E0:  MOVLB  0
017E2:  RCALL  1260
017E4:  MOVFF  2F0,2F3
017E8:  MOVLB  0
017EA:  RCALL  1260
017EC:  MOVFF  2F1,2F3
017F0:  MOVLB  0
017F2:  RCALL  1260
017F4:  MOVFF  2F2,2F3
017F8:  MOVLB  0
017FA:  RCALL  1260
017FC:  RETURN 0
*
023D6:  MOVLB  2
023D8:  CLRF   xF6
023DA:  CLRF   xF7
023DC:  MOVLW  01
023DE:  MOVWF  xF8
023E0:  CLRF   FDA
023E2:  CLRF   FD9
023E4:  MOVLW  02
023E6:  MOVWF  xFB
023E8:  MOVLW  EE
023EA:  MOVWF  xFA
023EC:  MOVLW  02
023EE:  MOVWF  FEA
023F0:  MOVLW  F2
023F2:  MOVWF  FE9
023F4:  MOVFF  2FB,FE2
023F8:  MOVFF  2FA,FE1
023FC:  MOVFF  2F8,2F9
02400:  BCF    FD8.0
02402:  MOVF   FE5,W
02404:  MULWF  FEE
02406:  MOVF   FF3,W
02408:  ADDWFC xF6,F
0240A:  MOVF   FF4,W
0240C:  ADDWFC xF7,F
0240E:  DECFSZ xF9,F
02410:  BRA    2400
02412:  MOVFF  2F6,FDE
02416:  MOVFF  2F7,2F6
0241A:  CLRF   xF7
0241C:  BTFSC  FD8.0
0241E:  INCF   xF7,F
02420:  INCF   xFA,F
02422:  BTFSC  FD8.2
02424:  INCF   xFB,F
02426:  INCF   xF8,F
02428:  MOVF   xF8,W
0242A:  SUBLW  05
0242C:  BNZ   23EC
0242E:  MOVLB  0
02430:  GOTO   24D8 (RETURN)
02434:  MOVF   03,W
02436:  SUBLW  20
02438:  BZ    244A
0243A:  MOVF   03,W
0243C:  SUBLW  08
0243E:  BC    2446
02440:  MOVF   03,W
02442:  SUBLW  0D
02444:  BC    244A
02446:  CLRF   01
02448:  BRA    244E
0244A:  MOVLW  01
0244C:  MOVWF  01
0244E:  RETURN 0
02450:  MOVLB  2
02452:  CLRF   xE8
02454:  CLRF   xEC
02456:  CLRF   xEB
02458:  CLRF   xEA
0245A:  CLRF   xE9
0245C:  BTFSS  xE6.7
0245E:  BRA    2466
02460:  MOVF   xE5,F
02462:  BTFSC  FD8.2
02464:  BRA    253C
02466:  MOVLB  0
02468:  RCALL  1EBA
0246A:  MOVFF  01,2E7
0246E:  MOVLB  2
02470:  MOVF   xE7,F
02472:  BTFSC  FD8.2
02474:  BRA    253C
02476:  INCF   xE8,F
02478:  MOVF   xE7,W
0247A:  SUBLW  20
0247C:  BC    2508
0247E:  MOVF   xE7,W
02480:  SUBLW  58
02482:  BZ    2526
02484:  MOVF   xE7,W
02486:  SUBLW  78
02488:  BZ    2526
0248A:  MOVF   xE7,W
0248C:  SUBLW  2F
0248E:  BC    2538
02490:  MOVLW  30
02492:  SUBWF  xE7,F
02494:  MOVF   xE7,W
02496:  SUBLW  09
02498:  BC    24BA
0249A:  MOVLW  07
0249C:  SUBWF  xE7,F
0249E:  MOVF   xE7,W
024A0:  SUBLW  09
024A2:  BC    2538
024A4:  MOVF   xE7,W
024A6:  SUBLW  0F
024A8:  BC    24BA
024AA:  MOVLW  20
024AC:  SUBWF  xE7,F
024AE:  MOVF   xE7,W
024B0:  SUBLW  09
024B2:  BC    2538
024B4:  MOVF   xE7,W
024B6:  SUBLW  0F
024B8:  BNC   2538
024BA:  MOVFF  2EC,2F1
024BE:  MOVFF  2EB,2F0
024C2:  MOVFF  2EA,2EF
024C6:  MOVFF  2E9,2EE
024CA:  CLRF   xF5
024CC:  CLRF   xF4
024CE:  CLRF   xF3
024D0:  MOVLW  10
024D2:  MOVWF  xF2
024D4:  MOVLB  0
024D6:  BRA    23D6
024D8:  MOVLB  2
024DA:  MOVF   xE7,W
024DC:  ADDWF  00,W
024DE:  MOVWF  xE9
024E0:  MOVLW  00
024E2:  ADDWFC 01,W
024E4:  MOVWF  xEA
024E6:  MOVLW  00
024E8:  ADDWFC 02,W
024EA:  MOVWF  xEB
024EC:  MOVLW  00
024EE:  ADDWFC 03,W
024F0:  MOVWF  xEC
024F2:  BTFSC  xE6.7
024F4:  DECF   xE5,F
024F6:  BTFSC  xE6.0
024F8:  BRA    2502
024FA:  MOVF   xE7,F
024FC:  BNZ   2502
024FE:  BSF    xE6.1
02500:  BRA    245C
02502:  BCF    xE6.1
02504:  BSF    xE6.0
02506:  BRA    245C
02508:  MOVFF  2E7,03
0250C:  MOVLB  0
0250E:  RCALL  2434
02510:  MOVF   01,F
02512:  BTFSS  FD8.2
02514:  BRA    251A
02516:  MOVLB  2
02518:  BRA    2538
0251A:  MOVLB  2
0251C:  BTFSC  xE6.0
0251E:  BRA    253C
02520:  BTFSC  xE6.1
02522:  BRA    253C
02524:  BRA    245C
02526:  BTFSC  xE6.0
02528:  BRA    2538
0252A:  BTFSS  xE6.1
0252C:  BRA    2538
0252E:  BTFSC  xE6.7
02530:  INCF   xE5,F
02532:  BCF    xE6.1
02534:  BSF    xE6.0
02536:  BRA    245C
02538:  CLRF   xE8
0253A:  BRA    2558
0253C:  BTFSC  xE6.6
0253E:  BRA    2558
02540:  MOVFF  2E4,FEA
02544:  MOVFF  2E3,FE9
02548:  MOVFF  2E9,FEF
0254C:  MOVFF  2EA,FEC
02550:  MOVFF  2EB,FEC
02554:  MOVFF  2EC,FEC
02558:  MOVFF  2E8,01
0255C:  MOVLB  0
0255E:  RETURN 0
02560:  MOVLB  2
02562:  CLRF   xEA
02564:  CLRF   xEB
02566:  BTFSS  xE8.7
02568:  BRA    256E
0256A:  MOVF   xE7,F
0256C:  BZ    2618
0256E:  MOVLB  0
02570:  RCALL  1EBA
02572:  MOVFF  01,2E9
02576:  MOVLB  2
02578:  MOVF   xE9,F
0257A:  BZ    2618
0257C:  INCF   xEA,F
0257E:  MOVF   xE9,W
02580:  SUBLW  20
02582:  BC    25E4
02584:  MOVF   xE9,W
02586:  SUBLW  58
02588:  BZ    2602
0258A:  MOVF   xE9,W
0258C:  SUBLW  78
0258E:  BZ    2602
02590:  MOVF   xE9,W
02592:  SUBLW  2F
02594:  BC    2614
02596:  MOVLW  30
02598:  SUBWF  xE9,F
0259A:  MOVF   xE9,W
0259C:  SUBLW  09
0259E:  BC    25C0
025A0:  MOVLW  07
025A2:  SUBWF  xE9,F
025A4:  MOVF   xE9,W
025A6:  SUBLW  09
025A8:  BC    2614
025AA:  MOVF   xE9,W
025AC:  SUBLW  0F
025AE:  BC    25C0
025B0:  MOVLW  20
025B2:  SUBWF  xE9,F
025B4:  MOVF   xE9,W
025B6:  SUBLW  09
025B8:  BC    2614
025BA:  MOVF   xE9,W
025BC:  SUBLW  0F
025BE:  BNC   2614
025C0:  MOVF   xEB,W
025C2:  MULLW  10
025C4:  MOVFF  FF3,01
025C8:  MOVF   xE9,W
025CA:  ADDWF  01,W
025CC:  MOVWF  xEB
025CE:  BTFSC  xE8.7
025D0:  DECF   xE7,F
025D2:  BTFSC  xE8.0
025D4:  BRA    25DE
025D6:  MOVF   xE9,F
025D8:  BNZ   25DE
025DA:  BSF    xE8.1
025DC:  BRA    2566
025DE:  BCF    xE8.1
025E0:  BSF    xE8.0
025E2:  BRA    2566
025E4:  MOVFF  2E9,03
025E8:  MOVLB  0
025EA:  RCALL  2434
025EC:  MOVF   01,F
025EE:  BTFSS  FD8.2
025F0:  BRA    25F6
025F2:  MOVLB  2
025F4:  BRA    2614
025F6:  MOVLB  2
025F8:  BTFSC  xE8.0
025FA:  BRA    2618
025FC:  BTFSC  xE8.1
025FE:  BRA    2618
02600:  BRA    2566
02602:  BTFSC  xE8.0
02604:  BRA    2614
02606:  BTFSS  xE8.1
02608:  BRA    2614
0260A:  BTFSC  xE8.7
0260C:  INCF   xE7,F
0260E:  BCF    xE8.1
02610:  BSF    xE8.0
02612:  BRA    2566
02614:  CLRF   xEA
02616:  BRA    2628
02618:  BTFSC  xE8.6
0261A:  BRA    2628
0261C:  MOVFF  2E6,FEA
02620:  MOVFF  2E5,FE9
02624:  MOVFF  2EB,FEF
02628:  MOVFF  2EA,01
0262C:  MOVLB  0
0262E:  RETURN 0
*
027AA:  CLRF   00
027AC:  CLRF   01
027AE:  MOVLB  1
027B0:  MOVF   xE5,W
027B2:  BCF    FD8.0
027B4:  BTFSC  xE6.0
027B6:  ADDWF  00,F
027B8:  RRCF   00,F
027BA:  RRCF   01,F
027BC:  BTFSC  xE6.1
027BE:  ADDWF  00,F
027C0:  RRCF   00,F
027C2:  RRCF   01,F
027C4:  BTFSC  xE6.2
027C6:  ADDWF  00,F
027C8:  RRCF   00,F
027CA:  RRCF   01,F
027CC:  BTFSC  xE6.3
027CE:  ADDWF  00,F
027D0:  RRCF   00,F
027D2:  RRCF   01,F
027D4:  BTFSC  xE6.4
027D6:  ADDWF  00,F
027D8:  RRCF   00,F
027DA:  RRCF   01,F
027DC:  BTFSC  xE6.5
027DE:  ADDWF  00,F
027E0:  RRCF   00,F
027E2:  RRCF   01,F
027E4:  BTFSC  xE6.6
027E6:  ADDWF  00,F
027E8:  RRCF   00,F
027EA:  RRCF   01,F
027EC:  BTFSC  xE6.7
027EE:  ADDWF  00,F
027F0:  RRCF   00,F
027F2:  RRCF   01,F
027F4:  MOVLB  0
027F6:  GOTO   284E (RETURN)
027FA:  MOVLB  1
027FC:  CLRF   xE2
027FE:  CLRF   xE3
02800:  BTFSS  xDD.7
02802:  BRA    2808
02804:  MOVF   xDC,F
02806:  BZ    28BC
02808:  MOVLB  0
0280A:  CALL   1EBA
0280E:  MOVFF  01,1E1
02812:  MOVLB  1
02814:  MOVF   xE1,F
02816:  BZ    28BC
02818:  INCF   xE2,F
0281A:  MOVF   xE1,W
0281C:  SUBLW  20
0281E:  BC    2880
02820:  MOVF   xE1,W
02822:  SUBLW  2D
02824:  BZ    28A2
02826:  MOVF   xE1,W
02828:  SUBLW  2B
0282A:  BZ    28A6
0282C:  MOVF   xE1,W
0282E:  SUBLW  2F
02830:  BC    28B8
02832:  MOVLW  30
02834:  SUBWF  xE1,F
02836:  MOVF   xE0,W
02838:  SUBWF  xE1,W
0283A:  BC    28B8
0283C:  BTFSS  xDD.4
0283E:  BRA    2842
02840:  NEGF   xE1
02842:  MOVFF  1E3,1E5
02846:  MOVFF  1E0,1E6
0284A:  MOVLB  0
0284C:  BRA    27AA
0284E:  MOVF   01,W
02850:  MOVFF  01,1E3
02854:  MOVLB  1
02856:  MOVF   xE1,W
02858:  ADDWF  xE3,F
0285A:  BTFSC  xDD.7
0285C:  DECF   xDC,F
0285E:  MOVF   xE0,W
02860:  SUBLW  08
02862:  BNZ   287A
02864:  BTFSC  xDD.0
02866:  BRA    2872
02868:  MOVF   xE1,F
0286A:  BNZ   287A
0286C:  BSF    xDD.1
0286E:  BSF    xDD.0
02870:  BRA    2800
02872:  BTFSS  xDD.1
02874:  BRA    287A
02876:  BTFSC  xDD.7
02878:  INCF   xDC,F
0287A:  BSF    xDD.0
0287C:  BCF    xDD.1
0287E:  BRA    2800
02880:  MOVFF  1E1,03
02884:  MOVLB  0
02886:  RCALL  2434
02888:  MOVF   01,F
0288A:  BTFSS  FD8.2
0288C:  BRA    2892
0288E:  MOVLB  1
02890:  BRA    28B8
02892:  MOVLB  1
02894:  BTFSC  xDD.0
02896:  BRA    28BC
02898:  BTFSC  xDD.1
0289A:  BRA    28BC
0289C:  BTFSC  xDD.2
0289E:  BRA    28B8
028A0:  BRA    2800
028A2:  BSF    xDD.4
028A4:  BRA    28A8
028A6:  BCF    xDD.4
028A8:  BTFSC  xDD.0
028AA:  BRA    28B8
028AC:  BTFSC  xDD.1
028AE:  BRA    28B8
028B0:  BTFSC  xDD.2
028B2:  BRA    28B8
028B4:  BSF    xDD.2
028B6:  BRA    2800
028B8:  CLRF   xE2
028BA:  BRA    28CC
028BC:  BTFSC  xDD.6
028BE:  BRA    28CC
028C0:  MOVFF  1DF,FEA
028C4:  MOVFF  1DE,FE9
028C8:  MOVFF  1E3,FEF
028CC:  MOVFF  1E2,01
028D0:  MOVLB  0
028D2:  GOTO   29C0 (RETURN)
*
03914:  MOVF   FEF,F
03916:  BZ    3938
03918:  MOVFF  FEA,1D9
0391C:  MOVFF  FE9,1D8
03920:  MOVFF  FEF,2F3
03924:  CALL   1260
03928:  MOVFF  1D9,FEA
0392C:  MOVFF  1D8,FE9
03930:  INCF   FE9,F
03932:  BTFSC  FD8.2
03934:  INCF   FEA,F
03936:  BRA    3914
03938:  RETURN 0
*
03B40:  MOVLW  8E
03B42:  MOVWF  00
03B44:  MOVFF  1D5,01
03B48:  MOVFF  1D4,02
03B4C:  CLRF   03
03B4E:  MOVF   01,F
03B50:  BNZ   3B64
03B52:  MOVFF  02,01
03B56:  CLRF   02
03B58:  MOVLW  08
03B5A:  SUBWF  00,F
03B5C:  MOVF   01,F
03B5E:  BNZ   3B64
03B60:  CLRF   00
03B62:  BRA    3B74
03B64:  BCF    FD8.0
03B66:  BTFSC  01.7
03B68:  BRA    3B72
03B6A:  RLCF   02,F
03B6C:  RLCF   01,F
03B6E:  DECF   00,F
03B70:  BRA    3B64
03B72:  BCF    01.7
03B74:  RETURN 0
03B76:  MOVLB  1
03B78:  MOVF   xD4,W
03B7A:  BTFSC  FD8.2
03B7C:  BRA    3C60
03B7E:  MOVWF  00
03B80:  MOVF   xD8,W
03B82:  BTFSC  FD8.2
03B84:  BRA    3C60
03B86:  ADDWF  00,F
03B88:  BNC   3B92
03B8A:  MOVLW  81
03B8C:  ADDWF  00,F
03B8E:  BC    3C60
03B90:  BRA    3B9A
03B92:  MOVLW  7F
03B94:  SUBWF  00,F
03B96:  BNC   3C60
03B98:  BZ    3C60
03B9A:  MOVFF  1D5,1DC
03B9E:  MOVF   xD9,W
03BA0:  XORWF  xDC,F
03BA2:  BSF    xD5.7
03BA4:  BSF    xD9.7
03BA6:  MOVF   xD7,W
03BA8:  MULWF  xDB
03BAA:  MOVFF  FF4,1DE
03BAE:  MOVF   xD6,W
03BB0:  MULWF  xDA
03BB2:  MOVFF  FF4,03
03BB6:  MOVFF  FF3,1DD
03BBA:  MULWF  xDB
03BBC:  MOVF   FF3,W
03BBE:  ADDWF  xDE,F
03BC0:  MOVF   FF4,W
03BC2:  ADDWFC xDD,F
03BC4:  MOVLW  00
03BC6:  ADDWFC 03,F
03BC8:  MOVF   xD7,W
03BCA:  MULWF  xDA
03BCC:  MOVF   FF3,W
03BCE:  ADDWF  xDE,F
03BD0:  MOVF   FF4,W
03BD2:  ADDWFC xDD,F
03BD4:  MOVLW  00
03BD6:  CLRF   02
03BD8:  ADDWFC 03,F
03BDA:  ADDWFC 02,F
03BDC:  MOVF   xD5,W
03BDE:  MULWF  xDB
03BE0:  MOVF   FF3,W
03BE2:  ADDWF  xDD,F
03BE4:  MOVF   FF4,W
03BE6:  ADDWFC 03,F
03BE8:  MOVLW  00
03BEA:  ADDWFC 02,F
03BEC:  MOVF   xD5,W
03BEE:  MULWF  xDA
03BF0:  MOVF   FF3,W
03BF2:  ADDWF  03,F
03BF4:  MOVF   FF4,W
03BF6:  ADDWFC 02,F
03BF8:  MOVLW  00
03BFA:  CLRF   01
03BFC:  ADDWFC 01,F
03BFE:  MOVF   xD7,W
03C00:  MULWF  xD9
03C02:  MOVF   FF3,W
03C04:  ADDWF  xDD,F
03C06:  MOVF   FF4,W
03C08:  ADDWFC 03,F
03C0A:  MOVLW  00
03C0C:  ADDWFC 02,F
03C0E:  ADDWFC 01,F
03C10:  MOVF   xD6,W
03C12:  MULWF  xD9
03C14:  MOVF   FF3,W
03C16:  ADDWF  03,F
03C18:  MOVF   FF4,W
03C1A:  ADDWFC 02,F
03C1C:  MOVLW  00
03C1E:  ADDWFC 01,F
03C20:  MOVF   xD5,W
03C22:  MULWF  xD9
03C24:  MOVF   FF3,W
03C26:  ADDWF  02,F
03C28:  MOVF   FF4,W
03C2A:  ADDWFC 01,F
03C2C:  INCF   00,F
03C2E:  BTFSC  01.7
03C30:  BRA    3C3C
03C32:  RLCF   xDD,F
03C34:  RLCF   03,F
03C36:  RLCF   02,F
03C38:  RLCF   01,F
03C3A:  DECF   00,F
03C3C:  MOVLW  00
03C3E:  BTFSS  xDD.7
03C40:  BRA    3C56
03C42:  INCF   03,F
03C44:  ADDWFC 02,F
03C46:  ADDWFC 01,F
03C48:  MOVF   01,W
03C4A:  BNZ   3C56
03C4C:  MOVF   02,W
03C4E:  BNZ   3C56
03C50:  MOVF   03,W
03C52:  BNZ   3C56
03C54:  INCF   00,F
03C56:  BTFSC  xDC.7
03C58:  BSF    01.7
03C5A:  BTFSS  xDC.7
03C5C:  BCF    01.7
03C5E:  BRA    3C68
03C60:  CLRF   00
03C62:  CLRF   01
03C64:  CLRF   02
03C66:  CLRF   03
03C68:  MOVLB  0
03C6A:  RETURN 0
03C6C:  MOVLB  1
03C6E:  MOVF   xD8,W
03C70:  BTFSC  FD8.2
03C72:  BRA    3DBE
03C74:  MOVWF  xE4
03C76:  MOVF   xDC,W
03C78:  BTFSC  FD8.2
03C7A:  BRA    3DBE
03C7C:  SUBWF  xE4,F
03C7E:  BNC   3C8A
03C80:  MOVLW  7F
03C82:  ADDWF  xE4,F
03C84:  BTFSC  FD8.0
03C86:  BRA    3DBE
03C88:  BRA    3C96
03C8A:  MOVLW  81
03C8C:  SUBWF  xE4,F
03C8E:  BTFSS  FD8.0
03C90:  BRA    3DBE
03C92:  BTFSC  FD8.2
03C94:  BRA    3DBE
03C96:  MOVFF  1E4,00
03C9A:  CLRF   01
03C9C:  CLRF   02
03C9E:  CLRF   03
03CA0:  CLRF   xE3
03CA2:  MOVFF  1D9,1E2
03CA6:  BSF    xE2.7
03CA8:  MOVFF  1DA,1E1
03CAC:  MOVFF  1DB,1E0
03CB0:  MOVLW  19
03CB2:  MOVWF  xE4
03CB4:  MOVF   xDF,W
03CB6:  SUBWF  xE0,F
03CB8:  BC    3CD4
03CBA:  MOVLW  01
03CBC:  SUBWF  xE1,F
03CBE:  BC    3CD4
03CC0:  SUBWF  xE2,F
03CC2:  BC    3CD4
03CC4:  SUBWF  xE3,F
03CC6:  BC    3CD4
03CC8:  INCF   xE3,F
03CCA:  INCF   xE2,F
03CCC:  INCF   xE1,F
03CCE:  MOVF   xDF,W
03CD0:  ADDWF  xE0,F
03CD2:  BRA    3D24
03CD4:  MOVF   xDE,W
03CD6:  SUBWF  xE1,F
03CD8:  BC    3CFE
03CDA:  MOVLW  01
03CDC:  SUBWF  xE2,F
03CDE:  BC    3CFE
03CE0:  SUBWF  xE3,F
03CE2:  BC    3CFE
03CE4:  INCF   xE3,F
03CE6:  INCF   xE2,F
03CE8:  MOVF   xDE,W
03CEA:  ADDWF  xE1,F
03CEC:  MOVF   xDF,W
03CEE:  ADDWF  xE0,F
03CF0:  BNC   3D24
03CF2:  INCF   xE1,F
03CF4:  BNZ   3D24
03CF6:  INCF   xE2,F
03CF8:  BNZ   3D24
03CFA:  INCF   xE3,F
03CFC:  BRA    3D24
03CFE:  MOVF   xDD,W
03D00:  IORLW  80
03D02:  SUBWF  xE2,F
03D04:  BC    3D22
03D06:  MOVLW  01
03D08:  SUBWF  xE3,F
03D0A:  BC    3D22
03D0C:  INCF   xE3,F
03D0E:  MOVF   xDD,W
03D10:  IORLW  80
03D12:  ADDWF  xE2,F
03D14:  MOVF   xDE,W
03D16:  ADDWF  xE1,F
03D18:  BNC   3CEC
03D1A:  INCF   xE2,F
03D1C:  BNZ   3CEC
03D1E:  INCF   xE3,F
03D20:  BRA    3CEC
03D22:  BSF    03.0
03D24:  DECFSZ xE4,F
03D26:  BRA    3D2A
03D28:  BRA    3D40
03D2A:  BCF    FD8.0
03D2C:  RLCF   xE0,F
03D2E:  RLCF   xE1,F
03D30:  RLCF   xE2,F
03D32:  RLCF   xE3,F
03D34:  BCF    FD8.0
03D36:  RLCF   03,F
03D38:  RLCF   02,F
03D3A:  RLCF   01,F
03D3C:  RLCF   xE5,F
03D3E:  BRA    3CB4
03D40:  BTFSS  xE5.0
03D42:  BRA    3D50
03D44:  BCF    FD8.0
03D46:  RRCF   01,F
03D48:  RRCF   02,F
03D4A:  RRCF   03,F
03D4C:  RRCF   xE5,F
03D4E:  BRA    3D54
03D50:  DECF   00,F
03D52:  BZ    3DBE
03D54:  BTFSC  xE5.7
03D56:  BRA    3D94
03D58:  BCF    FD8.0
03D5A:  RLCF   xE0,F
03D5C:  RLCF   xE1,F
03D5E:  RLCF   xE2,F
03D60:  RLCF   xE3,F
03D62:  MOVF   xDF,W
03D64:  SUBWF  xE0,F
03D66:  BC    3D76
03D68:  MOVLW  01
03D6A:  SUBWF  xE1,F
03D6C:  BC    3D76
03D6E:  SUBWF  xE2,F
03D70:  BC    3D76
03D72:  SUBWF  xE3,F
03D74:  BNC   3DAA
03D76:  MOVF   xDE,W
03D78:  SUBWF  xE1,F
03D7A:  BC    3D86
03D7C:  MOVLW  01
03D7E:  SUBWF  xE2,F
03D80:  BC    3D86
03D82:  SUBWF  xE3,F
03D84:  BNC   3DAA
03D86:  MOVF   xDD,W
03D88:  IORLW  80
03D8A:  SUBWF  xE2,F
03D8C:  BC    3D94
03D8E:  MOVLW  01
03D90:  SUBWF  xE3,F
03D92:  BNC   3DAA
03D94:  INCF   03,F
03D96:  BNZ   3DAA
03D98:  INCF   02,F
03D9A:  BNZ   3DAA
03D9C:  INCF   01,F
03D9E:  BNZ   3DAA
03DA0:  INCF   00,F
03DA2:  BZ    3DBE
03DA4:  RRCF   01,F
03DA6:  RRCF   02,F
03DA8:  RRCF   03,F
03DAA:  MOVFF  1D9,1E4
03DAE:  MOVF   xDD,W
03DB0:  XORWF  xE4,F
03DB2:  BTFSS  xE4.7
03DB4:  BRA    3DBA
03DB6:  BSF    01.7
03DB8:  BRA    3DC6
03DBA:  BCF    01.7
03DBC:  BRA    3DC6
03DBE:  CLRF   00
03DC0:  CLRF   01
03DC2:  CLRF   02
03DC4:  CLRF   03
03DC6:  MOVLB  0
03DC8:  RETURN 0
.................... 
.................... #list
.................... 
.................... //  #include <MT25Q.h>
....................  #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................   unsigned char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n)
.................... {
....................    unsigned char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    unsigned char uc;
....................    unsigned char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(unsigned char *s)
.................... {
....................    unsigned char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2)
.................... {
....................    unsigned char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... unsigned char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strlwr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... unsigned char *strupr(unsigned char *s)
.................... {
....................    unsigned char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... //remove TRUE and FALSE added by CCS's device .h file
.................... #if defined(TRUE)
.................... #undef TRUE
.................... #endif
.................... #if defined(FALSE)
.................... #undef FALSE
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... // #device ADC=16
.................... // #device ICD=TRUE
.................... // #include <main_functions.h>
....................  #FUSES NOWDT NOBROWNOUT    
....................  #use delay(clock=16M, crystal)
*
01236:  MOVLW  01
01238:  MOVWF  FEA
0123A:  MOVLW  CD
0123C:  MOVWF  FE9
0123E:  MOVF   FEF,W
01240:  BZ    125E
01242:  MOVLW  05
01244:  MOVWF  01
01246:  CLRF   00
01248:  DECFSZ 00,F
0124A:  BRA    1248
0124C:  DECFSZ 01,F
0124E:  BRA    1246
01250:  MOVLW  2E
01252:  MOVWF  00
01254:  DECFSZ 00,F
01256:  BRA    1254
01258:  BRA    125A
0125A:  DECFSZ FEF,F
0125C:  BRA    1242
0125E:  RETURN 0
....................   
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  #use rs232(baud=9600, parity=N, xmit=PIN_E5, rcv=PIN_E4, bits=8, stream=EPS) //EPS DATA ACQUISITION
*
0307A:  BSF    F96.4
0307C:  BTFSC  F84.4
0307E:  BRA    307C
03080:  MOVLW  08
03082:  MOVWF  00
03084:  MOVLB  1
03086:  CLRF   xDB
03088:  BSF    00.7
0308A:  BRA    30A8
0308C:  BCF    00.7
0308E:  BRA    30A8
03090:  BCF    FD8.0
03092:  BTFSC  F84.4
03094:  BSF    FD8.0
03096:  RRCF   xDB,F
03098:  BSF    00.6
0309A:  BRA    30A8
0309C:  BCF    00.6
0309E:  DECFSZ 00,F
030A0:  BRA    3090
030A2:  MOVFF  1DB,01
030A6:  BRA    30C0
030A8:  MOVLW  84
030AA:  BTFSC  00.7
030AC:  MOVLW  24
030AE:  MOVWF  01
030B0:  DECFSZ 01,F
030B2:  BRA    30B0
030B4:  BRA    30B6
030B6:  BTFSC  00.7
030B8:  BRA    308C
030BA:  BTFSC  00.6
030BC:  BRA    309C
030BE:  BRA    3090
030C0:  MOVLB  0
030C2:  RETURN 0
*
0393A:  BCF    F96.5
0393C:  BCF    F8D.5
0393E:  MOVLW  08
03940:  MOVWF  01
03942:  BRA    3944
03944:  NOP   
03946:  BSF    01.7
03948:  BRA    396A
0394A:  BCF    01.7
0394C:  MOVLB  1
0394E:  RRCF   xD7,F
03950:  MOVLB  0
03952:  BTFSC  FD8.0
03954:  BSF    F8D.5
03956:  BTFSS  FD8.0
03958:  BCF    F8D.5
0395A:  BSF    01.6
0395C:  BRA    396A
0395E:  BCF    01.6
03960:  DECFSZ 01,F
03962:  BRA    394C
03964:  BRA    3966
03966:  NOP   
03968:  BSF    F8D.5
0396A:  MOVLW  84
0396C:  MOVWF  FE9
0396E:  DECFSZ FE9,F
03970:  BRA    396E
03972:  BRA    3974
03974:  NOP   
03976:  BTFSC  01.7
03978:  BRA    394A
0397A:  BTFSC  01.6
0397C:  BRA    395E
0397E:  GOTO   3988 (RETURN)
....................  #use rs232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, stream=EXT) //MAIN RAB Rear access board 
*
01260:  BCF    F94.6
01262:  BCF    F8B.6
01264:  MOVLW  08
01266:  MOVWF  01
01268:  BRA    126A
0126A:  NOP   
0126C:  BSF    01.7
0126E:  BRA    1290
01270:  BCF    01.7
01272:  MOVLB  2
01274:  RRCF   xF3,F
01276:  MOVLB  0
01278:  BTFSC  FD8.0
0127A:  BSF    F8B.6
0127C:  BTFSS  FD8.0
0127E:  BCF    F8B.6
01280:  BSF    01.6
01282:  BRA    1290
01284:  BCF    01.6
01286:  DECFSZ 01,F
01288:  BRA    1272
0128A:  BRA    128C
0128C:  NOP   
0128E:  BSF    F8B.6
01290:  MOVLW  84
01292:  MOVWF  FE9
01294:  DECFSZ FE9,F
01296:  BRA    1294
01298:  BRA    129A
0129A:  NOP   
0129C:  BTFSC  01.7
0129E:  BRA    1270
012A0:  BTFSC  01.6
012A2:  BRA    1284
012A4:  RETURN 0
*
01EBA:  BSF    F94.7
01EBC:  BTFSC  F82.7
01EBE:  BRA    1EBC
01EC0:  MOVLW  08
01EC2:  MOVWF  00
01EC4:  MOVLB  2
01EC6:  CLRF   xEE
01EC8:  BSF    00.7
01ECA:  BRA    1EE8
01ECC:  BCF    00.7
01ECE:  BRA    1EE8
01ED0:  BCF    FD8.0
01ED2:  BTFSC  F82.7
01ED4:  BSF    FD8.0
01ED6:  RRCF   xEE,F
01ED8:  BSF    00.6
01EDA:  BRA    1EE8
01EDC:  BCF    00.6
01EDE:  DECFSZ 00,F
01EE0:  BRA    1ED0
01EE2:  MOVFF  2EE,01
01EE6:  BRA    1F00
01EE8:  MOVLW  84
01EEA:  BTFSC  00.7
01EEC:  MOVLW  24
01EEE:  MOVWF  01
01EF0:  DECFSZ 01,F
01EF2:  BRA    1EF0
01EF4:  BRA    1EF6
01EF6:  BTFSC  00.7
01EF8:  BRA    1ECC
01EFA:  BTFSC  00.6
01EFC:  BRA    1EDC
01EFE:  BRA    1ED0
01F00:  MOVLB  0
01F02:  RETURN 0
....................  #use rs232(baud=57600, parity=N, xmit=PIN_D2, rcv=PIN_D3, bits=8, stream=COM, FORCE_SW) //MAIN COM Communication, send CW data 
....................  #use rs232(baud=57600, parity=N, xmit=PIN_F7, rcv=PIN_F6, bits=8, stream=CAM, FORCE_SW) //MAIN CAM Communicationx
....................  #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=10000, BITS=8, STREAM=MAIN_FM, MODE=0) //MAIN flash memory port
*
015A4:  MOVLB  2
015A6:  MOVF   xEF,W
015A8:  SUBLW  08
015AA:  BZ    15B4
015AC:  MOVWF  xF1
015AE:  RLCF   xEE,F
015B0:  DECFSZ xF1,F
015B2:  BRA    15AE
015B4:  BSF    F96.0
015B6:  BCF    F96.6
015B8:  BCF    F96.1
015BA:  BCF    F8D.1
015BC:  MOVFF  2EF,2F1
015C0:  BTFSS  xEE.7
015C2:  BCF    F8D.6
015C4:  BTFSC  xEE.7
015C6:  BSF    F8D.6
015C8:  RLCF   xEE,F
015CA:  BSF    F8D.1
015CC:  MOVLW  41
015CE:  MOVWF  xF2
015D0:  DECFSZ xF2,F
015D2:  BRA    15D0
015D4:  RLCF   01,F
015D6:  BTFSS  F84.0
015D8:  BCF    01.0
015DA:  BTFSC  F84.0
015DC:  BSF    01.0
015DE:  BCF    F8D.1
015E0:  MOVLW  40
015E2:  MOVWF  xF2
015E4:  DECFSZ xF2,F
015E6:  BRA    15E4
015E8:  DECFSZ xF1,F
015EA:  BRA    15C0
015EC:  MOVLB  0
015EE:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=10000, BITS=8, STREAM=COM_FM, MODE=0) //COM shared flash memory port
*
01A64:  MOVLB  2
01A66:  MOVF   xBE,W
01A68:  SUBLW  08
01A6A:  BZ    1A74
01A6C:  MOVWF  xC0
01A6E:  RLCF   xBD,F
01A70:  DECFSZ xC0,F
01A72:  BRA    1A6E
01A74:  BSF    F93.5
01A76:  BCF    F93.4
01A78:  BCF    F93.2
01A7A:  BCF    F8A.2
01A7C:  MOVFF  2BE,2C0
01A80:  BTFSS  xBD.7
01A82:  BCF    F8A.4
01A84:  BTFSC  xBD.7
01A86:  BSF    F8A.4
01A88:  RLCF   xBD,F
01A8A:  BSF    F8A.2
01A8C:  MOVLW  41
01A8E:  MOVWF  xC1
01A90:  DECFSZ xC1,F
01A92:  BRA    1A90
01A94:  RLCF   01,F
01A96:  BTFSS  F81.5
01A98:  BCF    01.0
01A9A:  BTFSC  F81.5
01A9C:  BSF    01.0
01A9E:  BCF    F8A.2
01AA0:  MOVLW  40
01AA2:  MOVWF  xC1
01AA4:  DECFSZ xC1,F
01AA6:  BRA    1AA4
01AA8:  DECFSZ xC0,F
01AAA:  BRA    1A80
01AAC:  MOVLB  0
01AAE:  RETURN 0
....................  #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=10000, BITS=8, STREAM=MISSION_FM, MODE=0) //ADCS shared flash memory port, Camera module (ovcam,mvcam) only can access via mux selcent
*
01B3E:  MOVLB  1
01B40:  MOVF   xD3,W
01B42:  SUBLW  08
01B44:  BZ    1B4E
01B46:  MOVWF  xD5
01B48:  RLCF   xD2,F
01B4A:  DECFSZ xD5,F
01B4C:  BRA    1B48
01B4E:  BSF    F92.0
01B50:  BCF    F92.1
01B52:  BCF    F92.3
01B54:  BCF    F89.3
01B56:  MOVFF  1D3,1D5
01B5A:  BTFSS  xD2.7
01B5C:  BCF    F89.1
01B5E:  BTFSC  xD2.7
01B60:  BSF    F89.1
01B62:  RLCF   xD2,F
01B64:  BSF    F89.3
01B66:  MOVLW  41
01B68:  MOVWF  xD6
01B6A:  DECFSZ xD6,F
01B6C:  BRA    1B6A
01B6E:  RLCF   01,F
01B70:  BTFSS  F80.0
01B72:  BCF    01.0
01B74:  BTFSC  F80.0
01B76:  BSF    01.0
01B78:  BCF    F89.3
01B7A:  MOVLW  40
01B7C:  MOVWF  xD6
01B7E:  DECFSZ xD6,F
01B80:  BRA    1B7E
01B82:  DECFSZ xD5,F
01B84:  BRA    1B5A
01B86:  MOVLB  0
01B88:  RETURN 0
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //SPI Stream alter name 
....................  #define SPIPORT MAIN_FM
....................  #define SPIPORT2 COM_FM
....................  #define SPIPORT3 MISSION_FM  //cam system futher added 
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................      
....................  //Flash memory chip select pins and mux control 
....................  #define CS_PIN_1 PIN_E2 //OBC_FLASH_SELECT
....................  #define CS_PIN_COM PIN_B3 //COM_CHIP_SELECT
....................  #define CS_PIN_MISSION PIN_A2 //ADCS_CHIP_SELECT
....................  #define MX_PIN_OVCAM PIN_G2 //OVCAM_MUX_SELECT
....................  #define MX_PIN_MVCAM PIN_G3 //MVCAM_MUX_SELECT
....................  #define MX_PIN_ADCS PIN_A5 //ADCS_MUX_SELECT
....................  #define MX_PIN_COM PIN_C4 //COM_MUX_SELECT
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //mt25q flash memory command assigment
....................  #define READ_ID              0x9F
....................  #define READ_STATUS_REG      0x05 
....................  #define READ_DATA_BYTES      0x13  //0x03 for byte
....................  #define ENABLE_WRITE         0x06
....................  #define WRITE_PAGE           0x12  //0x02 for 3byte 
....................  #define ERASE_SECTOR         0xDC  //0xD8 for 3byte
....................  #define ERASE_4KB_SUBSECTOR  0x21
....................  #define ERASE_32KB_SUBSECTOR 0x5C
....................  #define DIE_ERASE            0xC4
....................  #define FAST_READ            0x0B
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  
....................  //memory maping     
....................  #define SHUTDOWN_COUNT_ADDRESS 0x00100011
....................  
....................  //digtal control pins 
....................  #define EN_SUP_3V3_1 PIN_B0
....................  #define EN_SUP_3V3_2 PIN_G1
....................  #define EN_SUP_3V3_DAQ PIN_D0
....................  #define EN_SUP_UNREG PIN_B1
....................  #define EN_SUP_5V0 PIN_D1
....................  #define KILL_SWITCH PIN_A4
....................  #define MVCAM_PWR PIN_G0
....................  #define OVCAM_PWR PIN_D7
....................  #define ADCS_PWR PIN_D6
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //FLAG variable
....................     //  int8 EPS_UART = 0;
....................     //  int8 COM_UART = 0;
....................     //  int8 EXT_UART = 0; 
....................     //  unsigned int8 in_bffr_main[16] = {};
....................     //  int8 COM_DATA= 0;
....................  
....................  //    int8 ADCS_HK_ADDRESS = 0x00010000;
....................  //    int8 ADCS_HK_ADDRESS_COUNTER = 0x00000000;
....................  //    int8 SHUT_DOWN_COUNT_ADD = 0x00010000;
....................  //    int8 ADCS_COMMAND = 0x02;
....................  //    unsigned char *READ_HK_ADCS[16];
....................      
....................  
....................  //SerialDataReceive(){
....................  //   int num = 0;
....................  //   for(num = 0 ;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = fgetc(EXT);
....................  //   }     
....................  //   return;
....................  //}
....................  //void Delete_Buffer() //delete com command buffer
....................  //{
....................  //   int num = 0;
....................  //   for(num = 0;num < 16; num++)
....................  //   {
....................  //    in_bffr_main[num] = 0x00;
....................  //   }
....................  //   COM_DATA = 0;
....................  //   return;
....................  //}
....................  //
....................  //void Transfer_Buffer(int PORT_NUM) //get buffer data one by one
....................  //                                   //1:EPS 2:EXT 3:COM 4:CAM
....................  //{
....................  //   int num = 0;
....................  //   switch(PORT_NUM)
....................  //   {
....................  //      case 1:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EPS);
....................  //         }
....................  //         break;
....................  //      case 2:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],EXT);
....................  //         }
....................  //         break;
....................  //      case 3:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],COM);
....................  //         }
....................  //         break;
....................  //      case 4:
....................  //         for(;num < 16; num++)
....................  //         {
....................  //         fputc(in_bffr_main[num],CAM);
....................  //         }
....................  //         break;
....................  //   }
....................  //   return;
....................  //}
....................  //
....................  //void process_uart() {
....................  //    if (kbhit(EXT)) {  // Check if data is available
....................  //        SerialDataReceive();  // Load 16 bytes into the buffer
....................  //        fprintf(EXT, "Received Data: ");
....................  //        Transfer_Buffer(1);  // Transfer to PC for verification
....................  //        Delete_Buffer();  // Clear the buffer for the next message
....................  //    }
....................  //}
....................  
....................  void WRITE_ENABLE_OF(){
....................   output_low(CS_PIN_1);
*
01724:  BCF    F96.2
01726:  BCF    F8D.2
....................   spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06
01728:  MOVLW  06
0172A:  MOVLB  2
0172C:  MOVWF  xEE
0172E:  MOVLW  08
01730:  MOVWF  xEF
01732:  MOVLW  01
01734:  MOVWF  xF0
01736:  MOVLB  0
01738:  RCALL  15A4
....................   output_high(CS_PIN_1);  
0173A:  BCF    F96.2
0173C:  BSF    F8D.2
....................   return;
0173E:  GOTO   1874 (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_COM(){
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
*
01C14:  BCF    F93.3
01C16:  BCF    F8A.3
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01C18:  BCF    F94.4
01C1A:  BCF    F8B.4
....................      spi_xfer(SPIPORT2,ENABLE_WRITE);                //Send 0x06
01C1C:  MOVLW  06
01C1E:  MOVLB  2
01C20:  MOVWF  xBD
01C22:  MOVLW  08
01C24:  MOVWF  xBE
01C26:  MOVLW  01
01C28:  MOVWF  xBF
01C2A:  MOVLB  0
01C2C:  RCALL  1A64
....................      output_high(CS_PIN_COM);
01C2E:  BCF    F93.3
01C30:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01C32:  BCF    F94.4
01C34:  BSF    F8B.4
....................   return;
01C36:  GOTO   1CB4 (RETURN)
....................  }
....................  
....................  void WRITE_ENABLE_OF_ADCS(){
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
*
030DC:  BCF    F92.5
030DE:  BCF    F89.5
....................       // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
030E0:  BCF    F92.2
030E2:  BCF    F89.2
....................      spi_xfer(SPIPORT3,ENABLE_WRITE);                //Send 0x06
030E4:  MOVLW  06
030E6:  MOVLB  1
030E8:  MOVWF  xD2
030EA:  MOVLW  08
030EC:  MOVWF  xD3
030EE:  MOVLW  01
030F0:  MOVWF  xD4
030F2:  MOVLB  0
030F4:  CALL   1B3E
....................      output_high(CS_PIN_MISSION);  
030F8:  BCF    F92.2
030FA:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
030FC:  BCF    F92.5
030FE:  BSF    F89.5
....................   return;
03100:  RETURN 0
....................  }
....................  void WRITE_ENABLE_IHS(){
....................     // lower MX to connect to flash device
....................     output_low(MX_PIN_MVCAM);
....................     // LowerCS pin to activate the flash device
....................     output_low(CS_PIN_MISSION);
....................     spi_xfer(SPIPORT3,ENABLE_WRITE);                //Send 0x06
....................     output_high(CS_PIN_MISSION);
....................     output_high(MX_PIN_MVCAM);
....................   return;
....................  }
.................... 
....................  void WRITE_ENABLE_GENERIC(int STREAM, int CS_PIN, int MX_PIN) {
....................     // Lower MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_low(MX_PIN);
....................     }
.................... 
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN);
.................... 
....................     if(STREAM == 1) {
....................         spi_xfer(SPIPORT, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 2) {
....................         spi_xfer(SPIPORT2, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } else if(STREAM == 3) {
....................         spi_xfer(SPIPORT3, ENABLE_WRITE);  // Send ENABLE_WRITE command
....................     } 
....................     // Raise CS to deselect the SPI device
....................     output_high(CS_PIN);
.................... 
....................     // Raise MUX pin if applicable
....................     if (MX_PIN != -1) {
....................         output_high(MX_PIN);
....................     }
.................... }
....................  
....................  void SECTOR_ERASE_OF_ADCS(unsigned int32 sector_address) {
....................     unsigned int8 address[4];
....................     // Byte extraction for a 32-bit address
....................     address[0] = (unsigned int8)((sector_address >> 24) & 0xFF);
03102:  MOVLB  1
03104:  MOVFF  1C8,1C9
03108:  CLRF   03
....................     address[1] = (unsigned int8)((sector_address >> 16) & 0xFF);
0310A:  MOVFF  1C7,1CA
0310E:  CLRF   03
....................     address[2] = (unsigned int8)((sector_address >> 8) & 0xFF);
03110:  MOVFF  1C6,1CB
03114:  CLRF   03
....................     address[3] = (unsigned int8)(sector_address & 0xFF);
03116:  MOVFF  1C5,1CC
0311A:  CLRF   03
.................... 
....................     // Enable write operation
....................     WRITE_ENABLE_OF_ADCS();
0311C:  MOVLB  0
0311E:  RCALL  30DC
.................... 
....................     // Lower MX to connect to flash device
....................     output_low(MX_PIN_ADCS);
03120:  BCF    F92.5
03122:  BCF    F89.5
....................     // Lower CS to select the SPI device
....................     output_low(CS_PIN_MISSION);
03124:  BCF    F92.2
03126:  BCF    F89.2
....................     delay_us(2);  // Small delay for stabilization
03128:  MOVLW  02
0312A:  MOVWF  00
0312C:  DECFSZ 00,F
0312E:  BRA    312C
03130:  NOP   
.................... 
....................     // Send ERASE command and address
....................     spi_xfer(SPIPORT3, ERASE_SECTOR);
03132:  MOVLW  DC
03134:  MOVLB  1
03136:  MOVWF  xD2
03138:  MOVLW  08
0313A:  MOVWF  xD3
0313C:  MOVLW  01
0313E:  MOVWF  xD4
03140:  MOVLB  0
03142:  CALL   1B3E
....................     spi_xfer(SPIPORT3, address[0]);
03146:  MOVFF  1C9,1D2
0314A:  MOVLW  08
0314C:  MOVLB  1
0314E:  MOVWF  xD3
03150:  MOVLW  01
03152:  MOVWF  xD4
03154:  MOVLB  0
03156:  CALL   1B3E
....................     spi_xfer(SPIPORT3, address[1]);
0315A:  MOVFF  1CA,1D2
0315E:  MOVLW  08
03160:  MOVLB  1
03162:  MOVWF  xD3
03164:  MOVLW  01
03166:  MOVWF  xD4
03168:  MOVLB  0
0316A:  CALL   1B3E
....................     spi_xfer(SPIPORT3, address[2]);
0316E:  MOVFF  1CB,1D2
03172:  MOVLW  08
03174:  MOVLB  1
03176:  MOVWF  xD3
03178:  MOVLW  01
0317A:  MOVWF  xD4
0317C:  MOVLB  0
0317E:  CALL   1B3E
....................     spi_xfer(SPIPORT3, address[3]);
03182:  MOVFF  1CC,1D2
03186:  MOVLW  08
03188:  MOVLB  1
0318A:  MOVWF  xD3
0318C:  MOVLW  01
0318E:  MOVWF  xD4
03190:  MOVLB  0
03192:  CALL   1B3E
.................... 
....................     // Deselect SPI device and MUX
....................     output_high(CS_PIN_MISSION);
03196:  BCF    F92.2
03198:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);
0319A:  BCF    F92.5
0319C:  BSF    F89.5
.................... 
....................     // Wait for the erase operation to complete
....................     delay_ms(10);
0319E:  MOVLW  0A
031A0:  MOVLB  1
031A2:  MOVWF  xCD
031A4:  MOVLB  0
031A6:  CALL   1236
031AA:  GOTO   34A0 (RETURN)
.................... }
....................  
....................  void WRITE_DATA_NBYTES(unsigned int32 ADDRESS, unsigned int8* data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
017FE:  MOVLW  06
01800:  MOVWF  FF6
01802:  MOVLW  00
01804:  MOVWF  FF7
01806:  MOVLW  00
01808:  MOVWF  FF8
0180A:  MOVLW  11
0180C:  MOVLB  2
0180E:  MOVWF  xED
01810:  MOVLB  0
01812:  RCALL  141E
01814:  MOVFF  2E4,2ED
01818:  MOVLW  57
0181A:  MOVLB  2
0181C:  MOVWF  xEE
0181E:  MOVLB  0
01820:  RCALL  16DE
01822:  MOVFF  2E3,2ED
01826:  MOVLW  57
01828:  MOVLB  2
0182A:  MOVWF  xEE
0182C:  MOVLB  0
0182E:  RCALL  16DE
01830:  MOVFF  2E2,2ED
01834:  MOVLW  57
01836:  MOVLB  2
01838:  MOVWF  xEE
0183A:  MOVLB  0
0183C:  RCALL  16DE
0183E:  MOVFF  2E1,2ED
01842:  MOVLW  57
01844:  MOVLB  2
01846:  MOVWF  xEE
01848:  MOVLB  0
0184A:  RCALL  16DE
0184C:  MOVLW  0A
0184E:  MOVLB  2
01850:  MOVWF  xF3
01852:  MOVLB  0
01854:  RCALL  1260
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
01856:  MOVLB  2
01858:  MOVFF  2E4,2E8
0185C:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
0185E:  MOVFF  2E3,2E9
01862:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01864:  MOVFF  2E2,2EA
01868:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
0186A:  MOVFF  2E1,2EB
0186E:  CLRF   03
....................      WRITE_ENABLE_OF();  // Enable write operation
01870:  MOVLB  0
01872:  BRA    1724
....................  
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_1);
01874:  BCF    F96.2
01876:  BCF    F8D.2
....................      delay_us(2);  // Small delay for stabilization
01878:  MOVLW  02
0187A:  MOVWF  00
0187C:  DECFSZ 00,F
0187E:  BRA    187C
01880:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT, WRITE_PAGE);
01882:  MOVLW  12
01884:  MOVLB  2
01886:  MOVWF  xEE
01888:  MOVLW  08
0188A:  MOVWF  xEF
0188C:  MOVLW  01
0188E:  MOVWF  xF0
01890:  MOVLB  0
01892:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[0]);
01894:  MOVFF  2E8,2EE
01898:  MOVLW  08
0189A:  MOVLB  2
0189C:  MOVWF  xEF
0189E:  MOVLW  01
018A0:  MOVWF  xF0
018A2:  MOVLB  0
018A4:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[1]);
018A6:  MOVFF  2E9,2EE
018AA:  MOVLW  08
018AC:  MOVLB  2
018AE:  MOVWF  xEF
018B0:  MOVLW  01
018B2:  MOVWF  xF0
018B4:  MOVLB  0
018B6:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[2]);
018B8:  MOVFF  2EA,2EE
018BC:  MOVLW  08
018BE:  MOVLB  2
018C0:  MOVWF  xEF
018C2:  MOVLW  01
018C4:  MOVWF  xF0
018C6:  MOVLB  0
018C8:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[3]);
018CA:  MOVFF  2EB,2EE
018CE:  MOVLW  08
018D0:  MOVLB  2
018D2:  MOVWF  xEF
018D4:  MOVLW  01
018D6:  MOVWF  xF0
018D8:  MOVLB  0
018DA:  RCALL  15A4
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
018DC:  MOVLB  2
018DE:  CLRF   xEC
018E0:  MOVF   xE7,W
018E2:  SUBWF  xEC,W
018E4:  BC    1934
....................          spi_xfer(SPIPORT, data[i]);  // Send data byte
018E6:  MOVF   xEC,W
018E8:  ADDWF  xE5,W
018EA:  MOVWF  FE9
018EC:  MOVLW  00
018EE:  ADDWFC xE6,W
018F0:  MOVWF  FEA
018F2:  MOVFF  FEF,2EE
018F6:  MOVLW  08
018F8:  MOVWF  xEF
018FA:  MOVLW  01
018FC:  MOVWF  xF0
018FE:  MOVLB  0
01900:  RCALL  15A4
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (optional)
01902:  MOVLB  2
01904:  MOVF   xEC,W
01906:  ADDWF  xE5,W
01908:  MOVWF  FE9
0190A:  MOVLW  00
0190C:  ADDWFC xE6,W
0190E:  MOVWF  FEA
01910:  MOVFF  FEF,2ED
01914:  MOVLW  01
01916:  MOVWF  xEE
01918:  MOVLW  20
0191A:  MOVWF  xF3
0191C:  MOVLB  0
0191E:  RCALL  1260
01920:  MOVLB  2
01922:  DECFSZ xEE,F
01924:  BRA    1918
01926:  MOVFF  2ED,2F3
0192A:  MOVLB  0
0192C:  RCALL  1260
0192E:  MOVLB  2
01930:  INCF   xEC,F
01932:  BRA    18E0
....................      }
....................  //    for (int i = 0; i < data_number; i++) {
....................  //        spi_xfer(SPIPORT, data[i]);  // Send data byte
....................  //        fprintf(EXT,"%02d", data[i]);    // Print each byte as hex (optional)
....................  //    } for futhre use this is for displaying in hex format 
....................      
....................      output_high(CS_PIN_1);  // Deselect SPI device
01934:  BCF    F96.2
01936:  BSF    F8D.2
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN MAIN!\n", data_number);
01938:  MOVLW  0A
0193A:  MOVWF  xF3
0193C:  MOVLB  0
0193E:  RCALL  1260
01940:  MOVFF  2E7,2ED
01944:  MOVLW  18
01946:  MOVLB  2
01948:  MOVWF  xEE
0194A:  MOVLB  0
0194C:  RCALL  1742
0194E:  MOVLW  21
01950:  MOVWF  FF6
01952:  MOVLW  00
01954:  MOVWF  FF7
01956:  MOVLW  00
01958:  MOVWF  FF8
0195A:  MOVLW  18
0195C:  MOVLB  2
0195E:  MOVWF  xED
01960:  MOVLB  0
01962:  RCALL  141E
....................      return;
01964:  RETURN 0
....................  }
....................  
....................  
....................  void WRITE_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN COM: 0x%08lx\n", ADDRESS);  // Print address as hex
*
01C3A:  MOVLW  3A
01C3C:  MOVWF  FF6
01C3E:  MOVLW  00
01C40:  MOVWF  FF7
01C42:  MOVLW  00
01C44:  MOVWF  FF8
01C46:  MOVLW  18
01C48:  MOVLB  2
01C4A:  MOVWF  xED
01C4C:  MOVLB  0
01C4E:  CALL   141E
01C52:  MOVFF  1B4,2ED
01C56:  MOVLW  57
01C58:  MOVLB  2
01C5A:  MOVWF  xEE
01C5C:  MOVLB  0
01C5E:  RCALL  16DE
01C60:  MOVFF  1B3,2ED
01C64:  MOVLW  57
01C66:  MOVLB  2
01C68:  MOVWF  xEE
01C6A:  MOVLB  0
01C6C:  RCALL  16DE
01C6E:  MOVFF  1B2,2ED
01C72:  MOVLW  57
01C74:  MOVLB  2
01C76:  MOVWF  xEE
01C78:  MOVLB  0
01C7A:  RCALL  16DE
01C7C:  MOVFF  1B1,2ED
01C80:  MOVLW  57
01C82:  MOVLB  2
01C84:  MOVWF  xEE
01C86:  MOVLB  0
01C88:  RCALL  16DE
01C8A:  MOVLW  0A
01C8C:  MOVLB  2
01C8E:  MOVWF  xF3
01C90:  MOVLB  0
01C92:  CALL   1260
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
01C96:  MOVLB  1
01C98:  MOVFF  1B4,1B8
01C9C:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01C9E:  MOVFF  1B3,1B9
01CA2:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01CA4:  MOVFF  1B2,1BA
01CA8:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
01CAA:  MOVFF  1B1,1BB
01CAE:  CLRF   03
....................      WRITE_ENABLE_OF_COM();  // Enable write operation
01CB0:  MOVLB  0
01CB2:  BRA    1C14
....................  
....................      // Lower MX to connect to flash device
....................      output_low(MX_PIN_COM);
01CB4:  BCF    F94.4
01CB6:  BCF    F8B.4
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_COM);
01CB8:  BCF    F93.3
01CBA:  BCF    F8A.3
....................      delay_us(2);  // Small delay for stabilization
01CBC:  MOVLW  02
01CBE:  MOVWF  00
01CC0:  DECFSZ 00,F
01CC2:  BRA    1CC0
01CC4:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT2, WRITE_PAGE);
01CC6:  MOVLW  12
01CC8:  MOVLB  2
01CCA:  MOVWF  xBD
01CCC:  MOVLW  08
01CCE:  MOVWF  xBE
01CD0:  MOVLW  01
01CD2:  MOVWF  xBF
01CD4:  MOVLB  0
01CD6:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[0]);
01CD8:  MOVFF  1B8,2BD
01CDC:  MOVLW  08
01CDE:  MOVLB  2
01CE0:  MOVWF  xBE
01CE2:  MOVLW  01
01CE4:  MOVWF  xBF
01CE6:  MOVLB  0
01CE8:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[1]);
01CEA:  MOVFF  1B9,2BD
01CEE:  MOVLW  08
01CF0:  MOVLB  2
01CF2:  MOVWF  xBE
01CF4:  MOVLW  01
01CF6:  MOVWF  xBF
01CF8:  MOVLB  0
01CFA:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[2]);
01CFC:  MOVFF  1BA,2BD
01D00:  MOVLW  08
01D02:  MOVLB  2
01D04:  MOVWF  xBE
01D06:  MOVLW  01
01D08:  MOVWF  xBF
01D0A:  MOVLB  0
01D0C:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[3]);
01D0E:  MOVFF  1BB,2BD
01D12:  MOVLW  08
01D14:  MOVLB  2
01D16:  MOVWF  xBE
01D18:  MOVLW  01
01D1A:  MOVWF  xBF
01D1C:  MOVLB  0
01D1E:  RCALL  1A64
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
01D20:  MOVLB  1
01D22:  CLRF   xBC
01D24:  MOVF   xB7,W
01D26:  SUBWF  xBC,W
01D28:  BC    1D80
....................          spi_xfer(SPIPORT2, data[i]);  // Send data byte
01D2A:  MOVF   xBC,W
01D2C:  ADDWF  xB5,W
01D2E:  MOVWF  FE9
01D30:  MOVLW  00
01D32:  ADDWFC xB6,W
01D34:  MOVWF  FEA
01D36:  MOVFF  FEF,2BD
01D3A:  MOVLW  08
01D3C:  MOVLB  2
01D3E:  MOVWF  xBE
01D40:  MOVLW  01
01D42:  MOVWF  xBF
01D44:  MOVLB  0
01D46:  RCALL  1A64
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
01D48:  MOVLB  1
01D4A:  MOVF   xBC,W
01D4C:  ADDWF  xB5,W
01D4E:  MOVWF  FE9
01D50:  MOVLW  00
01D52:  ADDWFC xB6,W
01D54:  MOVWF  FEA
01D56:  MOVFF  FEF,1BD
01D5A:  MOVLW  01
01D5C:  MOVWF  xBE
01D5E:  MOVLW  20
01D60:  MOVLB  2
01D62:  MOVWF  xF3
01D64:  MOVLB  0
01D66:  CALL   1260
01D6A:  MOVLB  1
01D6C:  DECFSZ xBE,F
01D6E:  BRA    1D5E
01D70:  MOVFF  1BD,2F3
01D74:  MOVLB  0
01D76:  CALL   1260
01D7A:  MOVLB  1
01D7C:  INCF   xBC,F
01D7E:  BRA    1D24
....................      }
....................      
....................      output_high(CS_PIN_COM);  // Deselect SPI devices
01D80:  BCF    F93.3
01D82:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  //Deselect MUX from flash
01D84:  BCF    F94.4
01D86:  BSF    F8B.4
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN COM!\n", data_number);
01D88:  MOVLW  0A
01D8A:  MOVLB  2
01D8C:  MOVWF  xF3
01D8E:  MOVLB  0
01D90:  CALL   1260
01D94:  MOVFF  1B7,2ED
01D98:  MOVLW  18
01D9A:  MOVLB  2
01D9C:  MOVWF  xEE
01D9E:  MOVLB  0
01DA0:  RCALL  1742
01DA2:  MOVLW  5D
01DA4:  MOVWF  FF6
01DA6:  MOVLW  00
01DA8:  MOVWF  FF7
01DAA:  MOVLW  00
01DAC:  MOVWF  FF8
01DAE:  MOVLW  17
01DB0:  MOVLB  2
01DB2:  MOVWF  xED
01DB4:  MOVLB  0
01DB6:  CALL   141E
01DBA:  GOTO   4744 (RETURN)
....................  }
....................  
....................  void WRITE_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned int8 data[], unsigned char data_number) {
....................      fprintf(EXT,"WRITE ADDRESS IN ADCS: 0x%08lx\n", ADDRESS);  // Print address as hex
*
031AE:  MOVLW  76
031B0:  MOVWF  FF6
031B2:  MOVLW  00
031B4:  MOVWF  FF7
031B6:  MOVLW  00
031B8:  MOVWF  FF8
031BA:  MOVLW  19
031BC:  MOVLB  2
031BE:  MOVWF  xED
031C0:  MOVLB  0
031C2:  CALL   141E
031C6:  MOVFF  1C8,2ED
031CA:  MOVLW  57
031CC:  MOVLB  2
031CE:  MOVWF  xEE
031D0:  MOVLB  0
031D2:  CALL   16DE
031D6:  MOVFF  1C7,2ED
031DA:  MOVLW  57
031DC:  MOVLB  2
031DE:  MOVWF  xEE
031E0:  MOVLB  0
031E2:  CALL   16DE
031E6:  MOVFF  1C6,2ED
031EA:  MOVLW  57
031EC:  MOVLB  2
031EE:  MOVWF  xEE
031F0:  MOVLB  0
031F2:  CALL   16DE
031F6:  MOVFF  1C5,2ED
031FA:  MOVLW  57
031FC:  MOVLB  2
031FE:  MOVWF  xEE
03200:  MOVLB  0
03202:  CALL   16DE
03206:  MOVLW  0A
03208:  MOVLB  2
0320A:  MOVWF  xF3
0320C:  MOVLB  0
0320E:  CALL   1260
....................      unsigned int8 adsress[4];
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
03212:  MOVLB  1
03214:  MOVFF  1C8,1CC
03218:  CLRF   03
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
0321A:  MOVFF  1C7,1CD
0321E:  CLRF   03
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
03220:  MOVFF  1C6,1CE
03224:  CLRF   03
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
03226:  MOVFF  1C5,1CF
0322A:  CLRF   03
....................      WRITE_ENABLE_OF_ADCS();  // Enable write operation and MX and CS pins are included in here 
0322C:  MOVLB  0
0322E:  RCALL  30DC
....................  
....................      //Lower MX to connect to flash device
....................      output_low(MX_PIN_ADCS);
03230:  BCF    F92.5
03232:  BCF    F89.5
....................      // Lower CS to select the SPI device
....................      output_low(CS_PIN_MISSION);
03234:  BCF    F92.2
03236:  BCF    F89.2
....................      delay_us(2);  // Small delay for stabilization
03238:  MOVLW  02
0323A:  MOVWF  00
0323C:  DECFSZ 00,F
0323E:  BRA    323C
03240:  NOP   
....................      // Send WRITE command and address
....................      spi_xfer(SPIPORT3, WRITE_PAGE);
03242:  MOVLW  12
03244:  MOVLB  1
03246:  MOVWF  xD2
03248:  MOVLW  08
0324A:  MOVWF  xD3
0324C:  MOVLW  01
0324E:  MOVWF  xD4
03250:  MOVLB  0
03252:  CALL   1B3E
....................      spi_xfer(SPIPORT3, adsress[0]);
03256:  MOVFF  1CC,1D2
0325A:  MOVLW  08
0325C:  MOVLB  1
0325E:  MOVWF  xD3
03260:  MOVLW  01
03262:  MOVWF  xD4
03264:  MOVLB  0
03266:  CALL   1B3E
....................      spi_xfer(SPIPORT3, adsress[1]);
0326A:  MOVFF  1CD,1D2
0326E:  MOVLW  08
03270:  MOVLB  1
03272:  MOVWF  xD3
03274:  MOVLW  01
03276:  MOVWF  xD4
03278:  MOVLB  0
0327A:  CALL   1B3E
....................      spi_xfer(SPIPORT3, adsress[2]);
0327E:  MOVFF  1CE,1D2
03282:  MOVLW  08
03284:  MOVLB  1
03286:  MOVWF  xD3
03288:  MOVLW  01
0328A:  MOVWF  xD4
0328C:  MOVLB  0
0328E:  CALL   1B3E
....................      spi_xfer(SPIPORT3, adsress[3]);
03292:  MOVFF  1CF,1D2
03296:  MOVLW  08
03298:  MOVLB  1
0329A:  MOVWF  xD3
0329C:  MOVLW  01
0329E:  MOVWF  xD4
032A0:  MOVLB  0
032A2:  CALL   1B3E
....................      // Write data bytes
....................      for (int i = 0; i < data_number; i++) {
032A6:  MOVLB  1
032A8:  CLRF   xD0
032AA:  MOVF   xCB,W
032AC:  SUBWF  xD0,W
032AE:  BC    3306
....................          spi_xfer(SPIPORT3, data[i]);  // Send data byte
032B0:  MOVF   xD0,W
032B2:  ADDWF  xC9,W
032B4:  MOVWF  FE9
032B6:  MOVLW  00
032B8:  ADDWFC xCA,W
032BA:  MOVWF  FEA
032BC:  MOVFF  FEF,1D2
032C0:  MOVLW  08
032C2:  MOVWF  xD3
032C4:  MOVLW  01
032C6:  MOVWF  xD4
032C8:  MOVLB  0
032CA:  CALL   1B3E
....................          fprintf(EXT,"%02c", data[i]);    // Print each byte as hex (debugging purpose)
032CE:  MOVLB  1
032D0:  MOVF   xD0,W
032D2:  ADDWF  xC9,W
032D4:  MOVWF  FE9
032D6:  MOVLW  00
032D8:  ADDWFC xCA,W
032DA:  MOVWF  FEA
032DC:  MOVFF  FEF,1D1
032E0:  MOVLW  01
032E2:  MOVWF  xD2
032E4:  MOVLW  20
032E6:  MOVLB  2
032E8:  MOVWF  xF3
032EA:  MOVLB  0
032EC:  CALL   1260
032F0:  MOVLB  1
032F2:  DECFSZ xD2,F
032F4:  BRA    32E4
032F6:  MOVFF  1D1,2F3
032FA:  MOVLB  0
032FC:  CALL   1260
03300:  MOVLB  1
03302:  INCF   xD0,F
03304:  BRA    32AA
....................      }
....................      
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device5
03306:  BCF    F92.2
03308:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
0330A:  BCF    F92.5
0330C:  BSF    F89.5
....................      
....................      fprintf(EXT,"\n%d BYTES WRITTEN IN ADCS!\n", data_number);
0330E:  MOVLW  0A
03310:  MOVLB  2
03312:  MOVWF  xF3
03314:  MOVLB  0
03316:  CALL   1260
0331A:  MOVFF  1CB,2ED
0331E:  MOVLW  18
03320:  MOVLB  2
03322:  MOVWF  xEE
03324:  MOVLB  0
03326:  CALL   1742
0332A:  MOVLW  99
0332C:  MOVWF  FF6
0332E:  MOVLW  00
03330:  MOVWF  FF7
03332:  MOVLW  00
03334:  MOVWF  FF8
03336:  MOVLW  18
03338:  MOVLB  2
0333A:  MOVWF  xED
0333C:  MOVLB  0
0333E:  CALL   141E
03342:  GOTO   350E (RETURN)
....................  }
....................   
....................  
....................  char* READ_DATA_NBYTES(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  
....................  
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
015F0:  MOVFF  1DD,00
015F4:  MOVLB  2
015F6:  MOVFF  00,1DF
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
015FA:  MOVFF  1DC,00
015FE:  MOVFF  1DD,2E6
01602:  MOVFF  00,1E0
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01606:  MOVFF  1DB,00
0160A:  MOVFF  1DC,2E6
0160E:  MOVFF  1DD,2E7
01612:  MOVFF  00,1E1
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
01616:  MOVLB  1
01618:  MOVFF  1DA,1E2
0161C:  CLRF   03
....................  
....................      output_low(CS_PIN_1);  // Select SPI device
0161E:  BCF    F96.2
01620:  BCF    F8D.2
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(SPIPORT, READ_DATA_BYTES);
01622:  MOVLW  13
01624:  MOVLB  2
01626:  MOVWF  xEE
01628:  MOVLW  08
0162A:  MOVWF  xEF
0162C:  MOVLW  01
0162E:  MOVWF  xF0
01630:  MOVLB  0
01632:  RCALL  15A4
....................      // Send address bytes
....................      spi_xfer(SPIPORT, adsress[0]);
01634:  MOVFF  1DF,2EE
01638:  MOVLW  08
0163A:  MOVLB  2
0163C:  MOVWF  xEF
0163E:  MOVLW  01
01640:  MOVWF  xF0
01642:  MOVLB  0
01644:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[1]);
01646:  MOVFF  1E0,2EE
0164A:  MOVLW  08
0164C:  MOVLB  2
0164E:  MOVWF  xEF
01650:  MOVLW  01
01652:  MOVWF  xF0
01654:  MOVLB  0
01656:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[2]);
01658:  MOVFF  1E1,2EE
0165C:  MOVLW  08
0165E:  MOVLB  2
01660:  MOVWF  xEF
01662:  MOVLW  01
01664:  MOVWF  xF0
01666:  MOVLB  0
01668:  RCALL  15A4
....................      spi_xfer(SPIPORT, adsress[3]);
0166A:  MOVFF  1E2,2EE
0166E:  MOVLW  08
01670:  MOVLB  2
01672:  MOVWF  xEF
01674:  MOVLW  01
01676:  MOVWF  xF0
01678:  MOVLB  0
0167A:  RCALL  15A4
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {  // Avoid overflow
0167C:  MOVLB  2
0167E:  CLRF   xE3
01680:  MOVLB  1
01682:  MOVF   xDE,W
01684:  MOVLB  2
01686:  SUBWF  xE3,W
01688:  BC    16C8
....................          Data_return[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy byte to receive data
0168A:  CLRF   03
0168C:  MOVF   xE3,W
0168E:  ADDLW  E3
01690:  MOVWF  FE9
01692:  MOVLW  01
01694:  ADDWFC 03,W
01696:  MOVWF  FEA
01698:  CLRF   xEE
0169A:  MOVLW  08
0169C:  MOVWF  xEF
0169E:  MOVLW  01
016A0:  MOVWF  xF0
016A2:  MOVLB  0
016A4:  RCALL  15A4
016A6:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);  // Print each byte as hex
016AA:  CLRF   03
016AC:  MOVLB  2
016AE:  MOVF   xE3,W
016B0:  ADDLW  E3
016B2:  MOVWF  FE9
016B4:  MOVLW  01
016B6:  ADDWFC 03,W
016B8:  MOVWF  FEA
016BA:  MOVFF  FEF,2F3
016BE:  MOVLB  0
016C0:  RCALL  1260
016C2:  MOVLB  2
016C4:  INCF   xE3,F
016C6:  BRA    1680
....................      }
....................  
....................      output_high(CS_PIN_1);  // Deselect SPI device after reading
016C8:  BCF    F96.2
016CA:  BSF    F8D.2
....................      fprintf(EXT, "\n");
016CC:  MOVLW  0A
016CE:  MOVWF  xF3
016D0:  MOVLB  0
016D2:  RCALL  1260
....................  
....................      return Data_return;
016D4:  MOVLW  E3
016D6:  MOVWF  01
016D8:  MOVLW  01
016DA:  MOVWF  02
016DC:  RETURN 0
....................  }
....................  
....................  
....................  
....................  char* READ_DATA_NBYTES_COM(unsigned int32 ADDRESS, unsigned short data_number) {
....................      unsigned int8 adsress[4];
....................      unsigned char Data_return[256];  // 
....................      
....................      // Byte extraction for a 32-bit address
....................      adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
01DBE:  MOVFF  1B4,00
01DC2:  MOVLB  2
01DC4:  MOVFF  00,1B6
....................      adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
01DC8:  MOVFF  1B3,00
01DCC:  MOVFF  1B4,2BD
01DD0:  MOVFF  00,1B7
....................      adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
01DD4:  MOVFF  1B2,00
01DD8:  MOVFF  1B3,2BD
01DDC:  MOVFF  1B4,2BE
01DE0:  MOVFF  00,1B8
....................      adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
01DE4:  MOVLB  1
01DE6:  MOVFF  1B1,1B9
01DEA:  CLRF   03
....................  
....................      output_low(MX_PIN_COM);  // Lower MX to connect to flash device
01DEC:  BCF    F94.4
01DEE:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Select SPI device
01DF0:  BCF    F93.3
01DF2:  BCF    F8A.3
....................  
....................      // Send READ DATA COMMAND
....................      spi_xfer(SPIPORT2, READ_DATA_BYTES);
01DF4:  MOVLW  13
01DF6:  MOVLB  2
01DF8:  MOVWF  xBD
01DFA:  MOVLW  08
01DFC:  MOVWF  xBE
01DFE:  MOVLW  01
01E00:  MOVWF  xBF
01E02:  MOVLB  0
01E04:  RCALL  1A64
....................      // Send address bytes
....................      spi_xfer(SPIPORT2, adsress[0]);
01E06:  MOVFF  1B6,2BD
01E0A:  MOVLW  08
01E0C:  MOVLB  2
01E0E:  MOVWF  xBE
01E10:  MOVLW  01
01E12:  MOVWF  xBF
01E14:  MOVLB  0
01E16:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[1]);
01E18:  MOVFF  1B7,2BD
01E1C:  MOVLW  08
01E1E:  MOVLB  2
01E20:  MOVWF  xBE
01E22:  MOVLW  01
01E24:  MOVWF  xBF
01E26:  MOVLB  0
01E28:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[2]);
01E2A:  MOVFF  1B8,2BD
01E2E:  MOVLW  08
01E30:  MOVLB  2
01E32:  MOVWF  xBE
01E34:  MOVLW  01
01E36:  MOVWF  xBF
01E38:  MOVLB  0
01E3A:  RCALL  1A64
....................      spi_xfer(SPIPORT2, adsress[3]);
01E3C:  MOVFF  1B9,2BD
01E40:  MOVLW  08
01E42:  MOVLB  2
01E44:  MOVWF  xBE
01E46:  MOVLW  01
01E48:  MOVWF  xBF
01E4A:  MOVLB  0
01E4C:  RCALL  1A64
....................  
....................      // Read the requested number of bytes
....................      for (int i = 0; i < data_number && i < 256; i++) {
01E4E:  MOVLB  2
01E50:  CLRF   xBA
01E52:  MOVLB  1
01E54:  MOVF   xB5,W
01E56:  MOVLB  2
01E58:  SUBWF  xBA,W
01E5A:  BC    1E9C
....................          Data_return[i] = spi_xfer(SPIPORT2, 0x00);  // Send dummy byte to receive data
01E5C:  CLRF   03
01E5E:  MOVF   xBA,W
01E60:  ADDLW  BA
01E62:  MOVWF  FE9
01E64:  MOVLW  01
01E66:  ADDWFC 03,W
01E68:  MOVWF  FEA
01E6A:  CLRF   xBD
01E6C:  MOVLW  08
01E6E:  MOVWF  xBE
01E70:  MOVLW  01
01E72:  MOVWF  xBF
01E74:  MOVLB  0
01E76:  RCALL  1A64
01E78:  MOVFF  01,FEF
....................          fprintf(EXT, "%c", Data_return[i]);         // Print each byte
01E7C:  CLRF   03
01E7E:  MOVLB  2
01E80:  MOVF   xBA,W
01E82:  ADDLW  BA
01E84:  MOVWF  FE9
01E86:  MOVLW  01
01E88:  ADDWFC 03,W
01E8A:  MOVWF  FEA
01E8C:  MOVFF  FEF,2F3
01E90:  MOVLB  0
01E92:  CALL   1260
01E96:  MOVLB  2
01E98:  INCF   xBA,F
01E9A:  BRA    1E52
....................      }
....................  
....................      output_high(CS_PIN_COM);  // Deselect SPI device
01E9C:  BCF    F93.3
01E9E:  BSF    F8A.3
....................      output_high(MX_PIN_COM);  // Deselect MUX from flash
01EA0:  BCF    F94.4
01EA2:  BSF    F8B.4
....................      fprintf(EXT, "\n");
01EA4:  MOVLW  0A
01EA6:  MOVWF  xF3
01EA8:  MOVLB  0
01EAA:  CALL   1260
....................  
....................      return Data_return;
01EAE:  MOVLW  BA
01EB0:  MOVWF  01
01EB2:  MOVLW  01
01EB4:  MOVWF  02
01EB6:  GOTO   476E (RETURN)
....................  }
.................... 
.................... #define MAX_DATA_SIZE 256  // Define the maximum data size
.................... 
.................... unsigned int8 Data_return[MAX_DATA_SIZE];  // Static buffer to hold the data
.................... 
.................... unsigned int8* READ_DATA_NBYTES_ADCS(unsigned int32 ADDRESS, unsigned short data_number) {
....................     unsigned int8 adsress[4];
.................... 
....................     // Ensure data_number does not exceed the maximum buffer size
....................     if (data_number > MAX_DATA_SIZE) {
....................         data_number = MAX_DATA_SIZE;
....................     }
.................... 
....................     // Byte extraction for a 32-bit address
....................     adsress[0] = (unsigned int8)((ADDRESS >> 24) & 0xFF);
*
03346:  MOVLB  1
03348:  MOVFF  1C8,1CA
0334C:  CLRF   03
....................     adsress[1] = (unsigned int8)((ADDRESS >> 16) & 0xFF);
0334E:  MOVFF  1C7,1CB
03352:  CLRF   03
....................     adsress[2] = (unsigned int8)((ADDRESS >> 8) & 0xFF);
03354:  MOVFF  1C6,1CC
03358:  CLRF   03
....................     adsress[3] = (unsigned int8)(ADDRESS & 0xFF);
0335A:  MOVFF  1C5,1CD
0335E:  CLRF   03
.................... 
....................     output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
03360:  BCF    F92.5
03362:  BCF    F89.5
....................     output_low(CS_PIN_MISSION);  // Select SPI device
03364:  BCF    F92.2
03366:  BCF    F89.2
.................... 
....................     // Send READ DATA COMMAND
....................     spi_xfer(SPIPORT3, READ_DATA_BYTES);
03368:  MOVLW  13
0336A:  MOVWF  xD2
0336C:  MOVLW  08
0336E:  MOVWF  xD3
03370:  MOVLW  01
03372:  MOVWF  xD4
03374:  MOVLB  0
03376:  CALL   1B3E
....................     // Send address bytes
....................     spi_xfer(SPIPORT3, adsress[0]);
0337A:  MOVFF  1CA,1D2
0337E:  MOVLW  08
03380:  MOVLB  1
03382:  MOVWF  xD3
03384:  MOVLW  01
03386:  MOVWF  xD4
03388:  MOVLB  0
0338A:  CALL   1B3E
....................     spi_xfer(SPIPORT3, adsress[1]);
0338E:  MOVFF  1CB,1D2
03392:  MOVLW  08
03394:  MOVLB  1
03396:  MOVWF  xD3
03398:  MOVLW  01
0339A:  MOVWF  xD4
0339C:  MOVLB  0
0339E:  CALL   1B3E
....................     spi_xfer(SPIPORT3, adsress[2]);
033A2:  MOVFF  1CC,1D2
033A6:  MOVLW  08
033A8:  MOVLB  1
033AA:  MOVWF  xD3
033AC:  MOVLW  01
033AE:  MOVWF  xD4
033B0:  MOVLB  0
033B2:  CALL   1B3E
....................     spi_xfer(SPIPORT3, adsress[3]);
033B6:  MOVFF  1CD,1D2
033BA:  MOVLW  08
033BC:  MOVLB  1
033BE:  MOVWF  xD3
033C0:  MOVLW  01
033C2:  MOVWF  xD4
033C4:  MOVLB  0
033C6:  CALL   1B3E
.................... 
....................     // Read the requested number of bytes
....................     for (int i = 0; i < data_number; i++) {
033CA:  MOVLB  1
033CC:  CLRF   xCE
033CE:  MOVF   xC9,W
033D0:  SUBWF  xCE,W
033D2:  BC    3444
....................         Data_return[i] = spi_xfer(SPIPORT3, 0x00);  // Send dummy byte to receive data
033D4:  CLRF   03
033D6:  MOVF   xCE,W
033D8:  ADDLW  06
033DA:  MOVWF  FE9
033DC:  MOVLW  00
033DE:  ADDWFC 03,W
033E0:  MOVWF  FEA
033E2:  CLRF   xD2
033E4:  MOVLW  08
033E6:  MOVWF  xD3
033E8:  MOVLW  01
033EA:  MOVWF  xD4
033EC:  MOVLB  0
033EE:  CALL   1B3E
033F2:  MOVFF  01,FEF
....................         fprintf(EXT, "  0x%02x", Data_return[i]);  // Print each byte (optional)
033F6:  CLRF   03
033F8:  MOVLB  1
033FA:  MOVF   xCE,W
033FC:  ADDLW  06
033FE:  MOVWF  FE9
03400:  MOVLW  00
03402:  ADDWFC 03,W
03404:  MOVWF  FEA
03406:  MOVFF  FEF,1CF
0340A:  MOVLW  B2
0340C:  MOVWF  FF6
0340E:  MOVLW  00
03410:  MOVWF  FF7
03412:  MOVLW  00
03414:  MOVWF  FF8
03416:  MOVLW  04
03418:  MOVLB  2
0341A:  MOVWF  xED
0341C:  MOVLB  0
0341E:  CALL   141E
03422:  MOVFF  1CF,2ED
03426:  MOVLW  57
03428:  MOVLB  2
0342A:  MOVWF  xEE
0342C:  MOVLB  0
0342E:  CALL   16DE
....................         fprintf(EXT, "\n");
03432:  MOVLW  0A
03434:  MOVLB  2
03436:  MOVWF  xF3
03438:  MOVLB  0
0343A:  CALL   1260
0343E:  MOVLB  1
03440:  INCF   xCE,F
03442:  BRA    33CE
....................     }
.................... 
....................     output_high(CS_PIN_MISSION);  // Deselect SPI device
03444:  BCF    F92.2
03446:  BSF    F89.2
....................     output_high(MX_PIN_ADCS);  // Deselect MUX from flash
03448:  BCF    F92.5
0344A:  BSF    F89.5
....................     fprintf(EXT, "\n");
0344C:  MOVLW  0A
0344E:  MOVLB  2
03450:  MOVWF  xF3
03452:  MOVLB  0
03454:  CALL   1260
.................... 
....................     return Data_return;
03458:  MOVLW  06
0345A:  MOVWF  01
0345C:  MOVLW  00
0345E:  MOVWF  02
03460:  RETURN 0
.................... }
....................  
....................  
....................  int8 READ_DATA_BYTES_ADCS(unsigned int32 ADDRESS) {
....................      unsigned int8 adsress[4];
....................      unsigned int8 Data_return;
....................     
....................      // Byte extraction for a 32-bit address
....................      adsress[0]  = (unsigned int8)((ADDRESS >> 24) & 0xFF);
....................      adsress[1]  = (unsigned int8)((ADDRESS >> 16) & 0xFF);
....................      adsress[2]  = (unsigned int8)((ADDRESS >> 8) & 0xFF);
....................      adsress[3]  = (unsigned int8)(ADDRESS & 0xFF);
....................  
....................      output_low(MX_PIN_ADCS);  // Lower MX to connect to flash device
....................      output_low(CS_PIN_MISSION);  // Select SPI device
....................  
....................      // Send READ DATA COMMAND (0x13 or appropriate for your flash chip)
....................      spi_xfer(SPIPORT3, READ_DATA_BYTES);
....................      // Send address bytes
....................      spi_xfer(SPIPORT3, adsress[0]);
....................      spi_xfer(SPIPORT3, adsress[1]);
....................      spi_xfer(SPIPORT3, adsress[2]);
....................      spi_xfer(SPIPORT3, adsress[3]);
....................      // Read the requested number of bytes
....................          Data_return = spi_xfer(SPIPORT3, 0x00);  // Send dummy byte to receive data
....................  
....................      output_high(CS_PIN_MISSION);  // Deselect SPI device after reading
....................      output_high(MX_PIN_ADCS);  //Deselect MUX from flash
....................      return Data_return;
....................  }
....................  void READ_CHIP_ID_OF() {
....................      int8 chip_id[8];
....................      output_low(CS_PIN_1);  // Lower the CS PIN
*
0234A:  BCF    F96.2
0234C:  BCF    F8D.2
....................      spi_xfer(SPIPORT, READ_ID);  // READ ID COMMAND (0x9F)
0234E:  MOVLW  9F
02350:  MOVLB  2
02352:  MOVWF  xEE
02354:  MOVLW  08
02356:  MOVWF  xEF
02358:  MOVLW  01
0235A:  MOVWF  xF0
0235C:  MOVLB  0
0235E:  CALL   15A4
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
02362:  MOVLB  1
02364:  CLRF   xE2
02366:  MOVF   xE2,W
02368:  SUBLW  07
0236A:  BNC   23C2
....................          chip_id[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy bytes to receive data
0236C:  CLRF   03
0236E:  MOVF   xE2,W
02370:  ADDLW  DA
02372:  MOVWF  FE9
02374:  MOVLW  01
02376:  ADDWFC 03,W
02378:  MOVWF  FEA
0237A:  MOVLB  2
0237C:  CLRF   xEE
0237E:  MOVLW  08
02380:  MOVWF  xEF
02382:  MOVLW  01
02384:  MOVWF  xF0
02386:  MOVLB  0
02388:  CALL   15A4
0238C:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
02390:  CLRF   03
02392:  MOVLB  1
02394:  MOVF   xE2,W
02396:  ADDLW  DA
02398:  MOVWF  FE9
0239A:  MOVLW  01
0239C:  ADDWFC 03,W
0239E:  MOVWF  FEA
023A0:  MOVFF  FEF,2ED
023A4:  MOVLW  37
023A6:  MOVLB  2
023A8:  MOVWF  xEE
023AA:  MOVLB  0
023AC:  CALL   16DE
023B0:  MOVLW  20
023B2:  MOVLB  2
023B4:  MOVWF  xF3
023B6:  MOVLB  0
023B8:  CALL   1260
023BC:  MOVLB  1
023BE:  INCF   xE2,F
023C0:  BRA    2366
....................      }
....................      fprintf(EXT,"\n");
023C2:  MOVLW  0A
023C4:  MOVLB  2
023C6:  MOVWF  xF3
023C8:  MOVLB  0
023CA:  CALL   1260
....................  
....................      output_high(CS_PIN_1);  // Raise CS PIN back
023CE:  BCF    F96.2
023D0:  BSF    F8D.2
023D2:  GOTO   2A8E (RETURN)
....................  }
....................  void READ_CHIP_ID_OF_COM() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_COM);
*
01AB0:  BCF    F94.4
01AB2:  BCF    F8B.4
....................      output_low(CS_PIN_COM);  // Lower the CS PIN
01AB4:  BCF    F93.3
01AB6:  BCF    F8A.3
....................      spi_xfer(SPIPORT2, READ_ID);  // READ ID COMMAND (0x9F)
01AB8:  MOVLW  9F
01ABA:  MOVLB  2
01ABC:  MOVWF  xBD
01ABE:  MOVLW  08
01AC0:  MOVWF  xBE
01AC2:  MOVLW  01
01AC4:  MOVWF  xBF
01AC6:  MOVLB  0
01AC8:  RCALL  1A64
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01ACA:  MOVLB  1
01ACC:  CLRF   xB9
01ACE:  MOVF   xB9,W
01AD0:  SUBLW  07
01AD2:  BNC   1B26
....................          chip_id[i] = spi_xfer(SPIPORT2, 0x00);  // Send dummy bytes to receive data
01AD4:  CLRF   03
01AD6:  MOVF   xB9,W
01AD8:  ADDLW  B1
01ADA:  MOVWF  FE9
01ADC:  MOVLW  01
01ADE:  ADDWFC 03,W
01AE0:  MOVWF  FEA
01AE2:  MOVLB  2
01AE4:  CLRF   xBD
01AE6:  MOVLW  08
01AE8:  MOVWF  xBE
01AEA:  MOVLW  01
01AEC:  MOVWF  xBF
01AEE:  MOVLB  0
01AF0:  RCALL  1A64
01AF2:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01AF6:  CLRF   03
01AF8:  MOVLB  1
01AFA:  MOVF   xB9,W
01AFC:  ADDLW  B1
01AFE:  MOVWF  FE9
01B00:  MOVLW  01
01B02:  ADDWFC 03,W
01B04:  MOVWF  FEA
01B06:  MOVFF  FEF,2ED
01B0A:  MOVLW  37
01B0C:  MOVLB  2
01B0E:  MOVWF  xEE
01B10:  MOVLB  0
01B12:  RCALL  16DE
01B14:  MOVLW  20
01B16:  MOVLB  2
01B18:  MOVWF  xF3
01B1A:  MOVLB  0
01B1C:  CALL   1260
01B20:  MOVLB  1
01B22:  INCF   xB9,F
01B24:  BRA    1ACE
....................      }
....................      fprintf(EXT,"\n");
01B26:  MOVLW  0A
01B28:  MOVLB  2
01B2A:  MOVWF  xF3
01B2C:  MOVLB  0
01B2E:  CALL   1260
....................  
....................      output_high(CS_PIN_COM);  // Raise CS PIN back
01B32:  BCF    F93.3
01B34:  BSF    F8A.3
....................      output_high(MX_PIN_COM);
01B36:  BCF    F94.4
01B38:  BSF    F8B.4
01B3A:  GOTO   4640 (RETURN)
....................  }
....................  
....................  void READ_CHIP_ID_OF_ADCS() {
....................      int8 chip_id[8];
....................      output_low(MX_PIN_ADCS);
*
01B8A:  BCF    F92.5
01B8C:  BCF    F89.5
....................      output_low(CS_PIN_MISSION);  // Lower the CS PIN
01B8E:  BCF    F92.2
01B90:  BCF    F89.2
....................      spi_xfer(SPIPORT3, READ_ID);  // READ ID COMMAND (0x9F)
01B92:  MOVLW  9F
01B94:  MOVLB  1
01B96:  MOVWF  xD2
01B98:  MOVLW  08
01B9A:  MOVWF  xD3
01B9C:  MOVLW  01
01B9E:  MOVWF  xD4
01BA0:  MOVLB  0
01BA2:  RCALL  1B3E
....................      
....................      // Receive 8 bytes of chip ID
....................      for (int i = 0; i < 8; i++) {
01BA4:  MOVLB  1
01BA6:  CLRF   xCD
01BA8:  MOVF   xCD,W
01BAA:  SUBLW  07
01BAC:  BNC   1BFE
....................          chip_id[i] = spi_xfer(SPIPORT3, 0x00);  // Send dummy bytes to receive data
01BAE:  CLRF   03
01BB0:  MOVF   xCD,W
01BB2:  ADDLW  C5
01BB4:  MOVWF  FE9
01BB6:  MOVLW  01
01BB8:  ADDWFC 03,W
01BBA:  MOVWF  FEA
01BBC:  CLRF   xD2
01BBE:  MOVLW  08
01BC0:  MOVWF  xD3
01BC2:  MOVLW  01
01BC4:  MOVWF  xD4
01BC6:  MOVLB  0
01BC8:  RCALL  1B3E
01BCA:  MOVFF  01,FEF
....................          fprintf(EXT, "%02X ", chip_id[i]);
01BCE:  CLRF   03
01BD0:  MOVLB  1
01BD2:  MOVF   xCD,W
01BD4:  ADDLW  C5
01BD6:  MOVWF  FE9
01BD8:  MOVLW  01
01BDA:  ADDWFC 03,W
01BDC:  MOVWF  FEA
01BDE:  MOVFF  FEF,2ED
01BE2:  MOVLW  37
01BE4:  MOVLB  2
01BE6:  MOVWF  xEE
01BE8:  MOVLB  0
01BEA:  RCALL  16DE
01BEC:  MOVLW  20
01BEE:  MOVLB  2
01BF0:  MOVWF  xF3
01BF2:  MOVLB  0
01BF4:  CALL   1260
01BF8:  MOVLB  1
01BFA:  INCF   xCD,F
01BFC:  BRA    1BA8
....................      }
....................      fprintf(EXT,"\n");
01BFE:  MOVLW  0A
01C00:  MOVLB  2
01C02:  MOVWF  xF3
01C04:  MOVLB  0
01C06:  CALL   1260
....................  
....................      output_high(CS_PIN_MISSION);  // Raise CS PIN back
01C0A:  BCF    F92.2
01C0C:  BSF    F89.2
....................      output_high(MX_PIN_ADCS);
01C0E:  BCF    F92.5
01C10:  BSF    F89.5
01C12:  RETURN 0
....................  }
.................... //  void READ_CHIP_ID_GENERIC(int SPIPORT, int CS_PIN, int MX_PIN) {
.................... //     int8 chip_id[8];
.................... 
.................... //     // Lower MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_low(MX_PIN);
.................... //     }
.................... 
.................... //     // Lower CS to select the SPI device
.................... //     output_low(CS_PIN);
.................... 
.................... //     // Send READ ID command
.................... //     spi_xfer(SPIPORT, READ_ID);
.................... 
.................... //     // Receive 8 bytes of chip ID
.................... //     for (int i = 0; i < 8; i++) {
.................... //         chip_id[i] = spi_xfer(SPIPORT, 0x00);  // Send dummy bytes to receive data
.................... //         fprintf(EXT, "%02X ", chip_id[i]);    // Print each byte in hex
.................... //     }
.................... //     fprintf(EXT, "\n");
.................... 
.................... //     // Raise CS to deselect the SPI device
.................... //     output_high(CS_PIN);
.................... 
.................... //     // Raise MUX pin if applicable
.................... //     if (MX_PIN != -1) {
.................... //         output_high(MX_PIN);
.................... //     }
.................... // }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //Command operation
....................  //void SEND_COMMAND_ADCS(void){
....................  //    WRITE_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS, ADCS_COMMAND,1);
....................  //}
....................  ////void READ_HK_ADCS(void){
....................  ////    int8 state_of_pin = 0;
....................  ////    
....................  ////    state_of_pin = input_state(EN_SUP_3V3_2);
....................  ////    if(state_of_pin = FALSE){ 
....................  ////        READ_DATA_NBYTES_ADCS(ADCS_HK_ADDRESS[16], READ_HK_ADCS, 16);
....................  ////        
....................  ////    }
....................  ////}
....................  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  ////EEPROM operation 
....................  ////thus functions used to store essential data order to prevent loosing it in unexpected shutdowns  
....................  //void EEPROM_
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // Main menu functions
....................  
....................  void startup_freeze(){
....................      delay_ms(2000);
*
012CE:  MOVLW  08
012D0:  MOVLB  1
012D2:  MOVWF  xB1
012D4:  MOVLW  FA
012D6:  MOVWF  xCD
012D8:  MOVLB  0
012DA:  RCALL  1236
012DC:  MOVLB  1
012DE:  DECFSZ xB1,F
012E0:  BRA    12D4
....................      fprintf(EXT, "POWER ON!\n");
012E2:  MOVLW  BC
012E4:  MOVWF  FF6
012E6:  MOVLW  00
012E8:  MOVWF  FF7
012EA:  MOVLW  00
012EC:  MOVWF  FF8
012EE:  MOVLB  0
012F0:  RCALL  12A6
....................      //EPS power control all disabled when startup, using menu function will turn on
....................      output_low(EN_SUP_3V3_1);
012F2:  BCF    F93.0
012F4:  BCF    F8A.0
....................      output_low(EN_SUP_3V3_2 );
012F6:  BCF    F98.1
012F8:  BCF    F8F.1
....................      output_low(EN_SUP_3V3_DAQ);
012FA:  BCF    F95.0
012FC:  BCF    F8C.0
....................      output_low(EN_SUP_UNREG);
012FE:  BCF    F93.1
01300:  BCF    F8A.1
....................      output_low(EN_SUP_5V0);
01302:  BCF    F95.1
01304:  BCF    F8C.1
....................      output_low(MVCAM_PWR);
01306:  BCF    F98.0
01308:  BCF    F8F.0
....................      output_low(OVCAM_PWR);
0130A:  BCF    F95.7
0130C:  BCF    F8C.7
....................      output_low(ADCS_PWR); //turns on the power of ADCS instantly 
0130E:  BCF    F95.6
01310:  BCF    F8C.6
....................      output_high(CS_PIN_1);
01312:  BCF    F96.2
01314:  BSF    F8D.2
....................      output_high(CS_PIN_COM );
01316:  BCF    F93.3
01318:  BSF    F8A.3
....................      output_high(CS_PIN_MISSION );
0131A:  BCF    F92.2
0131C:  BSF    F89.2
....................      output_high(MX_PIN_OVCAM );
0131E:  BCF    F98.2
01320:  BSF    F8F.2
....................      output_high(MX_PIN_MVCAM );
01322:  BCF    F98.3
01324:  BSF    F8F.3
....................      output_high(MX_PIN_ADCS );
01326:  BCF    F92.5
01328:  BSF    F89.5
....................      output_high(MX_PIN_COM );
0132A:  BCF    F94.4
0132C:  BSF    F8B.4
....................      
....................      fprintf(EXT, "Digital pin out configured \n");
0132E:  MOVLW  C8
01330:  MOVWF  FF6
01332:  MOVLW  00
01334:  MOVWF  FF7
01336:  MOVLW  00
01338:  MOVWF  FF8
0133A:  RCALL  12A6
0133C:  GOTO   4604 (RETURN)
....................          
....................  }
....................  //set RTCC functions counting to all zero 
....................  void set_clock(rtc_time_t &date_time){
....................  
....................     date_time.tm_year=0000;
*
01474:  MOVLB  1
01476:  CLRF   xB1
*
02D16:  MOVLB  1
02D18:  CLRF   xB3
....................     date_time.tm_mon=00;
*
01478:  CLRF   xB4
*
02D1A:  CLRF   xB6
....................     date_time.tm_mday=00;
*
0147A:  CLRF   xB3
*
02D1C:  CLRF   xB5
....................     date_time.tm_wday=00;
*
0147C:  CLRF   xB6
*
02D1E:  CLRF   xB8
....................     date_time.tm_hour=00;
*
0147E:  CLRF   xB5
*
02D20:  CLRF   xB7
....................     date_time.tm_min=00;
*
01480:  CLRF   xB8
*
02D22:  CLRF   xBA
....................     date_time.tm_sec=0; 
*
01482:  CLRF   xB7
01484:  MOVLB  F
*
02D24:  CLRF   xB9
02D26:  MOVLB  F
....................  }
.................... 
....................  void RTC_initialize(){
....................      setup_lcd(LCD_DISABLED);
*
0144E:  MOVLB  E
01450:  CLRF   xD6
01452:  CLRF   xD7
01454:  CLRF   xDA
01456:  CLRF   xD8
01458:  CLRF   xD9
0145A:  MOVLB  F
....................      rtc_time_t write_clock, read_clock;
....................      setup_rtc(RTC_ENABLE | RTC_CLOCK_SOSC | RTC_CLOCK_INT, 0);
0145C:  MOVLB  F
0145E:  MOVLW  55
01460:  MOVWF  F7E
01462:  MOVLW  AA
01464:  MOVWF  F7E
01466:  BSF    x5F.5
01468:  CLRF   x5E
0146A:  MOVLW  04
0146C:  MOVWF  x57
0146E:  MOVLW  80
01470:  MOVWF  x5F
01472:  BCF    x5F.5
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
01486:  MOVLB  F
01488:  MOVLW  55
0148A:  MOVWF  F7E
0148C:  MOVLW  AA
0148E:  MOVWF  F7E
01490:  BSF    x5F.5
01492:  BSF    x5F.0
01494:  BSF    x5F.1
01496:  MOVLW  01
01498:  MOVWF  FEA
0149A:  MOVLW  B1
0149C:  MOVWF  FE9
0149E:  MOVLW  04
014A0:  MOVWF  01
014A2:  MOVF   FEE,W
014A4:  MOVLB  0
014A6:  RCALL  1340
014A8:  MOVLB  F
014AA:  MOVWF  x5C
014AC:  MOVF   FEE,W
014AE:  MOVLB  0
014B0:  RCALL  1340
014B2:  MOVLB  F
014B4:  MOVWF  x5D
014B6:  DECFSZ 01,F
014B8:  BRA    14A2
014BA:  BCF    x5F.5
....................      rtc_read(&read_clock);
014BC:  BSF    x5F.0
014BE:  BSF    x5F.1
014C0:  MOVLW  01
014C2:  MOVWF  FEA
014C4:  MOVLW  BA
014C6:  MOVWF  FE9
014C8:  MOVLW  04
014CA:  MOVWF  01
014CC:  MOVF   x5C,W
014CE:  MOVLB  0
014D0:  RCALL  1364
014D2:  MOVWF  FEE
014D4:  MOVLB  F
014D6:  MOVF   x5D,W
014D8:  MOVLB  0
014DA:  RCALL  1364
014DC:  MOVWF  FEE
014DE:  DECFSZ 01,F
014E0:  BRA    14E4
014E2:  BRA    14E8
014E4:  MOVLB  F
014E6:  BRA    14CC
....................      read_clock.tm_year - 2000; 
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year , read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
014E8:  MOVLW  0D
014EA:  MOVLB  2
014EC:  MOVWF  xF3
014EE:  MOVLB  0
014F0:  RCALL  1260
014F2:  MOVFF  1BD,1C5
014F6:  MOVLW  01
014F8:  MOVLB  1
014FA:  MOVWF  xC6
014FC:  MOVLB  0
014FE:  RCALL  13A2
01500:  MOVLW  2F
01502:  MOVLB  2
01504:  MOVWF  xF3
01506:  MOVLB  0
01508:  RCALL  1260
0150A:  MOVFF  1BC,1C5
0150E:  MOVLW  01
01510:  MOVLB  1
01512:  MOVWF  xC6
01514:  MOVLB  0
01516:  RCALL  13A2
01518:  MOVLW  F0
0151A:  MOVWF  FF6
0151C:  MOVLW  00
0151E:  MOVWF  FF7
01520:  MOVLW  00
01522:  MOVWF  FF8
01524:  MOVLW  03
01526:  MOVLB  2
01528:  MOVWF  xED
0152A:  MOVLB  0
0152C:  RCALL  141E
0152E:  MOVFF  1BA,1C5
01532:  MOVLW  01
01534:  MOVLB  1
01536:  MOVWF  xC6
01538:  MOVLB  0
0153A:  RCALL  13A2
0153C:  MOVLW  20
0153E:  MOVLB  2
01540:  MOVWF  xF3
01542:  MOVLB  0
01544:  RCALL  1260
01546:  MOVFF  1BE,1C5
0154A:  MOVLW  01
0154C:  MOVLB  1
0154E:  MOVWF  xC6
01550:  MOVLB  0
01552:  RCALL  13A2
01554:  MOVLW  3A
01556:  MOVLB  2
01558:  MOVWF  xF3
0155A:  MOVLB  0
0155C:  RCALL  1260
0155E:  MOVFF  1C1,1C5
01562:  MOVLW  01
01564:  MOVLB  1
01566:  MOVWF  xC6
01568:  MOVLB  0
0156A:  RCALL  13A2
0156C:  MOVLW  3A
0156E:  MOVLB  2
01570:  MOVWF  xF3
01572:  MOVLB  0
01574:  RCALL  1260
01576:  MOVFF  1C0,1C5
0157A:  MOVLW  01
0157C:  MOVLB  1
0157E:  MOVWF  xC6
01580:  MOVLB  0
01582:  RCALL  13A2
.................... 
....................      fprintf(EXT, "RTCC setup finished!\n");
01584:  MOVLW  08
01586:  MOVWF  FF6
01588:  MOVLW  01
0158A:  MOVWF  FF7
0158C:  MOVLW  00
0158E:  MOVWF  FF8
01590:  RCALL  12A6
....................      fprintf(EXT, "RTCC setup finished!\n");
01592:  MOVLW  1E
01594:  MOVWF  FF6
01596:  MOVLW  01
01598:  MOVWF  FF7
0159A:  MOVLW  00
0159C:  MOVWF  FF8
0159E:  RCALL  12A6
015A0:  GOTO   4608 (RETURN)
....................  
....................  }
....................  
....................  //this function will receive from EPS and sent to external port of EXT single character by character   
....................  void uart_repeater() {
....................      int received_data;
....................      while (TRUE) {
....................          // Check if data is available on the EPS stream
....................          if (kbhit(EPS)) {
*
030C4:  BTFSC  F84.4
030C6:  BRA    30D6
....................              // Read one byte from the EPS stream
....................              received_data = fgetc(EPS);
030C8:  RCALL  307A
030CA:  MOVFF  01,1B2
....................              // Send the received byte to the EXT stream
....................              fputc(received_data, EXT);
030CE:  MOVFF  1B2,2F3
030D2:  CALL   1260
....................          }
030D6:  BRA    30C4
....................      }
030D8:  GOTO   44E6 (RETURN)
....................  }
....................  // Function to receive exactly 16 bytes from UART
....................  void receive_16_bytes(int8* buffer) {
....................      for (int8 i = 0; i < 16; i++) {
....................          buffer[i] = getc(EPS);  // Blocks until a byte is received
....................      }
....................  }
....................  
....................  
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  //adcs command
....................  //
....................  //#define SHUTDOWN_COUNT_ADDRESS  0x00001000  // Address where shutdown count is stored
....................  // this function is not working correctly need to fix it 
....................  int8 *read_data_adcs; //ADCS flash received data will be stored in here 
.................... int8 adcs_mission[3] = {0x33, 0x05, 0x05}; // mission command for ADCS all sensors will run for 3 minutes 
.................... int8 adcs_mag[3] = {0x22, 0x01, 0x05}; // mag each 9 bytes for measurement
.................... int8 adcs_gyro[3] = {0x11, 0x01, 0x05}; // gyro each 9 bytes for measurement 
.................... int8 last_adcs[5] = {0x00, 0x00, 0x00, 0x00, 0x00}; // last command for ADCS 
....................                 // (how many measurements are taken), (last address of the data)x4 not inverted
....................                 // we will multiply measurement size and how many measurements are taken and subtract from the last address
....................                 // to get the first measurement address of the data
....................                 // later we will read the data from the first address to the last address
.................... int8 adcs_status_address = 0x00020000; // status address of the adcs first byte is measrument count /each 9 byte/, last 4 is last address
.................... int8 adcs_gyro_first_address = 0x00030000; // first address of the gyro data 
....................  void adcs_mission_mode(void){
....................      output_high(ADCS_PWR);
*
03462:  BCF    F95.6
03464:  BSF    F8C.6
.................... delay_ms(1000);
03466:  MOVLW  04
03468:  MOVLB  1
0346A:  MOVWF  xC5
0346C:  MOVLW  FA
0346E:  MOVWF  xCD
03470:  MOVLB  0
03472:  CALL   1236
03476:  MOVLB  1
03478:  DECFSZ xC5,F
0347A:  BRA    346C
.................... READ_CHIP_ID_OF_ADCS();
0347C:  MOVLB  0
0347E:  CALL   1B8A
.................... fprintf(EXT, "deleting command address of the adcs\n");
03482:  MOVLW  34
03484:  MOVWF  FF6
03486:  MOVLW  01
03488:  MOVWF  FF7
0348A:  MOVLW  00
0348C:  MOVWF  FF8
0348E:  CALL   12A6
.................... SECTOR_ERASE_OF_ADCS(0x00000000);
03492:  MOVLB  1
03494:  CLRF   xC8
03496:  CLRF   xC7
03498:  CLRF   xC6
0349A:  CLRF   xC5
0349C:  MOVLB  0
0349E:  BRA    3102
.................... delay_ms(100);
034A0:  MOVLW  64
034A2:  MOVLB  1
034A4:  MOVWF  xCD
034A6:  MOVLB  0
034A8:  CALL   1236
.................... //SECTOR_ERASE_OF_ADCS(0x00020000);
.................... delay_ms(100);
034AC:  MOVLW  64
034AE:  MOVLB  1
034B0:  MOVWF  xCD
034B2:  MOVLB  0
034B4:  CALL   1236
.................... fprintf(EXT, "Command address of the adcs is deleted!\n");
034B8:  MOVLW  5A
034BA:  MOVWF  FF6
034BC:  MOVLW  01
034BE:  MOVWF  FF7
034C0:  MOVLW  00
034C2:  MOVWF  FF8
034C4:  CALL   12A6
.................... delay_ms(100);
034C8:  MOVLW  64
034CA:  MOVLB  1
034CC:  MOVWF  xCD
034CE:  MOVLB  0
034D0:  CALL   1236
.................... fprintf(EXT, "Sending command to the adcs\n");
034D4:  MOVLW  84
034D6:  MOVWF  FF6
034D8:  MOVLW  01
034DA:  MOVWF  FF7
034DC:  MOVLW  00
034DE:  MOVWF  FF8
034E0:  CALL   12A6
.................... 
.................... // Write and read from ADCS flash memory
.................... fprintf(EXT, "Starting to write data in ADCS flash memory\n");
034E4:  MOVLW  A2
034E6:  MOVWF  FF6
034E8:  MOVLW  01
034EA:  MOVWF  FF7
034EC:  MOVLW  00
034EE:  MOVWF  FF8
034F0:  CALL   12A6
.................... WRITE_DATA_NBYTES_ADCS(0x00000000, adcs_gyro, sizeof(adcs_gyro));
034F4:  MOVLB  1
034F6:  CLRF   xC8
034F8:  CLRF   xC7
034FA:  CLRF   xC6
034FC:  CLRF   xC5
034FE:  MOVLW  01
03500:  MOVWF  xCA
03502:  MOVLW  10
03504:  MOVWF  xC9
03506:  MOVLW  03
03508:  MOVWF  xCB
0350A:  MOVLB  0
0350C:  BRA    31AE
.................... delay_ms(100);
0350E:  MOVLW  64
03510:  MOVLB  1
03512:  MOVWF  xCD
03514:  MOVLB  0
03516:  CALL   1236
.................... read_data_adcs = READ_DATA_NBYTES_ADCS(0x00000000, sizeof(adcs_gyro));
0351A:  MOVLB  1
0351C:  CLRF   xC8
0351E:  CLRF   xC7
03520:  CLRF   xC6
03522:  CLRF   xC5
03524:  MOVLW  03
03526:  MOVWF  xC9
03528:  MOVLB  0
0352A:  RCALL  3346
0352C:  MOVFF  02,109
03530:  MOVFF  01,108
.................... delay_ms(100);
03534:  MOVLW  64
03536:  MOVLB  1
03538:  MOVWF  xCD
0353A:  MOVLB  0
0353C:  CALL   1236
.................... for (int i = 0; i < sizeof(adcs_gyro); i++) {
03540:  MOVLB  1
03542:  CLRF   xB3
03544:  MOVF   xB3,W
03546:  SUBLW  02
03548:  BNC   3572
....................     fprintf(EXT, "%c", read_data_adcs[i]);
0354A:  MOVF   xB3,W
0354C:  ADDWF  x08,W
0354E:  MOVWF  FE9
03550:  MOVLW  00
03552:  ADDWFC x09,W
03554:  MOVWF  FEA
03556:  MOVFF  FEF,2F3
0355A:  MOVLB  0
0355C:  CALL   1260
....................     delay_ms(2);
03560:  MOVLW  02
03562:  MOVLB  1
03564:  MOVWF  xCD
03566:  MOVLB  0
03568:  CALL   1236
0356C:  MOVLB  1
0356E:  INCF   xB3,F
03570:  BRA    3544
.................... }
.................... fprintf(EXT, "\n"); 
03572:  MOVLW  0A
03574:  MOVLB  2
03576:  MOVWF  xF3
03578:  MOVLB  0
0357A:  CALL   1260
.................... fprintf(EXT, "ADCS command is written!\n");
0357E:  MOVLW  D0
03580:  MOVWF  FF6
03582:  MOVLW  01
03584:  MOVWF  FF7
03586:  MOVLW  00
03588:  MOVWF  FF8
0358A:  CALL   12A6
.................... 
.................... // Wait 70 seconds for ADCS to complete the mission
.................... for (int i = 0; i < 7; i++) {
0358E:  MOVLB  1
03590:  CLRF   xB4
03592:  MOVF   xB4,W
03594:  SUBLW  06
03596:  BNC   35F2
....................     fprintf(EXT, "waiting for adcs to finish 70s/%d0s\n", i);
03598:  MOVLW  EA
0359A:  MOVWF  FF6
0359C:  MOVLW  01
0359E:  MOVWF  FF7
035A0:  MOVLW  00
035A2:  MOVWF  FF8
035A4:  MOVLW  1F
035A6:  MOVLB  2
035A8:  MOVWF  xED
035AA:  MOVLB  0
035AC:  CALL   141E
035B0:  MOVFF  1B4,2ED
035B4:  MOVLW  18
035B6:  MOVLB  2
035B8:  MOVWF  xEE
035BA:  MOVLB  0
035BC:  CALL   1742
035C0:  MOVLW  0B
035C2:  MOVWF  FF6
035C4:  MOVLW  02
035C6:  MOVWF  FF7
035C8:  MOVLW  00
035CA:  MOVWF  FF8
035CC:  MOVLW  03
035CE:  MOVLB  2
035D0:  MOVWF  xED
035D2:  MOVLB  0
035D4:  CALL   141E
....................     delay_ms(10000);
035D8:  MOVLW  28
035DA:  MOVLB  1
035DC:  MOVWF  xC5
035DE:  MOVLW  FA
035E0:  MOVWF  xCD
035E2:  MOVLB  0
035E4:  CALL   1236
035E8:  MOVLB  1
035EA:  DECFSZ xC5,F
035EC:  BRA    35DE
035EE:  INCF   xB4,F
035F0:  BRA    3592
.................... }
.................... fprintf(EXT, "ADCS command is finished!\n");
035F2:  MOVLW  10
035F4:  MOVWF  FF6
035F6:  MOVLW  02
035F8:  MOVWF  FF7
035FA:  MOVLW  00
035FC:  MOVWF  FF8
035FE:  MOVLB  0
03600:  CALL   12A6
.................... 
.................... // Read status and last address from ADCS
.................... fprintf(EXT, "reading the status address of the adcs!\n");
03604:  MOVLW  2C
03606:  MOVWF  FF6
03608:  MOVLW  02
0360A:  MOVWF  FF7
0360C:  MOVLW  00
0360E:  MOVWF  FF8
03610:  CALL   12A6
.................... read_data_adcs = READ_DATA_NBYTES_ADCS(0x00020000, 5); // Read 5 bytes: 1 for status, 4 for last address
03614:  MOVLB  1
03616:  CLRF   xC8
03618:  MOVLW  02
0361A:  MOVWF  xC7
0361C:  CLRF   xC6
0361E:  CLRF   xC5
03620:  MOVLW  05
03622:  MOVWF  xC9
03624:  MOVLB  0
03626:  RCALL  3346
03628:  MOVFF  02,109
0362C:  MOVFF  01,108
.................... delay_ms(100);
03630:  MOVLW  64
03632:  MOVLB  1
03634:  MOVWF  xCD
03636:  MOVLB  0
03638:  CALL   1236
.................... 
.................... // Extract status and last address
.................... int8 adcs_status = read_data_adcs[0];  // Number of measurements (status)
.................... int32 last_adcs_address = 0;
0363C:  MOVLB  1
0363E:  MOVFF  108,FE9
03642:  MOVFF  109,FEA
03646:  MOVFF  FEF,1B5
0364A:  CLRF   xB9
0364C:  CLRF   xB8
0364E:  CLRF   xB7
03650:  CLRF   xB6
.................... for (int i = 1; i < 5; i++) {
03652:  MOVLW  01
03654:  MOVWF  xBA
03656:  MOVF   xBA,W
03658:  SUBLW  04
0365A:  BNC   3680
....................     last_adcs_address = (last_adcs_address << 8) | (int8)read_data_adcs[i]; // Combine 4 bytes into a 32-bit address
0365C:  MOVFF  1B8,1B9
03660:  MOVFF  1B7,1B8
03664:  MOVFF  1B6,1B7
03668:  CLRF   xC6
0366A:  MOVF   xBA,W
0366C:  ADDWF  x08,W
0366E:  MOVWF  FE9
03670:  MOVLW  00
03672:  ADDWFC x09,W
03674:  MOVWF  FEA
03676:  MOVF   FEF,W
03678:  IORWF  xC6,W
0367A:  MOVWF  xB6
0367C:  INCF   xBA,F
0367E:  BRA    3656
.................... }
.................... fprintf(EXT, "ADCS status: %d, last address: 0x%08x\n", adcs_status, last_adcs_address);
03680:  MOVLW  56
03682:  MOVWF  FF6
03684:  MOVLW  02
03686:  MOVWF  FF7
03688:  MOVLW  00
0368A:  MOVWF  FF8
0368C:  MOVLW  0D
0368E:  MOVLB  2
03690:  MOVWF  xED
03692:  MOVLB  0
03694:  CALL   141E
03698:  MOVFF  1B5,2ED
0369C:  MOVLW  18
0369E:  MOVLB  2
036A0:  MOVWF  xEE
036A2:  MOVLB  0
036A4:  CALL   1742
036A8:  MOVLW  65
036AA:  MOVWF  FF6
036AC:  MOVLW  02
036AE:  MOVWF  FF7
036B0:  MOVLW  00
036B2:  MOVWF  FF8
036B4:  MOVLW  12
036B6:  MOVLB  2
036B8:  MOVWF  xED
036BA:  MOVLB  0
036BC:  CALL   141E
036C0:  MOVLW  06
036C2:  MOVLB  1
036C4:  MOVWF  xC5
036C6:  MOVLW  30
036C8:  MOVLB  2
036CA:  MOVWF  xF3
036CC:  MOVLB  0
036CE:  CALL   1260
036D2:  MOVLB  1
036D4:  DECFSZ xC5,F
036D6:  BRA    36C6
036D8:  MOVFF  1B6,2ED
036DC:  MOVLW  57
036DE:  MOVLB  2
036E0:  MOVWF  xEE
036E2:  MOVLB  0
036E4:  CALL   16DE
036E8:  MOVLW  0A
036EA:  MOVLB  2
036EC:  MOVWF  xF3
036EE:  MOVLB  0
036F0:  CALL   1260
.................... 
.................... // Handle mission status
.................... if (adcs_status <= 0) {  // Assuming 0 or -1 indicates failure based on your original code
036F4:  MOVLB  1
036F6:  MOVF   xB5,F
036F8:  BNZ   373A
....................     fprintf(EXT, "ADCS mission failed!\n");
036FA:  MOVLW  7E
036FC:  MOVWF  FF6
036FE:  MOVLW  02
03700:  MOVWF  FF7
03702:  MOVLW  00
03704:  MOVWF  FF8
03706:  MOVLB  0
03708:  CALL   12A6
....................     while (TRUE) {
....................         fprintf(EXT, "ADCS mission failed!\n");
0370C:  MOVLW  94
0370E:  MOVWF  FF6
03710:  MOVLW  02
03712:  MOVWF  FF7
03714:  MOVLW  00
03716:  MOVWF  FF8
03718:  CALL   12A6
....................         delay_ms(5000);
0371C:  MOVLW  14
0371E:  MOVLB  1
03720:  MOVWF  xC5
03722:  MOVLW  FA
03724:  MOVWF  xCD
03726:  MOVLB  0
03728:  CALL   1236
0372C:  MOVLB  1
0372E:  DECFSZ xC5,F
03730:  BRA    3722
03732:  MOVLB  0
03734:  BRA    370C
....................     }
.................... } else {
03736:  BRA    390C
03738:  MOVLB  1
....................     fprintf(EXT, "ADCS mission success with %d measurements!\n", adcs_status);
0373A:  MOVLW  AA
0373C:  MOVWF  FF6
0373E:  MOVLW  02
03740:  MOVWF  FF7
03742:  MOVLW  00
03744:  MOVWF  FF8
03746:  MOVLW  1A
03748:  MOVLB  2
0374A:  MOVWF  xED
0374C:  MOVLB  0
0374E:  CALL   141E
03752:  MOVFF  1B5,2ED
03756:  MOVLW  18
03758:  MOVLB  2
0375A:  MOVWF  xEE
0375C:  MOVLB  0
0375E:  CALL   1742
03762:  MOVLW  C6
03764:  MOVWF  FF6
03766:  MOVLW  02
03768:  MOVWF  FF7
0376A:  MOVLW  00
0376C:  MOVWF  FF8
0376E:  MOVLW  0F
03770:  MOVLB  2
03772:  MOVWF  xED
03774:  MOVLB  0
03776:  CALL   141E
.................... 
....................     // Calculate the first data address
....................     int32 first_adcs_data_address = last_adcs_address - (adcs_status * 9); // Each measurement is 9 bytes
0377A:  MOVLB  1
0377C:  MOVF   xB5,W
0377E:  MULLW  09
03780:  MOVF   FF3,W
03782:  SUBWF  xB6,W
03784:  MOVWF  xBB
03786:  MOVLW  00
03788:  SUBWFB xB7,W
0378A:  MOVWF  xBC
0378C:  MOVLW  00
0378E:  SUBWFB xB8,W
03790:  MOVWF  xBD
03792:  MOVLW  00
03794:  SUBWFB xB9,W
03796:  MOVWF  xBE
....................     fprintf(EXT, "First data address: 0x%08x\n", first_adcs_data_address);
03798:  MOVLW  D6
0379A:  MOVWF  FF6
0379C:  MOVLW  02
0379E:  MOVWF  FF7
037A0:  MOVLW  00
037A2:  MOVWF  FF8
037A4:  MOVLW  16
037A6:  MOVLB  2
037A8:  MOVWF  xED
037AA:  MOVLB  0
037AC:  CALL   141E
037B0:  MOVLW  06
037B2:  MOVLB  1
037B4:  MOVWF  xC5
037B6:  MOVLW  30
037B8:  MOVLB  2
037BA:  MOVWF  xF3
037BC:  MOVLB  0
037BE:  CALL   1260
037C2:  MOVLB  1
037C4:  DECFSZ xC5,F
037C6:  BRA    37B6
037C8:  MOVFF  1BB,2ED
037CC:  MOVLW  57
037CE:  MOVLB  2
037D0:  MOVWF  xEE
037D2:  MOVLB  0
037D4:  CALL   16DE
037D8:  MOVLW  0A
037DA:  MOVLB  2
037DC:  MOVWF  xF3
037DE:  MOVLB  0
037E0:  CALL   1260
.................... 
....................     // Read and print each measurement
....................     for (int i = 0; i < adcs_status; i++) {
037E4:  MOVLB  1
037E6:  CLRF   xBF
037E8:  MOVF   xB5,W
037EA:  SUBWF  xBF,W
037EC:  BTFSC  FD8.0
037EE:  BRA    390A
....................         int32 current_address = first_adcs_data_address + (i * 9);
037F0:  MOVF   xBF,W
037F2:  MULLW  09
037F4:  MOVF   FF3,W
037F6:  ADDWF  xBB,W
037F8:  MOVWF  xC0
037FA:  MOVLW  00
037FC:  ADDWFC xBC,W
037FE:  MOVWF  xC1
03800:  MOVLW  00
03802:  ADDWFC xBD,W
03804:  MOVWF  xC2
03806:  MOVLW  00
03808:  ADDWFC xBE,W
0380A:  MOVWF  xC3
....................         read_data_adcs = READ_DATA_NBYTES_ADCS(current_address, 9); // Read 9 bytes per measurement
0380C:  MOVFF  1C3,1C8
03810:  MOVFF  1C2,1C7
03814:  MOVFF  1C1,1C6
03818:  MOVFF  1C0,1C5
0381C:  MOVLW  09
0381E:  MOVWF  xC9
03820:  MOVLB  0
03822:  RCALL  3346
03824:  MOVFF  02,109
03828:  MOVFF  01,108
....................         fprintf(EXT, "Measurement %d at address 0x%08x: ", i + 1, current_address);
0382C:  MOVLW  01
0382E:  MOVLB  1
03830:  ADDWF  xBF,W
03832:  MOVWF  xC5
03834:  MOVLW  F2
03836:  MOVWF  FF6
03838:  MOVLW  02
0383A:  MOVWF  FF7
0383C:  MOVLW  00
0383E:  MOVWF  FF8
03840:  MOVLW  0C
03842:  MOVLB  2
03844:  MOVWF  xED
03846:  MOVLB  0
03848:  CALL   141E
0384C:  MOVFF  1C5,2ED
03850:  MOVLW  18
03852:  MOVLB  2
03854:  MOVWF  xEE
03856:  MOVLB  0
03858:  CALL   1742
0385C:  MOVLW  00
0385E:  MOVWF  FF6
03860:  MOVLW  03
03862:  MOVWF  FF7
03864:  MOVLW  00
03866:  MOVWF  FF8
03868:  MOVLW  0E
0386A:  MOVLB  2
0386C:  MOVWF  xED
0386E:  MOVLB  0
03870:  CALL   141E
03874:  MOVLW  06
03876:  MOVLB  1
03878:  MOVWF  xC6
0387A:  MOVLW  30
0387C:  MOVLB  2
0387E:  MOVWF  xF3
03880:  MOVLB  0
03882:  CALL   1260
03886:  MOVLB  1
03888:  DECFSZ xC6,F
0388A:  BRA    387A
0388C:  MOVFF  1C0,2ED
03890:  MOVLW  57
03892:  MOVLB  2
03894:  MOVWF  xEE
03896:  MOVLB  0
03898:  CALL   16DE
0389C:  MOVLW  3A
0389E:  MOVLB  2
038A0:  MOVWF  xF3
038A2:  MOVLB  0
038A4:  CALL   1260
038A8:  MOVLW  20
038AA:  MOVLB  2
038AC:  MOVWF  xF3
038AE:  MOVLB  0
038B0:  CALL   1260
....................         for (int j = 0; j < 9; j++) {
038B4:  MOVLB  1
038B6:  CLRF   xC4
038B8:  MOVF   xC4,W
038BA:  SUBLW  08
038BC:  BNC   38EC
....................             fprintf(EXT, "%02x ", (int8)read_data_adcs[j]); // Print each byte in hex
038BE:  MOVF   xC4,W
038C0:  ADDWF  x08,W
038C2:  MOVWF  FE9
038C4:  MOVLW  00
038C6:  ADDWFC x09,W
038C8:  MOVWF  FEA
038CA:  MOVFF  FEF,2ED
038CE:  MOVLW  57
038D0:  MOVLB  2
038D2:  MOVWF  xEE
038D4:  MOVLB  0
038D6:  CALL   16DE
038DA:  MOVLW  20
038DC:  MOVLB  2
038DE:  MOVWF  xF3
038E0:  MOVLB  0
038E2:  CALL   1260
038E6:  MOVLB  1
038E8:  INCF   xC4,F
038EA:  BRA    38B8
....................         }
....................         fprintf(EXT, "\n");
038EC:  MOVLW  0A
038EE:  MOVLB  2
038F0:  MOVWF  xF3
038F2:  MOVLB  0
038F4:  CALL   1260
....................         delay_ms(2); // Small delay between reads
038F8:  MOVLW  02
038FA:  MOVLB  1
038FC:  MOVWF  xCD
038FE:  MOVLB  0
03900:  CALL   1236
03904:  MOVLB  1
03906:  INCF   xBF,F
03908:  BRA    37E8
0390A:  MOVLB  0
....................     }
.................... }
.................... output_low(ADCS_PWR);
0390C:  BCF    F95.6
0390E:  BCF    F8C.6
03910:  GOTO   4322 (RETURN)
....................  }
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
....................  // eps functions 
....................  char cmd = 'G'; // Command character to trigger EPS
.................... unsigned int8 temperature[7];
.................... unsigned int8 solar_panel_current[5];
.................... unsigned int8 solar_panel_voltage[5];
.................... unsigned int8 sc_pwr;
.................... unsigned int8 sc_i_sens;
.................... unsigned int8 batt_i_sens;
.................... unsigned int8 batt_pwr;
.................... unsigned int8 raw_i_sens;
.................... unsigned int8 raw_v_sens;
.................... unsigned int8 batt_temp;
.................... unsigned int8 DCDC_output_i[5];
.................... bool KS_OBC_STAT;
.................... bool KS_EPS_STAT;
.................... 
.................... // Function to receive 33 bytes from EPS into the buffer
.................... void get_data(char* buffer) {
....................     putc(cmd, EPS); // Send command to EPS
*
03982:  MOVFF  11A,1D7
03986:  BRA    393A
....................     for (int8 i = 0; i < 33; i++) {
03988:  MOVLB  1
0398A:  CLRF   xD6
0398C:  MOVF   xD6,W
0398E:  SUBLW  20
03990:  BNC   39BE
....................         buffer[i] = fgetc(EPS); // Receive byte from EPS (blocks until received)
03992:  MOVF   xD6,W
03994:  ADDWF  xD4,W
03996:  MOVWF  FE9
03998:  MOVLW  00
0399A:  ADDWFC xD5,W
0399C:  MOVWF  FEA
0399E:  MOVFF  FEA,1DA
039A2:  MOVFF  FE9,1D9
039A6:  MOVLB  0
039A8:  CALL   307A
039AC:  MOVFF  1DA,FEA
039B0:  MOVFF  1D9,FE9
039B4:  MOVFF  01,FEF
039B8:  MOVLB  1
039BA:  INCF   xD6,F
039BC:  BRA    398C
....................     }
039BE:  MOVLB  0
039C0:  GOTO   4272 (RETURN)
.................... }
.................... 
.................... // Function to send 33 bytes to EXT
.................... void send_data(char* buffer) {
....................     for (int8 i = 0; i < 33; i++) {
*
04214:  MOVLB  1
04216:  CLRF   xD6
04218:  MOVF   xD6,W
0421A:  SUBLW  20
0421C:  BNC   423A
....................         putc(buffer[i], EXT); // Send each byte to EXT
0421E:  MOVF   xD6,W
04220:  ADDWF  xD4,W
04222:  MOVWF  FE9
04224:  MOVLW  00
04226:  ADDWFC xD5,W
04228:  MOVWF  FEA
0422A:  MOVFF  FEF,2F3
0422E:  MOVLB  0
04230:  CALL   1260
04234:  MOVLB  1
04236:  INCF   xD6,F
04238:  BRA    4218
....................     }
....................     printf(EXT, "\n"); // Newline after sending all bytes
0423A:  CLRF   FEA
0423C:  MOVLW  02
0423E:  MOVWF  FE9
04240:  MOVLB  0
04242:  CALL   3914
04246:  GOTO   4292 (RETURN)
.................... }
.................... // Function to store data
.................... void store_eps_data(unsigned int8* buffer) {
....................     if (buffer[0] == '}' && buffer[32] == 'f') {
*
039C4:  MOVLB  1
039C6:  MOVFF  1D4,FE9
039CA:  MOVFF  1D5,FEA
039CE:  MOVF   FEF,W
039D0:  SUBLW  7D
039D2:  BTFSS  FD8.2
039D4:  BRA    3B3A
039D6:  MOVLW  20
039D8:  ADDWF  xD4,W
039DA:  MOVWF  FE9
039DC:  MOVLW  00
039DE:  ADDWFC xD5,W
039E0:  MOVWF  FEA
039E2:  MOVF   FEF,W
039E4:  SUBLW  66
039E6:  BTFSS  FD8.2
039E8:  BRA    3B3A
....................         memcpy(temperature, &buffer[1], 7);
039EA:  MOVLW  01
039EC:  ADDWF  xD4,W
039EE:  MOVWF  01
039F0:  MOVLW  00
039F2:  ADDWFC xD5,W
039F4:  MOVWF  03
039F6:  MOVFF  01,1D6
039FA:  MOVWF  xD7
039FC:  MOVLW  01
039FE:  MOVWF  FEA
03A00:  MOVLW  1B
03A02:  MOVWF  FE9
03A04:  MOVFF  03,FE2
03A08:  MOVFF  01,FE1
03A0C:  MOVLW  07
03A0E:  MOVWF  01
03A10:  MOVFF  FE6,FEE
03A14:  DECFSZ 01,F
03A16:  BRA    3A10
....................         memcpy(solar_panel_current, &buffer[8], 5);
03A18:  MOVLW  08
03A1A:  ADDWF  xD4,W
03A1C:  MOVWF  01
03A1E:  MOVLW  00
03A20:  ADDWFC xD5,W
03A22:  MOVWF  03
03A24:  MOVFF  01,1D6
03A28:  MOVWF  xD7
03A2A:  MOVLW  01
03A2C:  MOVWF  FEA
03A2E:  MOVLW  22
03A30:  MOVWF  FE9
03A32:  MOVFF  03,FE2
03A36:  MOVFF  01,FE1
03A3A:  MOVLW  05
03A3C:  MOVWF  01
03A3E:  MOVFF  FE6,FEE
03A42:  DECFSZ 01,F
03A44:  BRA    3A3E
....................         memcpy(solar_panel_voltage, &buffer[13], 5);
03A46:  MOVLW  0D
03A48:  ADDWF  xD4,W
03A4A:  MOVWF  01
03A4C:  MOVLW  00
03A4E:  ADDWFC xD5,W
03A50:  MOVWF  03
03A52:  MOVFF  01,1D6
03A56:  MOVWF  xD7
03A58:  MOVLW  01
03A5A:  MOVWF  FEA
03A5C:  MOVLW  27
03A5E:  MOVWF  FE9
03A60:  MOVFF  03,FE2
03A64:  MOVFF  01,FE1
03A68:  MOVLW  05
03A6A:  MOVWF  01
03A6C:  MOVFF  FE6,FEE
03A70:  DECFSZ 01,F
03A72:  BRA    3A6C
....................         sc_pwr = buffer[18];
03A74:  MOVLW  12
03A76:  ADDWF  xD4,W
03A78:  MOVWF  FE9
03A7A:  MOVLW  00
03A7C:  ADDWFC xD5,W
03A7E:  MOVWF  FEA
03A80:  MOVFF  FEF,12C
....................         sc_i_sens = buffer[19];
03A84:  MOVLW  13
03A86:  ADDWF  xD4,W
03A88:  MOVWF  FE9
03A8A:  MOVLW  00
03A8C:  ADDWFC xD5,W
03A8E:  MOVWF  FEA
03A90:  MOVFF  FEF,12D
....................         batt_i_sens = buffer[20];
03A94:  MOVLW  14
03A96:  ADDWF  xD4,W
03A98:  MOVWF  FE9
03A9A:  MOVLW  00
03A9C:  ADDWFC xD5,W
03A9E:  MOVWF  FEA
03AA0:  MOVFF  FEF,12E
....................         batt_pwr = buffer[21];
03AA4:  MOVLW  15
03AA6:  ADDWF  xD4,W
03AA8:  MOVWF  FE9
03AAA:  MOVLW  00
03AAC:  ADDWFC xD5,W
03AAE:  MOVWF  FEA
03AB0:  MOVFF  FEF,12F
....................         raw_i_sens = buffer[22];
03AB4:  MOVLW  16
03AB6:  ADDWF  xD4,W
03AB8:  MOVWF  FE9
03ABA:  MOVLW  00
03ABC:  ADDWFC xD5,W
03ABE:  MOVWF  FEA
03AC0:  MOVFF  FEF,130
....................         raw_v_sens = buffer[23];
03AC4:  MOVLW  17
03AC6:  ADDWF  xD4,W
03AC8:  MOVWF  FE9
03ACA:  MOVLW  00
03ACC:  ADDWFC xD5,W
03ACE:  MOVWF  FEA
03AD0:  MOVFF  FEF,131
....................         batt_temp = buffer[24];
03AD4:  MOVLW  18
03AD6:  ADDWF  xD4,W
03AD8:  MOVWF  FE9
03ADA:  MOVLW  00
03ADC:  ADDWFC xD5,W
03ADE:  MOVWF  FEA
03AE0:  MOVFF  FEF,132
....................         memcpy(DCDC_output_i, &buffer[25], 5);
03AE4:  MOVLW  19
03AE6:  ADDWF  xD4,W
03AE8:  MOVWF  01
03AEA:  MOVLW  00
03AEC:  ADDWFC xD5,W
03AEE:  MOVWF  03
03AF0:  MOVFF  01,1D6
03AF4:  MOVWF  xD7
03AF6:  MOVLW  01
03AF8:  MOVWF  FEA
03AFA:  MOVLW  33
03AFC:  MOVWF  FE9
03AFE:  MOVFF  03,FE2
03B02:  MOVFF  01,FE1
03B06:  MOVLW  05
03B08:  MOVWF  01
03B0A:  MOVFF  FE6,FEE
03B0E:  DECFSZ 01,F
03B10:  BRA    3B0A
....................         KS_OBC_STAT = buffer[30] != 0;
03B12:  BCF    x38.0
03B14:  MOVLW  1E
03B16:  ADDWF  xD4,W
03B18:  MOVWF  FE9
03B1A:  MOVLW  00
03B1C:  ADDWFC xD5,W
03B1E:  MOVWF  FEA
03B20:  MOVF   FEF,F
03B22:  BZ    3B26
03B24:  BSF    x38.0
....................         KS_EPS_STAT = buffer[31] != 0;
03B26:  BCF    x38.1
03B28:  MOVLW  1F
03B2A:  ADDWF  xD4,W
03B2C:  MOVWF  FE9
03B2E:  MOVLW  00
03B30:  ADDWFC xD5,W
03B32:  MOVWF  FEA
03B34:  MOVF   FEF,F
03B36:  BZ    3B3A
03B38:  BSF    x38.1
....................     }
03B3A:  MOVLB  0
03B3C:  GOTO   4282 (RETURN)
.................... }
.................... void print_table() {
....................     printf(EXT, "%-15s | %-8s | %-12s\n", "Variable", "Original", "Processed (V/A)");
*
03DCA:  CLRF   FEA
03DCC:  MOVLW  02
03DCE:  MOVWF  FE9
03DD0:  RCALL  3914
....................     printf(EXT, "--------------------------------------------------\n");
03DD2:  CLRF   FEA
03DD4:  MOVLW  02
03DD6:  MOVWF  FE9
03DD8:  RCALL  3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_pwr", sc_pwr, ((sc_pwr * 3.3) / 256.0) / 20.0);
03DDA:  MOVLB  1
03DDC:  CLRF   xD5
03DDE:  MOVFF  12C,1D4
03DE2:  MOVLB  0
03DE4:  RCALL  3B40
03DE6:  MOVFF  03,1D7
03DEA:  MOVFF  02,1D6
03DEE:  MOVFF  01,1D5
03DF2:  MOVFF  00,1D4
03DF6:  MOVLW  33
03DF8:  MOVLB  1
03DFA:  MOVWF  xDB
03DFC:  MOVWF  xDA
03DFE:  MOVLW  53
03E00:  MOVWF  xD9
03E02:  MOVLW  80
03E04:  MOVWF  xD8
03E06:  MOVLB  0
03E08:  RCALL  3B76
03E0A:  MOVFF  03,1D7
03E0E:  MOVFF  02,1D6
03E12:  MOVFF  01,1D5
03E16:  MOVFF  00,1D4
03E1A:  MOVFF  03,1DB
03E1E:  MOVFF  02,1DA
03E22:  MOVFF  01,1D9
03E26:  MOVFF  00,1D8
03E2A:  MOVLB  1
03E2C:  CLRF   xDF
03E2E:  CLRF   xDE
03E30:  CLRF   xDD
03E32:  MOVLW  87
03E34:  MOVWF  xDC
03E36:  MOVLB  0
03E38:  RCALL  3C6C
03E3A:  MOVFF  03,1D7
03E3E:  MOVFF  02,1D6
03E42:  MOVFF  01,1D5
03E46:  MOVFF  00,1D4
03E4A:  MOVFF  03,1DB
03E4E:  MOVFF  02,1DA
03E52:  MOVFF  01,1D9
03E56:  MOVFF  00,1D8
03E5A:  MOVLB  1
03E5C:  CLRF   xDF
03E5E:  CLRF   xDE
03E60:  MOVLW  20
03E62:  MOVWF  xDD
03E64:  MOVLW  83
03E66:  MOVWF  xDC
03E68:  MOVLB  0
03E6A:  RCALL  3C6C
03E6C:  MOVFF  03,1D7
03E70:  MOVFF  02,1D6
03E74:  MOVFF  01,1D5
03E78:  MOVFF  00,1D4
03E7C:  CLRF   FEA
03E7E:  MOVLW  02
03E80:  MOVWF  FE9
03E82:  RCALL  3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "sc_i_sens", sc_i_sens, ((sc_i_sens * 3.3) / 256.0) / 20.0);
03E84:  MOVLB  1
03E86:  CLRF   xD5
03E88:  MOVFF  12D,1D4
03E8C:  MOVLB  0
03E8E:  RCALL  3B40
03E90:  MOVFF  03,1D7
03E94:  MOVFF  02,1D6
03E98:  MOVFF  01,1D5
03E9C:  MOVFF  00,1D4
03EA0:  MOVLW  33
03EA2:  MOVLB  1
03EA4:  MOVWF  xDB
03EA6:  MOVWF  xDA
03EA8:  MOVLW  53
03EAA:  MOVWF  xD9
03EAC:  MOVLW  80
03EAE:  MOVWF  xD8
03EB0:  MOVLB  0
03EB2:  RCALL  3B76
03EB4:  MOVFF  03,1D7
03EB8:  MOVFF  02,1D6
03EBC:  MOVFF  01,1D5
03EC0:  MOVFF  00,1D4
03EC4:  MOVFF  03,1DB
03EC8:  MOVFF  02,1DA
03ECC:  MOVFF  01,1D9
03ED0:  MOVFF  00,1D8
03ED4:  MOVLB  1
03ED6:  CLRF   xDF
03ED8:  CLRF   xDE
03EDA:  CLRF   xDD
03EDC:  MOVLW  87
03EDE:  MOVWF  xDC
03EE0:  MOVLB  0
03EE2:  RCALL  3C6C
03EE4:  MOVFF  03,1D7
03EE8:  MOVFF  02,1D6
03EEC:  MOVFF  01,1D5
03EF0:  MOVFF  00,1D4
03EF4:  MOVFF  03,1DB
03EF8:  MOVFF  02,1DA
03EFC:  MOVFF  01,1D9
03F00:  MOVFF  00,1D8
03F04:  MOVLB  1
03F06:  CLRF   xDF
03F08:  CLRF   xDE
03F0A:  MOVLW  20
03F0C:  MOVWF  xDD
03F0E:  MOVLW  83
03F10:  MOVWF  xDC
03F12:  MOVLB  0
03F14:  RCALL  3C6C
03F16:  MOVFF  03,1D7
03F1A:  MOVFF  02,1D6
03F1E:  MOVFF  01,1D5
03F22:  MOVFF  00,1D4
03F26:  CLRF   FEA
03F28:  MOVLW  02
03F2A:  MOVWF  FE9
03F2C:  RCALL  3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_i_sens", raw_i_sens, ((raw_i_sens * 3.3) / 256.0) / 20.0);
03F2E:  MOVLB  1
03F30:  CLRF   xD5
03F32:  MOVFF  130,1D4
03F36:  MOVLB  0
03F38:  RCALL  3B40
03F3A:  MOVFF  03,1D7
03F3E:  MOVFF  02,1D6
03F42:  MOVFF  01,1D5
03F46:  MOVFF  00,1D4
03F4A:  MOVLW  33
03F4C:  MOVLB  1
03F4E:  MOVWF  xDB
03F50:  MOVWF  xDA
03F52:  MOVLW  53
03F54:  MOVWF  xD9
03F56:  MOVLW  80
03F58:  MOVWF  xD8
03F5A:  MOVLB  0
03F5C:  RCALL  3B76
03F5E:  MOVFF  03,1D7
03F62:  MOVFF  02,1D6
03F66:  MOVFF  01,1D5
03F6A:  MOVFF  00,1D4
03F6E:  MOVFF  03,1DB
03F72:  MOVFF  02,1DA
03F76:  MOVFF  01,1D9
03F7A:  MOVFF  00,1D8
03F7E:  MOVLB  1
03F80:  CLRF   xDF
03F82:  CLRF   xDE
03F84:  CLRF   xDD
03F86:  MOVLW  87
03F88:  MOVWF  xDC
03F8A:  MOVLB  0
03F8C:  RCALL  3C6C
03F8E:  MOVFF  03,1D7
03F92:  MOVFF  02,1D6
03F96:  MOVFF  01,1D5
03F9A:  MOVFF  00,1D4
03F9E:  MOVFF  03,1DB
03FA2:  MOVFF  02,1DA
03FA6:  MOVFF  01,1D9
03FAA:  MOVFF  00,1D8
03FAE:  MOVLB  1
03FB0:  CLRF   xDF
03FB2:  CLRF   xDE
03FB4:  MOVLW  20
03FB6:  MOVWF  xDD
03FB8:  MOVLW  83
03FBA:  MOVWF  xDC
03FBC:  MOVLB  0
03FBE:  RCALL  3C6C
03FC0:  MOVFF  03,1D7
03FC4:  MOVFF  02,1D6
03FC8:  MOVFF  01,1D5
03FCC:  MOVFF  00,1D4
03FD0:  CLRF   FEA
03FD2:  MOVLW  02
03FD4:  MOVWF  FE9
03FD6:  RCALL  3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "raw_v_sens", raw_v_sens, ((raw_v_sens * 3.3) / 256.0) / 20.0);
03FD8:  MOVLB  1
03FDA:  CLRF   xD5
03FDC:  MOVFF  131,1D4
03FE0:  MOVLB  0
03FE2:  RCALL  3B40
03FE4:  MOVFF  03,1D7
03FE8:  MOVFF  02,1D6
03FEC:  MOVFF  01,1D5
03FF0:  MOVFF  00,1D4
03FF4:  MOVLW  33
03FF6:  MOVLB  1
03FF8:  MOVWF  xDB
03FFA:  MOVWF  xDA
03FFC:  MOVLW  53
03FFE:  MOVWF  xD9
04000:  MOVLW  80
04002:  MOVWF  xD8
04004:  MOVLB  0
04006:  RCALL  3B76
04008:  MOVFF  03,1D7
0400C:  MOVFF  02,1D6
04010:  MOVFF  01,1D5
04014:  MOVFF  00,1D4
04018:  MOVFF  03,1DB
0401C:  MOVFF  02,1DA
04020:  MOVFF  01,1D9
04024:  MOVFF  00,1D8
04028:  MOVLB  1
0402A:  CLRF   xDF
0402C:  CLRF   xDE
0402E:  CLRF   xDD
04030:  MOVLW  87
04032:  MOVWF  xDC
04034:  MOVLB  0
04036:  RCALL  3C6C
04038:  MOVFF  03,1D7
0403C:  MOVFF  02,1D6
04040:  MOVFF  01,1D5
04044:  MOVFF  00,1D4
04048:  MOVFF  03,1DB
0404C:  MOVFF  02,1DA
04050:  MOVFF  01,1D9
04054:  MOVFF  00,1D8
04058:  MOVLB  1
0405A:  CLRF   xDF
0405C:  CLRF   xDE
0405E:  MOVLW  20
04060:  MOVWF  xDD
04062:  MOVLW  83
04064:  MOVWF  xDC
04066:  MOVLB  0
04068:  RCALL  3C6C
0406A:  MOVFF  03,1D7
0406E:  MOVFF  02,1D6
04072:  MOVFF  01,1D5
04076:  MOVFF  00,1D4
0407A:  CLRF   FEA
0407C:  MOVLW  02
0407E:  MOVWF  FE9
04080:  RCALL  3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_pwr", batt_pwr, ((batt_pwr * 3.3) / 256.0) / 20.0);
04082:  MOVLB  1
04084:  CLRF   xD5
04086:  MOVFF  12F,1D4
0408A:  MOVLB  0
0408C:  RCALL  3B40
0408E:  MOVFF  03,1D7
04092:  MOVFF  02,1D6
04096:  MOVFF  01,1D5
0409A:  MOVFF  00,1D4
0409E:  MOVLW  33
040A0:  MOVLB  1
040A2:  MOVWF  xDB
040A4:  MOVWF  xDA
040A6:  MOVLW  53
040A8:  MOVWF  xD9
040AA:  MOVLW  80
040AC:  MOVWF  xD8
040AE:  MOVLB  0
040B0:  RCALL  3B76
040B2:  MOVFF  03,1D7
040B6:  MOVFF  02,1D6
040BA:  MOVFF  01,1D5
040BE:  MOVFF  00,1D4
040C2:  MOVFF  03,1DB
040C6:  MOVFF  02,1DA
040CA:  MOVFF  01,1D9
040CE:  MOVFF  00,1D8
040D2:  MOVLB  1
040D4:  CLRF   xDF
040D6:  CLRF   xDE
040D8:  CLRF   xDD
040DA:  MOVLW  87
040DC:  MOVWF  xDC
040DE:  MOVLB  0
040E0:  RCALL  3C6C
040E2:  MOVFF  03,1D7
040E6:  MOVFF  02,1D6
040EA:  MOVFF  01,1D5
040EE:  MOVFF  00,1D4
040F2:  MOVFF  03,1DB
040F6:  MOVFF  02,1DA
040FA:  MOVFF  01,1D9
040FE:  MOVFF  00,1D8
04102:  MOVLB  1
04104:  CLRF   xDF
04106:  CLRF   xDE
04108:  MOVLW  20
0410A:  MOVWF  xDD
0410C:  MOVLW  83
0410E:  MOVWF  xDC
04110:  MOVLB  0
04112:  RCALL  3C6C
04114:  MOVFF  03,1D7
04118:  MOVFF  02,1D6
0411C:  MOVFF  01,1D5
04120:  MOVFF  00,1D4
04124:  CLRF   FEA
04126:  MOVLW  02
04128:  MOVWF  FE9
0412A:  CALL   3914
....................     printf(EXT, "%-15s | %-8u | %.6f\n", "batt_i_sens", batt_i_sens, ((batt_i_sens * 3.3) / 256.0) / 20.0);
0412E:  MOVLB  1
04130:  CLRF   xD5
04132:  MOVFF  12E,1D4
04136:  MOVLB  0
04138:  RCALL  3B40
0413A:  MOVFF  03,1D7
0413E:  MOVFF  02,1D6
04142:  MOVFF  01,1D5
04146:  MOVFF  00,1D4
0414A:  MOVLW  33
0414C:  MOVLB  1
0414E:  MOVWF  xDB
04150:  MOVWF  xDA
04152:  MOVLW  53
04154:  MOVWF  xD9
04156:  MOVLW  80
04158:  MOVWF  xD8
0415A:  MOVLB  0
0415C:  RCALL  3B76
0415E:  MOVFF  03,1D7
04162:  MOVFF  02,1D6
04166:  MOVFF  01,1D5
0416A:  MOVFF  00,1D4
0416E:  MOVFF  03,1DB
04172:  MOVFF  02,1DA
04176:  MOVFF  01,1D9
0417A:  MOVFF  00,1D8
0417E:  MOVLB  1
04180:  CLRF   xDF
04182:  CLRF   xDE
04184:  CLRF   xDD
04186:  MOVLW  87
04188:  MOVWF  xDC
0418A:  MOVLB  0
0418C:  RCALL  3C6C
0418E:  MOVFF  03,1D7
04192:  MOVFF  02,1D6
04196:  MOVFF  01,1D5
0419A:  MOVFF  00,1D4
0419E:  MOVFF  03,1DB
041A2:  MOVFF  02,1DA
041A6:  MOVFF  01,1D9
041AA:  MOVFF  00,1D8
041AE:  MOVLB  1
041B0:  CLRF   xDF
041B2:  CLRF   xDE
041B4:  MOVLW  20
041B6:  MOVWF  xDD
041B8:  MOVLW  83
041BA:  MOVWF  xDC
041BC:  MOVLB  0
041BE:  RCALL  3C6C
041C0:  MOVFF  03,1D7
041C4:  MOVFF  02,1D6
041C8:  MOVFF  01,1D5
041CC:  MOVFF  00,1D4
041D0:  CLRF   FEA
041D2:  MOVLW  02
041D4:  MOVWF  FE9
041D6:  CALL   3914
....................     printf(EXT, "\n"); // Add a newline after the table
041DA:  CLRF   FEA
041DC:  MOVLW  02
041DE:  MOVWF  FE9
041E0:  CALL   3914
....................     printf(EXT, "KS of OBC status is %d", KS_OBC_STAT);
041E4:  MOVLW  00
041E6:  MOVLB  1
041E8:  BTFSC  x38.0
041EA:  MOVLW  01
041EC:  MOVWF  xD4
041EE:  CLRF   FEA
041F0:  MOVLW  02
041F2:  MOVWF  FE9
041F4:  MOVLB  0
041F6:  CALL   3914
....................     printf(EXT, "KS of EPS status is %d", KS_EPS_STAT);
041FA:  MOVLW  00
041FC:  MOVLB  1
041FE:  BTFSC  x38.1
04200:  MOVLW  01
04202:  MOVWF  xD4
04204:  CLRF   FEA
04206:  MOVLW  02
04208:  MOVWF  FE9
0420A:  MOVLB  0
0420C:  CALL   3914
04210:  GOTO   4284 (RETURN)
.................... }
.................... // Main function to test UART communication
.................... void eps_mission_mode(void) {
....................     output_high(EN_SUP_3V3_DAQ); // Enable 3.3V supply for DAQ
*
0424A:  BCF    F95.0
0424C:  BSF    F8C.0
....................     printf(EXT, "EPS power on!\n");  // Initial message to EXT
0424E:  CLRF   FEA
04250:  MOVLW  02
04252:  MOVWF  FE9
04254:  CALL   3914
.................... 
....................     char buffer[33]; // Buffer to hold 33 bytes
.................... 
....................         printf(EXT, "Sending request...\n");
04258:  CLRF   FEA
0425A:  MOVLW  02
0425C:  MOVWF  FE9
0425E:  CALL   3914
....................         get_data(buffer);          // Get data from EPS
04262:  MOVLW  01
04264:  MOVLB  1
04266:  MOVWF  xD5
04268:  MOVLW  B3
0426A:  MOVWF  xD4
0426C:  MOVLB  0
0426E:  GOTO   3982
....................         store_eps_data(buffer);    // Parse buffer into variables
04272:  MOVLW  01
04274:  MOVLB  1
04276:  MOVWF  xD5
04278:  MOVLW  B3
0427A:  MOVWF  xD4
0427C:  MOVLB  0
0427E:  GOTO   39C4
....................         print_table();             // Print the table
04282:  BRA    3DCA
....................         send_data(buffer);         // Forward data to EXT
04284:  MOVLW  01
04286:  MOVLB  1
04288:  MOVWF  xD5
0428A:  MOVLW  B3
0428C:  MOVWF  xD4
0428E:  MOVLB  0
04290:  BRA    4214
04292:  GOTO   4322 (RETURN)
....................     
.................... }
....................  
....................  int8 update_shutdown_count(void) {
....................      fprintf(EXT, "Shutdown count started\n");
*
01966:  MOVLW  16
01968:  MOVWF  FF6
0196A:  MOVLW  03
0196C:  MOVWF  FF7
0196E:  MOVLW  00
01970:  MOVWF  FF8
01972:  RCALL  12A6
....................  
....................      // Read shutdown count directly from memory
....................      unsigned char shutdown_count[1];
....................      shutdown_count[0] = READ_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, 1); // Updated call
01974:  MOVLB  1
01976:  CLRF   xDD
01978:  MOVLW  10
0197A:  MOVWF  xDC
0197C:  CLRF   xDB
0197E:  MOVLW  11
01980:  MOVWF  xDA
01982:  MOVLW  01
01984:  MOVWF  xDE
01986:  MOVLB  0
01988:  RCALL  15F0
0198A:  MOVFF  01,1B1
....................      delay_ms(10);
0198E:  MOVLW  0A
01990:  MOVLB  1
01992:  MOVWF  xCD
01994:  MOVLB  0
01996:  RCALL  1236
....................  
....................      fprintf(EXT, "Read shutdown count: %u\n", shutdown_count[0]);
01998:  MOVLW  2E
0199A:  MOVWF  FF6
0199C:  MOVLW  03
0199E:  MOVWF  FF7
019A0:  MOVLW  00
019A2:  MOVWF  FF8
019A4:  MOVLW  15
019A6:  MOVLB  2
019A8:  MOVWF  xED
019AA:  MOVLB  0
019AC:  RCALL  141E
019AE:  MOVFF  1B1,1C5
019B2:  MOVLW  1B
019B4:  MOVLB  1
019B6:  MOVWF  xC6
019B8:  MOVLB  0
019BA:  RCALL  13A2
019BC:  MOVLW  0A
019BE:  MOVLB  2
019C0:  MOVWF  xF3
019C2:  MOVLB  0
019C4:  RCALL  1260
....................  
....................      shutdown_count[0]++;  // Increment the shutdown count
019C6:  MOVLB  1
019C8:  INCF   xB1,F
....................      fprintf(EXT, "Incremented shutdown count: %u\n", shutdown_count[0]);
019CA:  MOVLW  48
019CC:  MOVWF  FF6
019CE:  MOVLW  03
019D0:  MOVWF  FF7
019D2:  MOVLW  00
019D4:  MOVWF  FF8
019D6:  MOVLW  1C
019D8:  MOVLB  2
019DA:  MOVWF  xED
019DC:  MOVLB  0
019DE:  RCALL  141E
019E0:  MOVFF  1B1,1C5
019E4:  MOVLW  1B
019E6:  MOVLB  1
019E8:  MOVWF  xC6
019EA:  MOVLB  0
019EC:  RCALL  13A2
019EE:  MOVLW  0A
019F0:  MOVLB  2
019F2:  MOVWF  xF3
019F4:  MOVLB  0
019F6:  RCALL  1260
....................  
....................      // Write the updated shutdown count back to memory
....................      WRITE_DATA_NBYTES(SHUTDOWN_COUNT_ADDRESS, shutdown_count, 1);
019F8:  MOVLB  2
019FA:  CLRF   xE4
019FC:  MOVLW  10
019FE:  MOVWF  xE3
01A00:  CLRF   xE2
01A02:  MOVLW  11
01A04:  MOVWF  xE1
01A06:  MOVLW  01
01A08:  MOVWF  xE6
01A0A:  MOVLW  B1
01A0C:  MOVWF  xE5
01A0E:  MOVLW  01
01A10:  MOVWF  xE7
01A12:  MOVLB  0
01A14:  RCALL  17FE
....................      delay_ms(10);
01A16:  MOVLW  0A
01A18:  MOVLB  1
01A1A:  MOVWF  xCD
01A1C:  MOVLB  0
01A1E:  RCALL  1236
....................  
....................      fprintf(EXT, "Now shutdown count is : %u\n\n", shutdown_count[0]);
01A20:  MOVLW  68
01A22:  MOVWF  FF6
01A24:  MOVLW  03
01A26:  MOVWF  FF7
01A28:  MOVLW  00
01A2A:  MOVWF  FF8
01A2C:  MOVLW  18
01A2E:  MOVLB  2
01A30:  MOVWF  xED
01A32:  MOVLB  0
01A34:  RCALL  141E
01A36:  MOVFF  1B1,1C5
01A3A:  MOVLW  1B
01A3C:  MOVLB  1
01A3E:  MOVWF  xC6
01A40:  MOVLB  0
01A42:  RCALL  13A2
01A44:  MOVLW  0A
01A46:  MOVLB  2
01A48:  MOVWF  xF3
01A4A:  MOVLB  0
01A4C:  RCALL  1260
01A4E:  MOVLW  0A
01A50:  MOVLB  2
01A52:  MOVWF  xF3
01A54:  MOVLB  0
01A56:  RCALL  1260
....................  
....................      return shutdown_count[0];
01A58:  MOVLB  1
01A5A:  MOVFF  1B1,01
01A5E:  MOVLB  0
01A60:  GOTO   460C (RETURN)
....................  }
....................  
....................  
....................  //main flash memory consol for main_menu() function
....................  void write_to_main_flash_menu(){
....................              unsigned int32 address;
....................              unsigned int8 data[256]; // Buffer for data to be written (adjust size as needed)
....................              unsigned char data_number;
....................              unsigned char choice;
....................              unsigned int8 i;
....................              // Prompt user to enter the address
....................              fprintf(EXT, "\nEnter Address (hex, 0x1234): 0x");
*
02630:  MOVLW  86
02632:  MOVWF  FF6
02634:  MOVLW  03
02636:  MOVWF  FF7
02638:  MOVLW  00
0263A:  MOVWF  FF8
0263C:  CALL   12A6
....................              fscanf(EXT, "%x", &address); // Read address input in hex
02640:  MOVLB  2
02642:  CLRF   xE1
02644:  CLRF   xE2
02646:  MOVLW  01
02648:  MOVWF  xE4
0264A:  MOVLW  DA
0264C:  MOVWF  xE3
0264E:  CLRF   xE6
02650:  CLRF   xE5
02652:  MOVLB  0
02654:  RCALL  2450
02656:  MOVF   01,F
02658:  BNZ   2662
0265A:  MOVLB  2
0265C:  CLRF   xE2
0265E:  BRA    266A
02660:  MOVLB  0
02662:  MOVF   01,W
02664:  MOVLB  2
02666:  ADDWF  xE1,F
02668:  INCF   xE2,F
....................  
....................              // Prompt user to enter the number of bytes
....................              fprintf(EXT, "\nEnter number of bytes to write (max 256): ");
0266A:  MOVLW  A8
0266C:  MOVWF  FF6
0266E:  MOVLW  03
02670:  MOVWF  FF7
02672:  MOVLW  00
02674:  MOVWF  FF8
02676:  MOVLB  0
02678:  CALL   12A6
....................              fscanf(EXT, "%x", &data_number); // Read number of bytes
0267C:  MOVLB  2
0267E:  CLRF   xE1
02680:  CLRF   xE2
02682:  MOVLW  02
02684:  MOVWF  xE6
02686:  MOVLW  DE
02688:  MOVWF  xE5
0268A:  CLRF   xE8
0268C:  CLRF   xE7
0268E:  MOVLB  0
02690:  RCALL  2560
02692:  MOVF   01,F
02694:  BNZ   269E
02696:  MOVLB  2
02698:  CLRF   xE2
0269A:  BRA    26A6
0269C:  MOVLB  0
0269E:  MOVF   01,W
026A0:  MOVLB  2
026A2:  ADDWF  xE1,F
026A4:  INCF   xE2,F
....................  
.................... //             if (data_number > 256) {
.................... //                 fprintf(EXT, "Error: Maximum data length is 256 bytes.\n");
.................... //                 continue;
.................... //             }
....................  
....................              // Get data from user
....................              fprintf(EXT, "Enter %d bytes of data (in hex):\n", data_number);
026A6:  MOVLW  D4
026A8:  MOVWF  FF6
026AA:  MOVLW  03
026AC:  MOVWF  FF7
026AE:  MOVLW  00
026B0:  MOVWF  FF8
026B2:  MOVLW  06
026B4:  MOVWF  xED
026B6:  MOVLB  0
026B8:  CALL   141E
026BC:  MOVFF  2DE,2ED
026C0:  MOVLW  18
026C2:  MOVLB  2
026C4:  MOVWF  xEE
026C6:  MOVLB  0
026C8:  CALL   1742
026CC:  MOVLW  DC
026CE:  MOVWF  FF6
026D0:  MOVLW  03
026D2:  MOVWF  FF7
026D4:  MOVLW  00
026D6:  MOVWF  FF8
026D8:  MOVLW  19
026DA:  MOVLB  2
026DC:  MOVWF  xED
026DE:  MOVLB  0
026E0:  CALL   141E
....................              for (i = 0; i < data_number; i++) {
026E4:  MOVLB  2
026E6:  CLRF   xE0
026E8:  MOVF   xDE,W
026EA:  SUBWF  xE0,W
026EC:  BC    2774
....................                  fprintf(EXT, "Byte %d: 0x", i + 1);
026EE:  MOVLW  01
026F0:  ADDWF  xE0,W
026F2:  MOVWF  xE1
026F4:  MOVLW  F6
026F6:  MOVWF  FF6
026F8:  MOVLW  03
026FA:  MOVWF  FF7
026FC:  MOVLW  00
026FE:  MOVWF  FF8
02700:  MOVLW  05
02702:  MOVWF  xED
02704:  MOVLB  0
02706:  CALL   141E
0270A:  MOVFF  2E1,2ED
0270E:  MOVLW  18
02710:  MOVLB  2
02712:  MOVWF  xEE
02714:  MOVLB  0
02716:  CALL   1742
0271A:  MOVLW  FD
0271C:  MOVWF  FF6
0271E:  MOVLW  03
02720:  MOVWF  FF7
02722:  MOVLW  00
02724:  MOVWF  FF8
02726:  MOVLW  04
02728:  MOVLB  2
0272A:  MOVWF  xED
0272C:  MOVLB  0
0272E:  CALL   141E
....................                  fscanf(EXT, "%x", &data[i]); // Read byte in hex format
02732:  CLRF   03
02734:  MOVLB  2
02736:  MOVF   xE0,W
02738:  ADDLW  DE
0273A:  MOVWF  01
0273C:  MOVLW  01
0273E:  ADDWFC 03,F
02740:  MOVFF  01,2E1
02744:  MOVFF  03,2E2
02748:  CLRF   xE3
0274A:  CLRF   xE4
0274C:  MOVFF  03,2E6
02750:  MOVFF  01,2E5
02754:  CLRF   xE8
02756:  CLRF   xE7
02758:  MOVLB  0
0275A:  RCALL  2560
0275C:  MOVF   01,F
0275E:  BNZ   2768
02760:  MOVLB  2
02762:  CLRF   xE4
02764:  BRA    2770
02766:  MOVLB  0
02768:  MOVF   01,W
0276A:  MOVLB  2
0276C:  ADDWF  xE3,F
0276E:  INCF   xE4,F
02770:  INCF   xE0,F
02772:  BRA    26E8
....................              }
....................  
....................              // Call the function to write data to the address
....................              WRITE_DATA_NBYTES(address, data, data_number);
02774:  MOVFF  1DD,2E4
02778:  MOVFF  1DC,2E3
0277C:  MOVFF  1DB,2E2
02780:  MOVFF  1DA,2E1
02784:  MOVLW  01
02786:  MOVWF  xE6
02788:  MOVLW  DE
0278A:  MOVWF  xE5
0278C:  MOVFF  2DE,2E7
02790:  MOVLB  0
02792:  CALL   17FE
....................  
....................              fprintf(EXT, "\nData successfully written.\n");
02796:  MOVLW  02
02798:  MOVWF  FF6
0279A:  MOVLW  04
0279C:  MOVWF  FF7
0279E:  MOVLW  00
027A0:  MOVWF  FF8
027A2:  CALL   12A6
027A6:  GOTO   2A8E (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_main_flash_memory() {
....................      char main_flash_option;
....................      unsigned int32 address;
....................      unsigned char data[32];
....................      unsigned char data_length;
....................  
....................      fprintf(EXT, "MAIN flash memory chosen\n");
*
028D6:  MOVLW  20
028D8:  MOVWF  FF6
028DA:  MOVLW  04
028DC:  MOVWF  FF7
028DE:  MOVLW  00
028E0:  MOVWF  FF8
028E2:  CALL   12A6
....................      fprintf(EXT, "press a: Read ID of the chip\n");
028E6:  MOVLW  3A
028E8:  MOVWF  FF6
028EA:  MOVLW  04
028EC:  MOVWF  FF7
028EE:  MOVLW  00
028F0:  MOVWF  FF8
028F2:  CALL   12A6
....................      fprintf(EXT, "press b: Write data set in specified address\n");
028F6:  MOVLW  58
028F8:  MOVWF  FF6
028FA:  MOVLW  04
028FC:  MOVWF  FF7
028FE:  MOVLW  00
02900:  MOVWF  FF8
02902:  CALL   12A6
....................      fprintf(EXT, "press c: Read data set in specified address\n");
02906:  MOVLW  86
02908:  MOVWF  FF6
0290A:  MOVLW  04
0290C:  MOVWF  FF7
0290E:  MOVLW  00
02910:  MOVWF  FF8
02912:  CALL   12A6
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
02916:  MOVLW  B4
02918:  MOVWF  FF6
0291A:  MOVLW  04
0291C:  MOVWF  FF7
0291E:  MOVLW  00
02920:  MOVWF  FF8
02922:  CALL   12A6
....................  
....................      main_flash_option = fgetc(EXT);
02926:  CALL   1EBA
0292A:  MOVFF  01,1B4
....................  
....................      switch (main_flash_option) {
0292E:  MOVLB  1
02930:  MOVF   xB4,W
02932:  XORLW  61
02934:  MOVLB  0
02936:  BZ    2948
02938:  XORLW  03
0293A:  BZ    295C
0293C:  XORLW  01
0293E:  BZ    2960
02940:  XORLW  1B
02942:  BTFSC  FD8.2
02944:  BRA    2A7C
02946:  BRA    2A7E
....................          case 'a':
....................              fprintf(EXT, "Started reading chip ID of MAIN flash memory\n");
02948:  MOVLW  D2
0294A:  MOVWF  FF6
0294C:  MOVLW  04
0294E:  MOVWF  FF7
02950:  MOVLW  00
02952:  MOVWF  FF8
02954:  CALL   12A6
....................              READ_CHIP_ID_OF();  
02958:  BRA    234A
....................              break;
0295A:  BRA    2A8E
....................          case 'b':
....................              write_to_main_flash_menu();
0295C:  BRA    2630
....................              break;
0295E:  BRA    2A8E
....................          case 'c':
....................              fprintf(EXT, "Read data set in specified address\n");
02960:  MOVLW  00
02962:  MOVWF  FF6
02964:  MOVLW  05
02966:  MOVWF  FF7
02968:  MOVLW  00
0296A:  MOVWF  FF8
0296C:  CALL   12A6
....................              fprintf(EXT, "Enter your specified address and length (e.g., 0x1234 10): ");
02970:  MOVLW  24
02972:  MOVWF  FF6
02974:  MOVLW  05
02976:  MOVWF  FF7
02978:  MOVLW  00
0297A:  MOVWF  FF8
0297C:  CALL   12A6
....................              if (scanf("%x %d", &address, &data_length)) {
02980:  MOVLB  1
02982:  CLRF   xDA
02984:  CLRF   xDB
02986:  MOVLW  01
02988:  MOVLB  2
0298A:  MOVWF  xE4
0298C:  MOVLW  B5
0298E:  MOVWF  xE3
02990:  CLRF   xE6
02992:  CLRF   xE5
02994:  MOVLB  0
02996:  RCALL  2450
02998:  MOVF   01,F
0299A:  BNZ   29A4
0299C:  MOVLB  1
0299E:  CLRF   xDB
029A0:  BRA    29D4
029A2:  MOVLB  0
029A4:  MOVF   01,W
029A6:  MOVLB  1
029A8:  ADDWF  xDA,F
029AA:  INCF   xDB,F
029AC:  CLRF   xDD
029AE:  CLRF   xDC
029B0:  MOVLW  01
029B2:  MOVWF  xDF
029B4:  MOVLW  D9
029B6:  MOVWF  xDE
029B8:  MOVLW  0A
029BA:  MOVWF  xE0
029BC:  MOVLB  0
029BE:  BRA    27FA
029C0:  MOVF   01,F
029C2:  BNZ   29CC
029C4:  MOVLB  1
029C6:  CLRF   xDB
029C8:  BRA    29D4
029CA:  MOVLB  0
029CC:  MOVF   01,W
029CE:  MOVLB  1
029D0:  ADDWF  xDA,F
029D2:  INCF   xDB,F
029D4:  MOVF   xDB,W
029D6:  BZ    2A68
....................                  fprintf(EXT, "Address: 0x%09x, Length: %d\n", address, data_length);
029D8:  MOVLW  60
029DA:  MOVWF  FF6
029DC:  MOVLW  05
029DE:  MOVWF  FF7
029E0:  MOVLW  00
029E2:  MOVWF  FF8
029E4:  MOVLW  0B
029E6:  MOVLB  2
029E8:  MOVWF  xED
029EA:  MOVLB  0
029EC:  CALL   141E
029F0:  MOVLW  07
029F2:  MOVLB  1
029F4:  MOVWF  xDA
029F6:  MOVLW  30
029F8:  MOVLB  2
029FA:  MOVWF  xF3
029FC:  MOVLB  0
029FE:  CALL   1260
02A02:  MOVLB  1
02A04:  DECFSZ xDA,F
02A06:  BRA    29F6
02A08:  MOVFF  1B5,2ED
02A0C:  MOVLW  57
02A0E:  MOVLB  2
02A10:  MOVWF  xEE
02A12:  MOVLB  0
02A14:  CALL   16DE
02A18:  MOVLW  6F
02A1A:  MOVWF  FF6
02A1C:  MOVLW  05
02A1E:  MOVWF  FF7
02A20:  MOVLW  00
02A22:  MOVWF  FF8
02A24:  MOVLW  0A
02A26:  MOVLB  2
02A28:  MOVWF  xED
02A2A:  MOVLB  0
02A2C:  CALL   141E
02A30:  MOVFF  1D9,2ED
02A34:  MOVLW  18
02A36:  MOVLB  2
02A38:  MOVWF  xEE
02A3A:  MOVLB  0
02A3C:  CALL   1742
02A40:  MOVLW  0A
02A42:  MOVLB  2
02A44:  MOVWF  xF3
02A46:  MOVLB  0
02A48:  CALL   1260
....................                  READ_DATA_NBYTES(address, data_length);  // Replace with actual function
02A4C:  MOVFF  1B8,1DD
02A50:  MOVFF  1B7,1DC
02A54:  MOVFF  1B6,1DB
02A58:  MOVFF  1B5,1DA
02A5C:  MOVFF  1D9,1DE
02A60:  CALL   15F0
....................              } else {
02A64:  BRA    2A7A
02A66:  MOVLB  1
....................                  fprintf(EXT, "Invalid input. Please enter a valid address and length.\n");
02A68:  MOVLW  7E
02A6A:  MOVWF  FF6
02A6C:  MOVLW  05
02A6E:  MOVWF  FF7
02A70:  MOVLW  00
02A72:  MOVWF  FF8
02A74:  MOVLB  0
02A76:  CALL   12A6
....................              }
....................              break;
02A7A:  BRA    2A8E
....................  
....................          case 'x':
....................              return;
02A7C:  BRA    2A8E
....................          default:
....................              fprintf(EXT, "Invalid MAIN flash memory option. Please try again.\n");
02A7E:  MOVLW  B8
02A80:  MOVWF  FF6
02A82:  MOVLW  05
02A84:  MOVWF  FF7
02A86:  MOVLW  00
02A88:  MOVWF  FF8
02A8A:  CALL   12A6
....................              break;
....................      }
02A8E:  GOTO   2BA8 (RETURN)
....................  }
....................  //main flash memory consol for main_menu() function
....................  void handle_flash_memories() {
....................      char flash_option;
....................      fprintf(EXT, "pressed option d: Check Flash Memories\n\n");
02A92:  MOVLW  EE
02A94:  MOVWF  FF6
02A96:  MOVLW  05
02A98:  MOVWF  FF7
02A9A:  MOVLW  00
02A9C:  MOVWF  FF8
02A9E:  CALL   12A6
....................      fprintf(EXT, "Please choose which flash memory to work on (a, b, c, d, e):\n");
02AA2:  MOVLW  18
02AA4:  MOVWF  FF6
02AA6:  MOVLW  06
02AA8:  MOVWF  FF7
02AAA:  MOVLW  00
02AAC:  MOVWF  FF8
02AAE:  CALL   12A6
....................      fprintf(EXT, "press a: MAIN flash memory\n");
02AB2:  MOVLW  56
02AB4:  MOVWF  FF6
02AB6:  MOVLW  06
02AB8:  MOVWF  FF7
02ABA:  MOVLW  00
02ABC:  MOVWF  FF8
02ABE:  CALL   12A6
....................      fprintf(EXT, "press b: COM shared flash memory\n");
02AC2:  MOVLW  72
02AC4:  MOVWF  FF6
02AC6:  MOVLW  06
02AC8:  MOVWF  FF7
02ACA:  MOVLW  00
02ACC:  MOVWF  FF8
02ACE:  CALL   12A6
....................      fprintf(EXT, "press c: ADCS shared flash memory\n");
02AD2:  MOVLW  94
02AD4:  MOVWF  FF6
02AD6:  MOVLW  06
02AD8:  MOVWF  FF7
02ADA:  MOVLW  00
02ADC:  MOVWF  FF8
02ADE:  CALL   12A6
....................      fprintf(EXT, "press d: OVCAM shared flash memory\n");
02AE2:  MOVLW  B8
02AE4:  MOVWF  FF6
02AE6:  MOVLW  06
02AE8:  MOVWF  FF7
02AEA:  MOVLW  00
02AEC:  MOVWF  FF8
02AEE:  CALL   12A6
....................      fprintf(EXT, "press e: MVCAM shared flash memory\n");
02AF2:  MOVLW  DC
02AF4:  MOVWF  FF6
02AF6:  MOVLW  06
02AF8:  MOVWF  FF7
02AFA:  MOVLW  00
02AFC:  MOVWF  FF8
02AFE:  CALL   12A6
....................      fprintf(EXT, "press x: Return to MAIN MENU\n");
02B02:  MOVLW  00
02B04:  MOVWF  FF6
02B06:  MOVLW  07
02B08:  MOVWF  FF7
02B0A:  MOVLW  00
02B0C:  MOVWF  FF8
02B0E:  CALL   12A6
....................  
....................      flash_option = fgetc(EXT);
02B12:  CALL   1EBA
02B16:  MOVFF  01,1B3
....................  
....................      switch (flash_option) {
02B1A:  MOVLB  1
02B1C:  MOVF   xB3,W
02B1E:  XORLW  61
02B20:  MOVLB  0
02B22:  BZ    2B3A
02B24:  XORLW  03
02B26:  BZ    2B4E
02B28:  XORLW  01
02B2A:  BZ    2B60
02B2C:  XORLW  07
02B2E:  BZ    2B72
02B30:  XORLW  01
02B32:  BZ    2B84
02B34:  XORLW  1D
02B36:  BZ    2B96
02B38:  BRA    2B98
....................          case 'a':
....................              fprintf(EXT, "MAIN shared flash memory chosen\n");
02B3A:  MOVLW  1E
02B3C:  MOVWF  FF6
02B3E:  MOVLW  07
02B40:  MOVWF  FF7
02B42:  MOVLW  00
02B44:  MOVWF  FF8
02B46:  CALL   12A6
....................              handle_main_flash_memory();
02B4A:  BRA    28D6
....................              break;
02B4C:  BRA    2BA8
....................          case 'b':
....................              fprintf(EXT, "COM shared flash memory chosen\n");
02B4E:  MOVLW  40
02B50:  MOVWF  FF6
02B52:  MOVLW  07
02B54:  MOVWF  FF7
02B56:  MOVLW  00
02B58:  MOVWF  FF8
02B5A:  CALL   12A6
....................              // Implement COM shared flash memory handling
....................              break;
02B5E:  BRA    2BA8
....................          case 'c':
....................              fprintf(EXT, "ADCS shared flash memory chosen\n");
02B60:  MOVLW  60
02B62:  MOVWF  FF6
02B64:  MOVLW  07
02B66:  MOVWF  FF7
02B68:  MOVLW  00
02B6A:  MOVWF  FF8
02B6C:  CALL   12A6
....................              // Implement ADCS shared flash memory handling
....................              break;
02B70:  BRA    2BA8
....................           case 'd':
....................              fprintf(EXT, "OVCAM shared flash memory chosen\n");
02B72:  MOVLW  82
02B74:  MOVWF  FF6
02B76:  MOVLW  07
02B78:  MOVWF  FF7
02B7A:  MOVLW  00
02B7C:  MOVWF  FF8
02B7E:  CALL   12A6
....................              // Implement ADCS shared flash memory handling
....................              break;
02B82:  BRA    2BA8
....................           case 'e':
....................              fprintf(EXT, "MVCAM shared flash memory chosen\n");
02B84:  MOVLW  A4
02B86:  MOVWF  FF6
02B88:  MOVLW  07
02B8A:  MOVWF  FF7
02B8C:  MOVLW  00
02B8E:  MOVWF  FF8
02B90:  CALL   12A6
....................              // Implement ADCS shared flash memory handling
....................              break;
02B94:  BRA    2BA8
....................           case'x':
....................               break;
02B96:  BRA    2BA8
....................          default:
....................              fprintf(EXT, "Invalid flash memory option. Please try again.\n");
02B98:  MOVLW  C6
02B9A:  MOVWF  FF6
02B9C:  MOVLW  07
02B9E:  MOVWF  FF7
02BA0:  MOVLW  00
02BA2:  MOVWF  FF8
02BA4:  CALL   12A6
....................              break;
....................      }
02BA8:  RETURN 0
....................  }
....................  
....................  //main RTCC functions consol for main_menu() function
....................  void handle_set_time() {
....................      char handle_set_time_option;
....................      fprintf(EXT, "Settings of RTC chosen\n");
02BAA:  MOVLW  F6
02BAC:  MOVWF  FF6
02BAE:  MOVLW  07
02BB0:  MOVWF  FF7
02BB2:  MOVLW  00
02BB4:  MOVWF  FF8
02BB6:  CALL   12A6
....................      fprintf(EXT, "    press a: to reset the RTC /all current time will be set zero/\n");
02BBA:  MOVLW  0E
02BBC:  MOVWF  FF6
02BBE:  MOVLW  08
02BC0:  MOVWF  FF7
02BC2:  MOVLW  00
02BC4:  MOVWF  FF8
02BC6:  CALL   12A6
....................      fprintf(EXT, "    press b: display current time\n");
02BCA:  MOVLW  52
02BCC:  MOVWF  FF6
02BCE:  MOVLW  08
02BD0:  MOVWF  FF7
02BD2:  MOVLW  00
02BD4:  MOVWF  FF8
02BD6:  CALL   12A6
....................      fprintf(EXT, "    press c: display current time nonstop\n");
02BDA:  MOVLW  76
02BDC:  MOVWF  FF6
02BDE:  MOVLW  08
02BE0:  MOVWF  FF7
02BE2:  MOVLW  00
02BE4:  MOVWF  FF8
02BE6:  CALL   12A6
....................      handle_set_time_option = fgetc(EXT);
02BEA:  CALL   1EBA
02BEE:  MOVFF  01,1B2
....................  
....................      switch (handle_set_time_option) {
02BF2:  MOVLB  1
02BF4:  MOVF   xB2,W
02BF6:  XORLW  61
02BF8:  MOVLB  0
02BFA:  BZ    2C10
02BFC:  XORLW  03
02BFE:  BTFSC  FD8.2
02C00:  BRA    2E5C
02C02:  XORLW  01
02C04:  BTFSC  FD8.2
02C06:  BRA    2F44
02C08:  XORLW  1B
02C0A:  BTFSC  FD8.2
02C0C:  BRA    3062
02C0E:  BRA    3066
....................          case 'a':
....................      rtc_time_t write_clock, read_clock;
....................      rtc_read(&read_clock);
02C10:  MOVLB  F
02C12:  BSF    x5F.0
02C14:  BSF    x5F.1
02C16:  MOVLW  01
02C18:  MOVWF  FEA
02C1A:  MOVLW  BC
02C1C:  MOVWF  FE9
02C1E:  MOVLW  04
02C20:  MOVWF  01
02C22:  MOVF   x5C,W
02C24:  MOVLB  0
02C26:  CALL   1364
02C2A:  MOVWF  FEE
02C2C:  MOVLB  F
02C2E:  MOVF   x5D,W
02C30:  MOVLB  0
02C32:  CALL   1364
02C36:  MOVWF  FEE
02C38:  DECFSZ 01,F
02C3A:  BRA    2C3E
02C3C:  BRA    2C42
02C3E:  MOVLB  F
02C40:  BRA    2C22
....................      fprintf(EXT, "Now time is\n");
02C42:  MOVLW  A2
02C44:  MOVWF  FF6
02C46:  MOVLW  08
02C48:  MOVWF  FF7
02C4A:  MOVLW  00
02C4C:  MOVWF  FF8
02C4E:  CALL   12A6
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02C52:  MOVLW  0D
02C54:  MOVLB  2
02C56:  MOVWF  xF3
02C58:  MOVLB  0
02C5A:  CALL   1260
02C5E:  MOVFF  1BF,1C5
02C62:  MOVLW  01
02C64:  MOVLB  1
02C66:  MOVWF  xC6
02C68:  MOVLB  0
02C6A:  CALL   13A2
02C6E:  MOVLW  2F
02C70:  MOVLB  2
02C72:  MOVWF  xF3
02C74:  MOVLB  0
02C76:  CALL   1260
02C7A:  MOVFF  1BE,1C5
02C7E:  MOVLW  01
02C80:  MOVLB  1
02C82:  MOVWF  xC6
02C84:  MOVLB  0
02C86:  CALL   13A2
02C8A:  MOVLW  BA
02C8C:  MOVWF  FF6
02C8E:  MOVLW  08
02C90:  MOVWF  FF7
02C92:  MOVLW  00
02C94:  MOVWF  FF8
02C96:  MOVLW  03
02C98:  MOVLB  2
02C9A:  MOVWF  xED
02C9C:  MOVLB  0
02C9E:  CALL   141E
02CA2:  MOVFF  1BC,1C5
02CA6:  MOVLW  01
02CA8:  MOVLB  1
02CAA:  MOVWF  xC6
02CAC:  MOVLB  0
02CAE:  CALL   13A2
02CB2:  MOVLW  20
02CB4:  MOVLB  2
02CB6:  MOVWF  xF3
02CB8:  MOVLB  0
02CBA:  CALL   1260
02CBE:  MOVFF  1C0,1C5
02CC2:  MOVLW  01
02CC4:  MOVLB  1
02CC6:  MOVWF  xC6
02CC8:  MOVLB  0
02CCA:  CALL   13A2
02CCE:  MOVLW  3A
02CD0:  MOVLB  2
02CD2:  MOVWF  xF3
02CD4:  MOVLB  0
02CD6:  CALL   1260
02CDA:  MOVFF  1C3,1C5
02CDE:  MOVLW  01
02CE0:  MOVLB  1
02CE2:  MOVWF  xC6
02CE4:  MOVLB  0
02CE6:  CALL   13A2
02CEA:  MOVLW  3A
02CEC:  MOVLB  2
02CEE:  MOVWF  xF3
02CF0:  MOVLB  0
02CF2:  CALL   1260
02CF6:  MOVFF  1C2,1C5
02CFA:  MOVLW  01
02CFC:  MOVLB  1
02CFE:  MOVWF  xC6
02D00:  MOVLB  0
02D02:  CALL   13A2
....................      fprintf(EXT, "Time changing function activated\n");
02D06:  MOVLW  D2
02D08:  MOVWF  FF6
02D0A:  MOVLW  08
02D0C:  MOVWF  FF7
02D0E:  MOVLW  00
02D10:  MOVWF  FF8
02D12:  CALL   12A6
....................      set_clock(write_clock);
....................      rtc_write(&write_clock);
*
02D28:  MOVLB  F
02D2A:  MOVLW  55
02D2C:  MOVWF  F7E
02D2E:  MOVLW  AA
02D30:  MOVWF  F7E
02D32:  BSF    x5F.5
02D34:  BSF    x5F.0
02D36:  BSF    x5F.1
02D38:  MOVLW  01
02D3A:  MOVWF  FEA
02D3C:  MOVLW  B3
02D3E:  MOVWF  FE9
02D40:  MOVLW  04
02D42:  MOVWF  01
02D44:  MOVF   FEE,W
02D46:  MOVLB  0
02D48:  CALL   1340
02D4C:  MOVLB  F
02D4E:  MOVWF  x5C
02D50:  MOVF   FEE,W
02D52:  MOVLB  0
02D54:  CALL   1340
02D58:  MOVLB  F
02D5A:  MOVWF  x5D
02D5C:  DECFSZ 01,F
02D5E:  BRA    2D44
02D60:  BCF    x5F.5
....................      fprintf(EXT, "Time successfully changed. Current time is:\n");
02D62:  MOVLW  F4
02D64:  MOVWF  FF6
02D66:  MOVLW  08
02D68:  MOVWF  FF7
02D6A:  MOVLW  00
02D6C:  MOVWF  FF8
02D6E:  MOVLB  0
02D70:  CALL   12A6
....................      rtc_read(&read_clock);
02D74:  MOVLB  F
02D76:  BSF    x5F.0
02D78:  BSF    x5F.1
02D7A:  MOVLW  01
02D7C:  MOVWF  FEA
02D7E:  MOVLW  BC
02D80:  MOVWF  FE9
02D82:  MOVLW  04
02D84:  MOVWF  01
02D86:  MOVF   x5C,W
02D88:  MOVLB  0
02D8A:  CALL   1364
02D8E:  MOVWF  FEE
02D90:  MOVLB  F
02D92:  MOVF   x5D,W
02D94:  MOVLB  0
02D96:  CALL   1364
02D9A:  MOVWF  FEE
02D9C:  DECFSZ 01,F
02D9E:  BRA    2DA2
02DA0:  BRA    2DA6
02DA2:  MOVLB  F
02DA4:  BRA    2D86
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02DA6:  MOVLW  0D
02DA8:  MOVLB  2
02DAA:  MOVWF  xF3
02DAC:  MOVLB  0
02DAE:  CALL   1260
02DB2:  MOVFF  1BF,1C5
02DB6:  MOVLW  01
02DB8:  MOVLB  1
02DBA:  MOVWF  xC6
02DBC:  MOVLB  0
02DBE:  CALL   13A2
02DC2:  MOVLW  2F
02DC4:  MOVLB  2
02DC6:  MOVWF  xF3
02DC8:  MOVLB  0
02DCA:  CALL   1260
02DCE:  MOVFF  1BE,1C5
02DD2:  MOVLW  01
02DD4:  MOVLB  1
02DD6:  MOVWF  xC6
02DD8:  MOVLB  0
02DDA:  CALL   13A2
02DDE:  MOVLW  2C
02DE0:  MOVWF  FF6
02DE2:  MOVLW  09
02DE4:  MOVWF  FF7
02DE6:  MOVLW  00
02DE8:  MOVWF  FF8
02DEA:  MOVLW  03
02DEC:  MOVLB  2
02DEE:  MOVWF  xED
02DF0:  MOVLB  0
02DF2:  CALL   141E
02DF6:  MOVFF  1BC,1C5
02DFA:  MOVLW  01
02DFC:  MOVLB  1
02DFE:  MOVWF  xC6
02E00:  MOVLB  0
02E02:  CALL   13A2
02E06:  MOVLW  20
02E08:  MOVLB  2
02E0A:  MOVWF  xF3
02E0C:  MOVLB  0
02E0E:  CALL   1260
02E12:  MOVFF  1C0,1C5
02E16:  MOVLW  01
02E18:  MOVLB  1
02E1A:  MOVWF  xC6
02E1C:  MOVLB  0
02E1E:  CALL   13A2
02E22:  MOVLW  3A
02E24:  MOVLB  2
02E26:  MOVWF  xF3
02E28:  MOVLB  0
02E2A:  CALL   1260
02E2E:  MOVFF  1C3,1C5
02E32:  MOVLW  01
02E34:  MOVLB  1
02E36:  MOVWF  xC6
02E38:  MOVLB  0
02E3A:  CALL   13A2
02E3E:  MOVLW  3A
02E40:  MOVLB  2
02E42:  MOVWF  xF3
02E44:  MOVLB  0
02E46:  CALL   1260
02E4A:  MOVFF  1C2,1C5
02E4E:  MOVLW  01
02E50:  MOVLB  1
02E52:  MOVWF  xC6
02E54:  MOVLB  0
02E56:  CALL   13A2
....................      break;
02E5A:  BRA    3076
....................          case 'b':
....................              rtc_read(&read_clock);
02E5C:  MOVLB  F
02E5E:  BSF    x5F.0
02E60:  BSF    x5F.1
02E62:  MOVLW  01
02E64:  MOVWF  FEA
02E66:  MOVLW  BC
02E68:  MOVWF  FE9
02E6A:  MOVLW  04
02E6C:  MOVWF  01
02E6E:  MOVF   x5C,W
02E70:  MOVLB  0
02E72:  CALL   1364
02E76:  MOVWF  FEE
02E78:  MOVLB  F
02E7A:  MOVF   x5D,W
02E7C:  MOVLB  0
02E7E:  CALL   1364
02E82:  MOVWF  FEE
02E84:  DECFSZ 01,F
02E86:  BRA    2E8A
02E88:  BRA    2E8E
02E8A:  MOVLB  F
02E8C:  BRA    2E6E
....................      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);
02E8E:  MOVLW  0D
02E90:  MOVLB  2
02E92:  MOVWF  xF3
02E94:  MOVLB  0
02E96:  CALL   1260
02E9A:  MOVFF  1BF,1C5
02E9E:  MOVLW  01
02EA0:  MOVLB  1
02EA2:  MOVWF  xC6
02EA4:  MOVLB  0
02EA6:  CALL   13A2
02EAA:  MOVLW  2F
02EAC:  MOVLB  2
02EAE:  MOVWF  xF3
02EB0:  MOVLB  0
02EB2:  CALL   1260
02EB6:  MOVFF  1BE,1C5
02EBA:  MOVLW  01
02EBC:  MOVLB  1
02EBE:  MOVWF  xC6
02EC0:  MOVLB  0
02EC2:  CALL   13A2
02EC6:  MOVLW  4E
02EC8:  MOVWF  FF6
02ECA:  MOVLW  09
02ECC:  MOVWF  FF7
02ECE:  MOVLW  00
02ED0:  MOVWF  FF8
02ED2:  MOVLW  03
02ED4:  MOVLB  2
02ED6:  MOVWF  xED
02ED8:  MOVLB  0
02EDA:  CALL   141E
02EDE:  MOVFF  1BC,1C5
02EE2:  MOVLW  01
02EE4:  MOVLB  1
02EE6:  MOVWF  xC6
02EE8:  MOVLB  0
02EEA:  CALL   13A2
02EEE:  MOVLW  20
02EF0:  MOVLB  2
02EF2:  MOVWF  xF3
02EF4:  MOVLB  0
02EF6:  CALL   1260
02EFA:  MOVFF  1C0,1C5
02EFE:  MOVLW  01
02F00:  MOVLB  1
02F02:  MOVWF  xC6
02F04:  MOVLB  0
02F06:  CALL   13A2
02F0A:  MOVLW  3A
02F0C:  MOVLB  2
02F0E:  MOVWF  xF3
02F10:  MOVLB  0
02F12:  CALL   1260
02F16:  MOVFF  1C3,1C5
02F1A:  MOVLW  01
02F1C:  MOVLB  1
02F1E:  MOVWF  xC6
02F20:  MOVLB  0
02F22:  CALL   13A2
02F26:  MOVLW  3A
02F28:  MOVLB  2
02F2A:  MOVWF  xF3
02F2C:  MOVLB  0
02F2E:  CALL   1260
02F32:  MOVFF  1C2,1C5
02F36:  MOVLW  01
02F38:  MOVLB  1
02F3A:  MOVWF  xC6
02F3C:  MOVLB  0
02F3E:  CALL   13A2
....................      break;
02F42:  BRA    3076
....................          case 'c':
....................                  while(true){
....................                      rtc_read(&read_clock);
02F44:  MOVLB  F
02F46:  BSF    x5F.0
02F48:  BSF    x5F.1
02F4A:  MOVLW  01
02F4C:  MOVWF  FEA
02F4E:  MOVLW  BC
02F50:  MOVWF  FE9
02F52:  MOVLW  04
02F54:  MOVWF  01
02F56:  MOVF   x5C,W
02F58:  MOVLB  0
02F5A:  CALL   1364
02F5E:  MOVWF  FEE
02F60:  MOVLB  F
02F62:  MOVF   x5D,W
02F64:  MOVLB  0
02F66:  CALL   1364
02F6A:  MOVWF  FEE
02F6C:  DECFSZ 01,F
02F6E:  BRA    2F72
02F70:  BRA    2F76
02F72:  MOVLB  F
02F74:  BRA    2F56
....................                      fprintf(EXT, "Now time is\n");
02F76:  MOVLW  66
02F78:  MOVWF  FF6
02F7A:  MOVLW  09
02F7C:  MOVWF  FF7
02F7E:  MOVLW  00
02F80:  MOVWF  FF8
02F82:  CALL   12A6
....................                      fprintf(EXT, "\r%02u/%02u/20%02u %02u:%02u:%02u\n", read_clock.tm_mon, read_clock.tm_mday, read_clock.tm_year, read_clock.tm_hour, read_clock.tm_min, read_clock.tm_sec);   
02F86:  MOVLW  0D
02F88:  MOVLB  2
02F8A:  MOVWF  xF3
02F8C:  MOVLB  0
02F8E:  CALL   1260
02F92:  MOVFF  1BF,1C5
02F96:  MOVLW  01
02F98:  MOVLB  1
02F9A:  MOVWF  xC6
02F9C:  MOVLB  0
02F9E:  CALL   13A2
02FA2:  MOVLW  2F
02FA4:  MOVLB  2
02FA6:  MOVWF  xF3
02FA8:  MOVLB  0
02FAA:  CALL   1260
02FAE:  MOVFF  1BE,1C5
02FB2:  MOVLW  01
02FB4:  MOVLB  1
02FB6:  MOVWF  xC6
02FB8:  MOVLB  0
02FBA:  CALL   13A2
02FBE:  MOVLW  7E
02FC0:  MOVWF  FF6
02FC2:  MOVLW  09
02FC4:  MOVWF  FF7
02FC6:  MOVLW  00
02FC8:  MOVWF  FF8
02FCA:  MOVLW  03
02FCC:  MOVLB  2
02FCE:  MOVWF  xED
02FD0:  MOVLB  0
02FD2:  CALL   141E
02FD6:  MOVFF  1BC,1C5
02FDA:  MOVLW  01
02FDC:  MOVLB  1
02FDE:  MOVWF  xC6
02FE0:  MOVLB  0
02FE2:  CALL   13A2
02FE6:  MOVLW  20
02FE8:  MOVLB  2
02FEA:  MOVWF  xF3
02FEC:  MOVLB  0
02FEE:  CALL   1260
02FF2:  MOVFF  1C0,1C5
02FF6:  MOVLW  01
02FF8:  MOVLB  1
02FFA:  MOVWF  xC6
02FFC:  MOVLB  0
02FFE:  CALL   13A2
03002:  MOVLW  3A
03004:  MOVLB  2
03006:  MOVWF  xF3
03008:  MOVLB  0
0300A:  CALL   1260
0300E:  MOVFF  1C3,1C5
03012:  MOVLW  01
03014:  MOVLB  1
03016:  MOVWF  xC6
03018:  MOVLB  0
0301A:  CALL   13A2
0301E:  MOVLW  3A
03020:  MOVLB  2
03022:  MOVWF  xF3
03024:  MOVLB  0
03026:  CALL   1260
0302A:  MOVFF  1C2,1C5
0302E:  MOVLW  01
03030:  MOVLB  1
03032:  MOVWF  xC6
03034:  MOVLB  0
03036:  CALL   13A2
0303A:  MOVLW  0A
0303C:  MOVLB  2
0303E:  MOVWF  xF3
03040:  MOVLB  0
03042:  CALL   1260
....................                      delay_ms(1000);
03046:  MOVLW  04
03048:  MOVLB  1
0304A:  MOVWF  xC5
0304C:  MOVLW  FA
0304E:  MOVWF  xCD
03050:  MOVLB  0
03052:  CALL   1236
03056:  MOVLB  1
03058:  DECFSZ xC5,F
0305A:  BRA    304C
0305C:  MOVLB  0
0305E:  BRA    2F44
....................                  }
....................              break;
03060:  BRA    3076
....................          case 'x':
....................              break;
03062:  BRA    3076
....................              return;
03064:  BRA    3076
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
03066:  MOVLW  96
03068:  MOVWF  FF6
0306A:  MOVLW  09
0306C:  MOVWF  FF7
0306E:  MOVLW  00
03070:  MOVWF  FF8
03072:  CALL   12A6
....................      break;
....................              
....................  }
03076:  GOTO   44E6 (RETURN)
....................  }
....................  //main IO control consol for main_menu() function
....................  void handle_io_control() {
....................      char io_option;
....................      int8 state_of_pin;
....................  
....................      fprintf(EXT, "IO control chosen\n");
*
01F04:  MOVLW  BC
01F06:  MOVWF  FF6
01F08:  MOVLW  09
01F0A:  MOVWF  FF7
01F0C:  MOVLW  00
01F0E:  MOVWF  FF8
01F10:  CALL   12A6
....................  
....................      // Check and display the state of each pin before providing options
....................      state_of_pin = input_state(EN_SUP_3V3_1);
01F14:  MOVLB  1
01F16:  CLRF   xB3
01F18:  BTFSC  F81.0
01F1A:  INCF   xB3,F
....................      fprintf(EXT, "    press a: Toggle EN_SUP_3V3_1 /is currently/");
01F1C:  MOVLW  D0
01F1E:  MOVWF  FF6
01F20:  MOVLW  09
01F22:  MOVWF  FF7
01F24:  MOVLW  00
01F26:  MOVWF  FF8
01F28:  MOVLB  0
01F2A:  CALL   12A6
....................      if(state_of_pin == 1 ){
01F2E:  MOVLB  1
01F30:  DECFSZ xB3,W
01F32:  BRA    1F4A
....................          fprintf(EXT, "HIGH\n");
01F34:  MOVLW  00
01F36:  MOVWF  FF6
01F38:  MOVLW  0A
01F3A:  MOVWF  FF7
01F3C:  MOVLW  00
01F3E:  MOVWF  FF8
01F40:  MOVLB  0
01F42:  CALL   12A6
....................      }else if(state_of_pin == 0){
01F46:  BRA    1F76
01F48:  MOVLB  1
01F4A:  MOVF   xB3,F
01F4C:  BNZ   1F64
....................          fprintf(EXT, "LOW\n");
01F4E:  MOVLW  06
01F50:  MOVWF  FF6
01F52:  MOVLW  0A
01F54:  MOVWF  FF7
01F56:  MOVLW  00
01F58:  MOVWF  FF8
01F5A:  MOVLB  0
01F5C:  CALL   12A6
....................      }else {
01F60:  BRA    1F76
01F62:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
01F64:  MOVLW  0C
01F66:  MOVWF  FF6
01F68:  MOVLW  0A
01F6A:  MOVWF  FF7
01F6C:  MOVLW  00
01F6E:  MOVWF  FF8
01F70:  MOVLB  0
01F72:  CALL   12A6
....................      }
....................      state_of_pin = input_state(EN_SUP_3V3_2);
01F76:  MOVLB  1
01F78:  CLRF   xB3
01F7A:  BTFSC  F86.1
01F7C:  INCF   xB3,F
....................      fprintf(EXT, "    press b: Toggle EN_SUP_3V3_2 /is currently/");
01F7E:  MOVLW  16
01F80:  MOVWF  FF6
01F82:  MOVLW  0A
01F84:  MOVWF  FF7
01F86:  MOVLW  00
01F88:  MOVWF  FF8
01F8A:  MOVLB  0
01F8C:  CALL   12A6
....................      if(state_of_pin == 1 ){
01F90:  MOVLB  1
01F92:  DECFSZ xB3,W
01F94:  BRA    1FAC
....................          fprintf(EXT, "HIGH\n");
01F96:  MOVLW  46
01F98:  MOVWF  FF6
01F9A:  MOVLW  0A
01F9C:  MOVWF  FF7
01F9E:  MOVLW  00
01FA0:  MOVWF  FF8
01FA2:  MOVLB  0
01FA4:  CALL   12A6
....................      }else if(state_of_pin == 0){
01FA8:  BRA    1FD8
01FAA:  MOVLB  1
01FAC:  MOVF   xB3,F
01FAE:  BNZ   1FC6
....................          fprintf(EXT, "LOW\n");
01FB0:  MOVLW  4C
01FB2:  MOVWF  FF6
01FB4:  MOVLW  0A
01FB6:  MOVWF  FF7
01FB8:  MOVLW  00
01FBA:  MOVWF  FF8
01FBC:  MOVLB  0
01FBE:  CALL   12A6
....................      }else {
01FC2:  BRA    1FD8
01FC4:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
01FC6:  MOVLW  52
01FC8:  MOVWF  FF6
01FCA:  MOVLW  0A
01FCC:  MOVWF  FF7
01FCE:  MOVLW  00
01FD0:  MOVWF  FF8
01FD2:  MOVLB  0
01FD4:  CALL   12A6
....................      }
....................       state_of_pin = input_state(EN_SUP_3V3_DAQ);
01FD8:  MOVLB  1
01FDA:  CLRF   xB3
01FDC:  BTFSC  F83.0
01FDE:  INCF   xB3,F
....................      fprintf(EXT, "    press c: Toggle EN_SUP_3V3_DAQ /is currently/");
01FE0:  MOVLW  5C
01FE2:  MOVWF  FF6
01FE4:  MOVLW  0A
01FE6:  MOVWF  FF7
01FE8:  MOVLW  00
01FEA:  MOVWF  FF8
01FEC:  MOVLB  0
01FEE:  CALL   12A6
....................      if(state_of_pin == 1 ){
01FF2:  MOVLB  1
01FF4:  DECFSZ xB3,W
01FF6:  BRA    200E
....................          fprintf(EXT, "HIGH\n");
01FF8:  MOVLW  8E
01FFA:  MOVWF  FF6
01FFC:  MOVLW  0A
01FFE:  MOVWF  FF7
02000:  MOVLW  00
02002:  MOVWF  FF8
02004:  MOVLB  0
02006:  CALL   12A6
....................      }else if(state_of_pin == 0){
0200A:  BRA    203A
0200C:  MOVLB  1
0200E:  MOVF   xB3,F
02010:  BNZ   2028
....................          fprintf(EXT, "LOW\n");
02012:  MOVLW  94
02014:  MOVWF  FF6
02016:  MOVLW  0A
02018:  MOVWF  FF7
0201A:  MOVLW  00
0201C:  MOVWF  FF8
0201E:  MOVLB  0
02020:  CALL   12A6
....................      }else {
02024:  BRA    203A
02026:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02028:  MOVLW  9A
0202A:  MOVWF  FF6
0202C:  MOVLW  0A
0202E:  MOVWF  FF7
02030:  MOVLW  00
02032:  MOVWF  FF8
02034:  MOVLB  0
02036:  CALL   12A6
....................      }
....................      state_of_pin = input_state(EN_SUP_UNREG);
0203A:  MOVLB  1
0203C:  CLRF   xB3
0203E:  BTFSC  F81.1
02040:  INCF   xB3,F
....................      fprintf(EXT, "    press d: Toggle EN_SUP_UNREG /is currently/");
02042:  MOVLW  A4
02044:  MOVWF  FF6
02046:  MOVLW  0A
02048:  MOVWF  FF7
0204A:  MOVLW  00
0204C:  MOVWF  FF8
0204E:  MOVLB  0
02050:  CALL   12A6
....................      if(state_of_pin == 1 ){
02054:  MOVLB  1
02056:  DECFSZ xB3,W
02058:  BRA    2070
....................          fprintf(EXT, "HIGH\n");
0205A:  MOVLW  D4
0205C:  MOVWF  FF6
0205E:  MOVLW  0A
02060:  MOVWF  FF7
02062:  MOVLW  00
02064:  MOVWF  FF8
02066:  MOVLB  0
02068:  CALL   12A6
....................      }else if(state_of_pin == 0){
0206C:  BRA    209C
0206E:  MOVLB  1
02070:  MOVF   xB3,F
02072:  BNZ   208A
....................          fprintf(EXT, "LOW\n");
02074:  MOVLW  DA
02076:  MOVWF  FF6
02078:  MOVLW  0A
0207A:  MOVWF  FF7
0207C:  MOVLW  00
0207E:  MOVWF  FF8
02080:  MOVLB  0
02082:  CALL   12A6
....................      }else {
02086:  BRA    209C
02088:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
0208A:  MOVLW  E0
0208C:  MOVWF  FF6
0208E:  MOVLW  0A
02090:  MOVWF  FF7
02092:  MOVLW  00
02094:  MOVWF  FF8
02096:  MOVLB  0
02098:  CALL   12A6
....................      }
....................      state_of_pin = input_state(EN_SUP_5V0);
0209C:  MOVLB  1
0209E:  CLRF   xB3
020A0:  BTFSC  F83.1
020A2:  INCF   xB3,F
....................      fprintf(EXT, "    press e: Toggle EN_SUP_5V0 /is currently/");
020A4:  MOVLW  EA
020A6:  MOVWF  FF6
020A8:  MOVLW  0A
020AA:  MOVWF  FF7
020AC:  MOVLW  00
020AE:  MOVWF  FF8
020B0:  MOVLB  0
020B2:  CALL   12A6
....................      if(state_of_pin == 1 ){
020B6:  MOVLB  1
020B8:  DECFSZ xB3,W
020BA:  BRA    20D2
....................          fprintf(EXT, "HIGH\n");
020BC:  MOVLW  18
020BE:  MOVWF  FF6
020C0:  MOVLW  0B
020C2:  MOVWF  FF7
020C4:  MOVLW  00
020C6:  MOVWF  FF8
020C8:  MOVLB  0
020CA:  CALL   12A6
....................      }else if(state_of_pin == 0){
020CE:  BRA    20FE
020D0:  MOVLB  1
020D2:  MOVF   xB3,F
020D4:  BNZ   20EC
....................          fprintf(EXT, "LOW\n");
020D6:  MOVLW  1E
020D8:  MOVWF  FF6
020DA:  MOVLW  0B
020DC:  MOVWF  FF7
020DE:  MOVLW  00
020E0:  MOVWF  FF8
020E2:  MOVLB  0
020E4:  CALL   12A6
....................      }else {
020E8:  BRA    20FE
020EA:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
020EC:  MOVLW  24
020EE:  MOVWF  FF6
020F0:  MOVLW  0B
020F2:  MOVWF  FF7
020F4:  MOVLW  00
020F6:  MOVWF  FF8
020F8:  MOVLB  0
020FA:  CALL   12A6
....................      }
....................      state_of_pin = input_state(KILL_SWITCH);
020FE:  MOVLB  1
02100:  CLRF   xB3
02102:  BTFSC  F80.4
02104:  INCF   xB3,F
....................      fprintf(EXT, "    press f: Toggle KILL_SWITCH /is currently/");
02106:  MOVLW  2E
02108:  MOVWF  FF6
0210A:  MOVLW  0B
0210C:  MOVWF  FF7
0210E:  MOVLW  00
02110:  MOVWF  FF8
02112:  MOVLB  0
02114:  CALL   12A6
....................      if(state_of_pin == 1 ){
02118:  MOVLB  1
0211A:  DECFSZ xB3,W
0211C:  BRA    2134
....................          fprintf(EXT, "HIGH\n");
0211E:  MOVLW  5E
02120:  MOVWF  FF6
02122:  MOVLW  0B
02124:  MOVWF  FF7
02126:  MOVLW  00
02128:  MOVWF  FF8
0212A:  MOVLB  0
0212C:  CALL   12A6
....................      }else if(state_of_pin == 0){
02130:  BRA    2160
02132:  MOVLB  1
02134:  MOVF   xB3,F
02136:  BNZ   214E
....................          fprintf(EXT, "LOW\n");
02138:  MOVLW  64
0213A:  MOVWF  FF6
0213C:  MOVLW  0B
0213E:  MOVWF  FF7
02140:  MOVLW  00
02142:  MOVWF  FF8
02144:  MOVLB  0
02146:  CALL   12A6
....................      }else {
0214A:  BRA    2160
0214C:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
0214E:  MOVLW  6A
02150:  MOVWF  FF6
02152:  MOVLW  0B
02154:  MOVWF  FF7
02156:  MOVLW  00
02158:  MOVWF  FF8
0215A:  MOVLB  0
0215C:  CALL   12A6
....................      }
....................          state_of_pin = input_state(MVCAM_PWR);
02160:  MOVLB  1
02162:  CLRF   xB3
02164:  BTFSC  F86.0
02166:  INCF   xB3,F
....................      fprintf(EXT, "    press g: Toggle MVCAM_PWR /is currently/");
02168:  MOVLW  74
0216A:  MOVWF  FF6
0216C:  MOVLW  0B
0216E:  MOVWF  FF7
02170:  MOVLW  00
02172:  MOVWF  FF8
02174:  MOVLB  0
02176:  CALL   12A6
....................      if(state_of_pin == 1 ){
0217A:  MOVLB  1
0217C:  DECFSZ xB3,W
0217E:  BRA    2196
....................          fprintf(EXT, "HIGH\n");
02180:  MOVLW  A2
02182:  MOVWF  FF6
02184:  MOVLW  0B
02186:  MOVWF  FF7
02188:  MOVLW  00
0218A:  MOVWF  FF8
0218C:  MOVLB  0
0218E:  CALL   12A6
....................      }else if(state_of_pin == 0){
02192:  BRA    21C2
02194:  MOVLB  1
02196:  MOVF   xB3,F
02198:  BNZ   21B0
....................          fprintf(EXT, "LOW\n");
0219A:  MOVLW  A8
0219C:  MOVWF  FF6
0219E:  MOVLW  0B
021A0:  MOVWF  FF7
021A2:  MOVLW  00
021A4:  MOVWF  FF8
021A6:  MOVLB  0
021A8:  CALL   12A6
....................      }else {
021AC:  BRA    21C2
021AE:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
021B0:  MOVLW  AE
021B2:  MOVWF  FF6
021B4:  MOVLW  0B
021B6:  MOVWF  FF7
021B8:  MOVLW  00
021BA:  MOVWF  FF8
021BC:  MOVLB  0
021BE:  CALL   12A6
....................      }
....................          state_of_pin = input_state(OVCAM_PWR);
021C2:  MOVLB  1
021C4:  CLRF   xB3
021C6:  BTFSC  F83.7
021C8:  INCF   xB3,F
....................      fprintf(EXT, "    press h: Toggle OVCAM_PWR /is currently/");
021CA:  MOVLW  B8
021CC:  MOVWF  FF6
021CE:  MOVLW  0B
021D0:  MOVWF  FF7
021D2:  MOVLW  00
021D4:  MOVWF  FF8
021D6:  MOVLB  0
021D8:  CALL   12A6
....................      if(state_of_pin == 1 ){
021DC:  MOVLB  1
021DE:  DECFSZ xB3,W
021E0:  BRA    21F8
....................          fprintf(EXT, "HIGH\n");
021E2:  MOVLW  E6
021E4:  MOVWF  FF6
021E6:  MOVLW  0B
021E8:  MOVWF  FF7
021EA:  MOVLW  00
021EC:  MOVWF  FF8
021EE:  MOVLB  0
021F0:  CALL   12A6
....................      }else if(state_of_pin == 0){
021F4:  BRA    2224
021F6:  MOVLB  1
021F8:  MOVF   xB3,F
021FA:  BNZ   2212
....................          fprintf(EXT, "LOW\n");
021FC:  MOVLW  EC
021FE:  MOVWF  FF6
02200:  MOVLW  0B
02202:  MOVWF  FF7
02204:  MOVLW  00
02206:  MOVWF  FF8
02208:  MOVLB  0
0220A:  CALL   12A6
....................      }else {
0220E:  BRA    2224
02210:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02212:  MOVLW  F2
02214:  MOVWF  FF6
02216:  MOVLW  0B
02218:  MOVWF  FF7
0221A:  MOVLW  00
0221C:  MOVWF  FF8
0221E:  MOVLB  0
02220:  CALL   12A6
....................      }
....................          state_of_pin = input_state(ADCS_PWR);
02224:  MOVLB  1
02226:  CLRF   xB3
02228:  BTFSC  F83.6
0222A:  INCF   xB3,F
....................      fprintf(EXT, "    press i: Toggle ADCS_PWR /is currently/");
0222C:  MOVLW  FC
0222E:  MOVWF  FF6
02230:  MOVLW  0B
02232:  MOVWF  FF7
02234:  MOVLW  00
02236:  MOVWF  FF8
02238:  MOVLB  0
0223A:  CALL   12A6
....................      if(state_of_pin == 1 ){
0223E:  MOVLB  1
02240:  DECFSZ xB3,W
02242:  BRA    225A
....................          fprintf(EXT, "HIGH\n");
02244:  MOVLW  28
02246:  MOVWF  FF6
02248:  MOVLW  0C
0224A:  MOVWF  FF7
0224C:  MOVLW  00
0224E:  MOVWF  FF8
02250:  MOVLB  0
02252:  CALL   12A6
....................      }else if(state_of_pin == 0){
02256:  BRA    2286
02258:  MOVLB  1
0225A:  MOVF   xB3,F
0225C:  BNZ   2274
....................          fprintf(EXT, "LOW\n");
0225E:  MOVLW  2E
02260:  MOVWF  FF6
02262:  MOVLW  0C
02264:  MOVWF  FF7
02266:  MOVLW  00
02268:  MOVWF  FF8
0226A:  MOVLB  0
0226C:  CALL   12A6
....................      }else {
02270:  BRA    2286
02272:  MOVLB  1
....................          fprintf(EXT, "Invalid\n"); 
02274:  MOVLW  34
02276:  MOVWF  FF6
02278:  MOVLW  0C
0227A:  MOVWF  FF7
0227C:  MOVLW  00
0227E:  MOVWF  FF8
02280:  MOVLB  0
02282:  CALL   12A6
....................      }
....................      fprintf(EXT, "    press j: Toggle all Pins");
02286:  MOVLW  3E
02288:  MOVWF  FF6
0228A:  MOVLW  0C
0228C:  MOVWF  FF7
0228E:  MOVLW  00
02290:  MOVWF  FF8
02292:  CALL   12A6
....................      
....................  
....................      io_option = fgetc(EXT);
02296:  RCALL  1EBA
02298:  MOVFF  01,1B2
....................  
....................      switch (io_option) {
0229C:  MOVLB  1
0229E:  MOVF   xB2,W
022A0:  XORLW  61
022A2:  MOVLB  0
022A4:  BZ    22D4
022A6:  XORLW  03
022A8:  BZ    22DA
022AA:  XORLW  01
022AC:  BZ    22E0
022AE:  XORLW  07
022B0:  BZ    22E6
022B2:  XORLW  01
022B4:  BZ    22EC
022B6:  XORLW  03
022B8:  BZ    22F2
022BA:  XORLW  01
022BC:  BZ    22F8
022BE:  XORLW  0F
022C0:  BZ    22FE
022C2:  XORLW  01
022C4:  BZ    2304
022C6:  XORLW  03
022C8:  BZ    230A
022CA:  XORLW  01
022CC:  BZ    232C
022CE:  XORLW  13
022D0:  BZ    2332
022D2:  BRA    2336
....................          case 'a':
....................              output_toggle(EN_SUP_3V3_1);
022D4:  BCF    F93.0
022D6:  BTG    F8A.0
....................              break;
022D8:  BRA    2346
....................          case 'b':
....................              output_toggle(EN_SUP_3V3_2);
022DA:  BCF    F98.1
022DC:  BTG    F8F.1
....................              break;
022DE:  BRA    2346
....................          case 'c':
....................              output_toggle(EN_SUP_3V3_DAQ);
022E0:  BCF    F95.0
022E2:  BTG    F8C.0
....................              break;
022E4:  BRA    2346
....................          case 'd':
....................              output_toggle(EN_SUP_UNREG);
022E6:  BCF    F93.1
022E8:  BTG    F8A.1
....................              break;
022EA:  BRA    2346
....................          case 'e':
....................              output_toggle(EN_SUP_5V0);
022EC:  BCF    F95.1
022EE:  BTG    F8C.1
....................              break;
022F0:  BRA    2346
....................          case 'f':
....................              output_toggle(KILL_SWITCH);
022F2:  BCF    F92.4
022F4:  BTG    F89.4
....................              break;
022F6:  BRA    2346
....................          case 'g':
....................              output_toggle(MVCAM_PWR);
022F8:  BCF    F98.0
022FA:  BTG    F8F.0
....................              break;
022FC:  BRA    2346
....................          case 'h':
....................              output_toggle(OVCAM_PWR);        
022FE:  BCF    F95.7
02300:  BTG    F8C.7
....................              break;
02302:  BRA    2346
....................          case 'i':
....................              output_toggle(ADCS_PWR);        
02304:  BCF    F95.6
02306:  BTG    F8C.6
....................              break;    
02308:  BRA    2346
....................          case 'j' :
....................              output_toggle(OVCAM_PWR);
0230A:  BCF    F95.7
0230C:  BTG    F8C.7
....................              output_toggle(MVCAM_PWR);  
0230E:  BCF    F98.0
02310:  BTG    F8F.0
....................              output_toggle(KILL_SWITCH);
02312:  BCF    F92.4
02314:  BTG    F89.4
....................              output_toggle(EN_SUP_5V0);
02316:  BCF    F95.1
02318:  BTG    F8C.1
....................              output_toggle(EN_SUP_UNREG);
0231A:  BCF    F93.1
0231C:  BTG    F8A.1
....................              output_toggle(EN_SUP_3V3_DAQ);
0231E:  BCF    F95.0
02320:  BTG    F8C.0
....................              output_toggle(EN_SUP_3V3_2);
02322:  BCF    F98.1
02324:  BTG    F8F.1
....................              output_toggle(EN_SUP_3V3_1);
02326:  BCF    F93.0
02328:  BTG    F8A.0
....................              break;
0232A:  BRA    2346
....................          case 'k' :
....................              output_toggle(MX_PIN_COM);
0232C:  BCF    F94.4
0232E:  BTG    F8B.4
....................              break;
02330:  BRA    2346
....................          case 'x':
....................              break;
02332:  BRA    2346
....................              return;
02334:  BRA    2346
....................          default:
....................              fprintf(EXT, "Invalid IO option. Please try again.\n");
02336:  MOVLW  5C
02338:  MOVWF  FF6
0233A:  MOVLW  0C
0233C:  MOVWF  FF7
0233E:  MOVLW  00
02340:  MOVWF  FF8
02342:  CALL   12A6
....................              break;
....................      }
02346:  GOTO   44E6 (RETURN)
....................  }
....................  void testmode(void){
....................     fprintf(EXT, "    press a: ADCS mission mode\n");
*
04296:  MOVLW  82
04298:  MOVWF  FF6
0429A:  MOVLW  0C
0429C:  MOVWF  FF7
0429E:  MOVLW  00
042A0:  MOVWF  FF8
042A2:  CALL   12A6
....................     fprintf(EXT, "    press b: EPS mission mode\n");
042A6:  MOVLW  A2
042A8:  MOVWF  FF6
042AA:  MOVLW  0C
042AC:  MOVWF  FF7
042AE:  MOVLW  00
042B0:  MOVWF  FF8
042B2:  CALL   12A6
....................     fprintf(EXT, "    press c: Check Flash Memories\n");
042B6:  MOVLW  C2
042B8:  MOVWF  FF6
042BA:  MOVLW  0C
042BC:  MOVWF  FF7
042BE:  MOVLW  00
042C0:  MOVWF  FF8
042C2:  CALL   12A6
....................           //fprintf(EXT, "    press e: See satellite Log\n");
....................           char io_option;
....................             io_option = fgetc(EXT);
042C6:  CALL   1EBA
042CA:  MOVFF  01,1B2
....................             switch (io_option) {
042CE:  MOVLB  1
042D0:  MOVF   xB2,W
042D2:  XORLW  61
042D4:  MOVLB  0
042D6:  BZ    42E2
042D8:  XORLW  03
042DA:  BZ    42F8
042DC:  XORLW  01
042DE:  BZ    430C
042E0:  BRA    4312
....................               case 'a':
....................                 fprintf(EXT, "ADCS mission mode\n");
042E2:  MOVLW  E6
042E4:  MOVWF  FF6
042E6:  MOVLW  0C
042E8:  MOVWF  FF7
042EA:  MOVLW  00
042EC:  MOVWF  FF8
042EE:  CALL   12A6
....................                 adcs_mission_mode();
042F2:  GOTO   3462
....................                 break;
042F6:  BRA    4322
....................                 case 'b':
....................                 fprintf(EXT, "EPS mission mode\n");
042F8:  MOVLW  FA
042FA:  MOVWF  FF6
042FC:  MOVLW  0C
042FE:  MOVWF  FF7
04300:  MOVLW  00
04302:  MOVWF  FF8
04304:  CALL   12A6
....................                 eps_mission_mode();
04308:  BRA    424A
....................                 break;
0430A:  BRA    4322
....................                 case 'c':
....................                 handle_flash_memories();
0430C:  CALL   2A92
....................                 break;
04310:  BRA    4322
....................                 default:
....................                 fprintf(EXT, "Invalid IO option. Please try again.\n");
04312:  MOVLW  0C
04314:  MOVWF  FF6
04316:  MOVLW  0D
04318:  MOVWF  FF7
0431A:  MOVLW  00
0431C:  MOVWF  FF8
0431E:  CALL   12A6
....................                 break;
....................    }
04322:  GOTO   44E6 (RETURN)
....................  }
....................          
.................... void main_menu(void) {
....................     char option;
....................   fprintf(EXT, " __  __ _____ _   _ _   _   _____                 _   _             \n");
04326:  MOVLW  32
04328:  MOVWF  FF6
0432A:  MOVLW  0D
0432C:  MOVWF  FF7
0432E:  MOVLW  00
04330:  MOVWF  FF8
04332:  CALL   12A6
....................   fprintf(EXT, "|  \\/  | ____| \\ | | | | | |  ___|   _ _ __   ___| |_(_) ___  _ __  \n");
04336:  MOVLW  78
04338:  MOVWF  FF6
0433A:  MOVLW  0D
0433C:  MOVWF  FF7
0433E:  MOVLW  00
04340:  MOVWF  FF8
04342:  CALL   12A6
....................   fprintf(EXT, "| |\\/| |  _| |  \\| | | | | | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\ \n");
04346:  MOVLW  BE
04348:  MOVWF  FF6
0434A:  MOVLW  0D
0434C:  MOVWF  FF7
0434E:  MOVLW  00
04350:  MOVWF  FF8
04352:  CALL   12A6
....................   fprintf(EXT, "| |  | | |___| |\\  | |_| | |  _|| |_| | | | | (__| |_| | (_) | | | |\n");
04356:  MOVLW  04
04358:  MOVWF  FF6
0435A:  MOVLW  0E
0435C:  MOVWF  FF7
0435E:  MOVLW  00
04360:  MOVWF  FF8
04362:  CALL   12A6
....................   fprintf(EXT, "|_| _|_|_____|_| \\_|\\___/  |_|_  \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|\n");
04366:  MOVLW  4A
04368:  MOVWF  FF6
0436A:  MOVLW  0E
0436C:  MOVWF  FF7
0436E:  MOVLW  00
04370:  MOVWF  FF8
04372:  CALL   12A6
....................   fprintf(EXT, "   / \\   ___| |_(_)_   ____ _| |_ ___  __| | |                      \n");
04376:  MOVLW  90
04378:  MOVWF  FF6
0437A:  MOVLW  0E
0437C:  MOVWF  FF7
0437E:  MOVLW  00
04380:  MOVWF  FF8
04382:  CALL   12A6
....................   fprintf(EXT, "  / _ \\ / __| __| \\ \\ / / _` | __/ _ \\/ _` | |                      \n");
04386:  MOVLW  D6
04388:  MOVWF  FF6
0438A:  MOVLW  0E
0438C:  MOVWF  FF7
0438E:  MOVLW  00
04390:  MOVWF  FF8
04392:  CALL   12A6
....................   fprintf(EXT, " / ___ \\ (__| |_| |\\ V / (_| | ||  __/ (_| |_|                      \n");
04396:  MOVLW  1C
04398:  MOVWF  FF6
0439A:  MOVLW  0F
0439C:  MOVWF  FF7
0439E:  MOVLW  00
043A0:  MOVWF  FF8
043A2:  CALL   12A6
....................   fprintf(EXT, "/_/   \\_\\___|\\__|_| \\_/ \\__,_|\\__\\___|\\__,_(_)                      \n");
043A6:  MOVLW  62
043A8:  MOVWF  FF6
043AA:  MOVLW  0F
043AC:  MOVWF  FF7
043AE:  MOVLW  00
043B0:  MOVWF  FF8
043B2:  CALL   12A6
....................     
....................     while (1) {
....................         // Display Main Menu
....................         fprintf(EXT, "\n-----------------Main Menu-----------------\n");
043B6:  MOVLW  A8
043B8:  MOVWF  FF6
043BA:  MOVLW  0F
043BC:  MOVWF  FF7
043BE:  MOVLW  00
043C0:  MOVWF  FF8
043C2:  CALL   12A6
....................         //fprintf(EXT, "    press a: Get House keeping data\n");
....................         fprintf(EXT, "    press b: EPS Power output control\n");
043C6:  MOVLW  D6
043C8:  MOVWF  FF6
043CA:  MOVLW  0F
043CC:  MOVWF  FF7
043CE:  MOVLW  00
043D0:  MOVWF  FF8
043D2:  CALL   12A6
....................         fprintf(EXT, "    press c: House keeping data collection\n");
043D6:  MOVLW  FE
043D8:  MOVWF  FF6
043DA:  MOVLW  0F
043DC:  MOVWF  FF7
043DE:  MOVLW  00
043E0:  MOVWF  FF8
043E2:  CALL   12A6
....................         fprintf(EXT, "    press d: Check Flash Memories\n");
043E6:  MOVLW  2A
043E8:  MOVWF  FF6
043EA:  MOVLW  10
043EC:  MOVWF  FF7
043EE:  MOVLW  00
043F0:  MOVWF  FF8
043F2:  CALL   12A6
....................         //fprintf(EXT, "    press e: See satellite Log\n");
....................         fprintf(EXT, "    press f: Settings of RTC\n");
043F6:  MOVLW  4E
043F8:  MOVWF  FF6
043FA:  MOVLW  10
043FC:  MOVWF  FF7
043FE:  MOVLW  00
04400:  MOVWF  FF8
04402:  CALL   12A6
....................         //fprintf(EXT, "    press g: Satellite log down-link command\n");
....................         //fprintf(EXT, "    press h: IHC Mission start\n");
....................         //fprintf(EXT, "    press i: SEL current Measurement\n");
....................         //fprintf(EXT, "    press j: H8 COM Reset\n");
....................         fprintf(EXT, "    press k: UART repeater of EPS\n");
04406:  MOVLW  6C
04408:  MOVWF  FF6
0440A:  MOVLW  10
0440C:  MOVWF  FF7
0440E:  MOVLW  00
04410:  MOVWF  FF8
04412:  CALL   12A6
....................         fprintf(EXT, "    press l: testmode \n");
04416:  MOVLW  90
04418:  MOVWF  FF6
0441A:  MOVLW  10
0441C:  MOVWF  FF7
0441E:  MOVLW  00
04420:  MOVWF  FF8
04422:  CALL   12A6
....................         fprintf(EXT, "    press x: Exit Main Menu\n");
04426:  MOVLW  A8
04428:  MOVWF  FF6
0442A:  MOVLW  10
0442C:  MOVWF  FF7
0442E:  MOVLW  00
04430:  MOVWF  FF8
04432:  CALL   12A6
....................         fprintf(EXT, "    DO NOT USE CAPITAL CHARACTERS TO WRITE!\n\n");
04436:  MOVLW  C6
04438:  MOVWF  FF6
0443A:  MOVLW  10
0443C:  MOVWF  FF7
0443E:  MOVLW  00
04440:  MOVWF  FF8
04442:  CALL   12A6
.................... 
....................         // Read the user's choice
....................         option = fgetc(EXT);
04446:  CALL   1EBA
0444A:  MOVFF  01,1B1
.................... 
....................         // Main menu switch
....................         switch (option) {
0444E:  MOVLB  1
04450:  MOVF   xB1,W
04452:  XORLW  61
04454:  MOVLB  0
04456:  BZ    448A
04458:  XORLW  03
0445A:  BZ    448C
0445C:  XORLW  01
0445E:  BZ    4492
04460:  XORLW  07
04462:  BZ    4494
04464:  XORLW  01
04466:  BZ    449A
04468:  XORLW  03
0446A:  BZ    449C
0446C:  XORLW  01
0446E:  BZ    44A2
04470:  XORLW  0F
04472:  BZ    44A4
04474:  XORLW  01
04476:  BZ    44A6
04478:  XORLW  03
0447A:  BZ    44A8
0447C:  XORLW  01
0447E:  BZ    44AA
04480:  XORLW  07
04482:  BZ    44C0
04484:  XORLW  14
04486:  BZ    44D4
04488:  BRA    44D6
....................             case 'a':
....................                 // Call a function to get housekeeping data
....................                 // get_housekeeping_data();
....................                 break;
0448A:  BRA    44E6
....................             case 'b':
....................                 // Call a function to control EPS power output
....................                 handle_io_control();
0448C:  GOTO   1F04
....................                 break;
04490:  BRA    44E6
....................             case 'c':
....................                 // Call a function to collect housekeeping data
....................                 // collect_housekeeping_data();
....................                 break;
04492:  BRA    44E6
....................             case 'd':
....................                 handle_flash_memories();
04494:  CALL   2A92
....................                 break;
04498:  BRA    44E6
....................             case 'e':
....................                 // Call a function to see satellite log
....................                 // see_satellite_log();
....................                 break;
0449A:  BRA    44E6
....................             case 'f':
....................                 handle_set_time();
0449C:  GOTO   2BAA
....................                 break;
044A0:  BRA    44E6
....................             case 'g':
....................                 // Call a function for satellite log downlink command
....................                 // satellite_log_downlink_command();
....................                 break;
044A2:  BRA    44E6
....................             case 'h':
....................                 // Call a function for IHC mission start
....................                 // ihc_mission_start();
....................                 break;
044A4:  BRA    44E6
....................             case 'i':
....................                 // Call a function for SEL current measurement
....................                 // sel_current_measurement();
....................                 break;
044A6:  BRA    44E6
....................             case 'j':
....................                 // Call a function for H8 COM reset
....................                 // h8_com_reset();
....................                 break;
044A8:  BRA    44E6
....................             case 'k':
....................                 fprintf(EXT, "UART Repeater Initialized.\n");
044AA:  MOVLW  F4
044AC:  MOVWF  FF6
044AE:  MOVLW  10
044B0:  MOVWF  FF7
044B2:  MOVLW  00
044B4:  MOVWF  FF8
044B6:  CALL   12A6
....................                 uart_repeater();
044BA:  GOTO   30C4
....................                 break;
044BE:  BRA    44E6
....................             case 'l':
....................                 fprintf(EXT, "Testmode initialized\n");
044C0:  MOVLW  10
044C2:  MOVWF  FF6
044C4:  MOVLW  11
044C6:  MOVWF  FF7
044C8:  MOVLW  00
044CA:  MOVWF  FF8
044CC:  CALL   12A6
....................                 testmode();
044D0:  BRA    4296
....................                 break;
044D2:  BRA    44E6
....................                 
....................             case 'x':
....................                 return;
044D4:  BRA    44E8
....................             default:
....................                 fprintf(EXT, "Invalid option. Please try again.\n");
044D6:  MOVLW  26
044D8:  MOVWF  FF6
044DA:  MOVLW  11
044DC:  MOVWF  FF7
044DE:  MOVLW  00
044E0:  MOVWF  FF8
044E2:  CALL   12A6
....................                 break;
....................         }
044E6:  BRA    43B6
....................     }
044E8:  GOTO   47DE (RETURN)
.................... }
.................... //void receive_16_bytes(int16* buffer) {
.................... //    for (int8 i = 0; i < 33; i++) {
.................... //        buffer[i] = getc(EPS);  // Blocks until a byte is received
.................... //    }
.................... //}
.................... //void EPS_DATA_ACQUISITION (){
.................... //        output_high(EN_SUP_3V3_DAQ);
.................... //    printf(EXT,"Power on!\n");
.................... //    int16 buffer[33];  // Buffer to hold the 16 bytes
.................... //    while (1) {
.................... //        printf(EXT,"sending request...\n");
.................... //        putc(cmd, EPS);
.................... //        // Receive 16 bytes into the buffer
.................... //        printf(EXT,"Waiting to respond...\n");
.................... //        receive_16_bytes(buffer);
.................... //        // Send the 16 bytes back via UART
.................... //        for (int8 i = 0; i < 33; i++) {
.................... //            putc(buffer[i], EXT);
.................... //        }
.................... //        printf("\n");
.................... //    }
.................... //}
.................... 
....................  
....................  #ifdef	__cplusplus
....................  }
....................  #endif
....................  
....................  #endif	/* MAIN_H */
....................  
....................  
.................... 
.................... 
.................... char bichig[25] = "test data update of MAIN"; //test data for testing 
.................... char bichigcom[24] = "test data update of COM"; //test data for testing 
.................... char bichigadcs[25] = "test data update of ADCS"; //test data for testing 
.................... char *read_data; //MAIN flash received data will be stored in here 
.................... unsigned char buffer[40]; //secondary buffer 
.................... char *read_data_com; //COM flash received data will be stored in here 
.................... 
.................... 
.................... void main() {
044EC:  CLRF   FF8
044EE:  BCF    FD0.7
044F0:  CLRF   F9B
044F2:  CLRF   F64
044F4:  CLRF   F65
044F6:  CLRF   F66
044F8:  MOVLW  02
044FA:  MOVWF  FD3
044FC:  BCF    F96.5
044FE:  BSF    F8D.5
04500:  BCF    F94.6
04502:  BSF    F8B.6
04504:  BCF    F95.2
04506:  BSF    F8C.2
04508:  BCF    F97.7
0450A:  BSF    F8E.7
0450C:  BSF    F96.0
0450E:  BCF    F96.6
04510:  BCF    F96.1
04512:  BCF    F8D.1
04514:  BSF    F93.5
04516:  BCF    F93.4
04518:  BCF    F93.2
0451A:  BCF    F8A.2
0451C:  BSF    F92.0
0451E:  BCF    F92.1
04520:  BCF    F92.3
04522:  BCF    F89.3
04524:  MOVLB  1
04526:  CLRF   x07
04528:  CLRF   x06
0452A:  CLRF   x18
0452C:  CLRF   x19
0452E:  MOVLW  47
04530:  MOVWF  x1A
04532:  MOVLB  E
04534:  CLRF   xD9
04536:  CLRF   xDA
04538:  CLRF   xCE
0453A:  CLRF   xCF
0453C:  CLRF   xD0
0453E:  CLRF   xD1
04540:  CLRF   xD2
04542:  CLRF   xD3
04544:  CLRF   xD4
04546:  CLRF   xD5
04548:  CLRF   x45
0454A:  CLRF   x46
0454C:  CLRF   x47
0454E:  BCF    x8D.7
04550:  BCF    x8D.6
04552:  BCF    x8D.5
04554:  MOVLB  F
04556:  CLRF   x53
04558:  CLRF   x38
0455A:  CLRF   x37
0455C:  BRA    45C0
0455E:  DATA 02,00
04560:  DATA 04,00
04562:  DATA 00,09
04564:  DATA 01,0A
04566:  DATA 33,05
04568:  DATA 05,22
0456A:  DATA 01,05
0456C:  DATA 11,01
0456E:  DATA 05,05
04570:  DATA C0,00
04572:  DATA 4A,01
04574:  DATA 39,74
04576:  DATA 65,73
04578:  DATA 74,20
0457A:  DATA 64,61
0457C:  DATA 74,61
0457E:  DATA 20,75
04580:  DATA 70,64
04582:  DATA 61,74
04584:  DATA 65,20
04586:  DATA 6F,66
04588:  DATA 20,4D
0458A:  DATA 41,49
0458C:  DATA 4E,00
0458E:  DATA 74,65
04590:  DATA 73,74
04592:  DATA 20,64
04594:  DATA 61,74
04596:  DATA 61,20
04598:  DATA 75,70
0459A:  DATA 64,61
0459C:  DATA 74,65
0459E:  DATA 20,6F
045A0:  DATA 66,20
045A2:  DATA 43,4F
045A4:  DATA 4D,00
045A6:  DATA 74,65
045A8:  DATA 73,74
045AA:  DATA 20,64
045AC:  DATA 61,74
045AE:  DATA 61,20
045B0:  DATA 75,70
045B2:  DATA 64,61
045B4:  DATA 74,65
045B6:  DATA 20,6F
045B8:  DATA 66,20
045BA:  DATA 41,44
045BC:  DATA 43,53
045BE:  DATA 00,00
045C0:  MOVLW  00
045C2:  MOVWF  FF8
045C4:  MOVLW  45
045C6:  MOVWF  FF7
045C8:  MOVLW  5E
045CA:  MOVWF  FF6
045CC:  TBLRD*+
045CE:  MOVF   FF5,W
045D0:  MOVWF  00
045D2:  XORLW  00
045D4:  BZ    45FC
045D6:  TBLRD*+
045D8:  MOVF   FF5,W
045DA:  MOVWF  01
045DC:  BTFSC  FE8.7
045DE:  BRA    45EA
045E0:  ANDLW  3F
045E2:  MOVWF  FEA
045E4:  TBLRD*+
045E6:  MOVFF  FF5,FE9
045EA:  BTFSC  01.6
045EC:  TBLRD*+
045EE:  BTFSS  01.6
045F0:  TBLRD*+
045F2:  MOVFF  FF5,FEE
045F6:  DCFSNZ 00,F
045F8:  BRA    45CC
045FA:  BRA    45EE
045FC:  CLRF   FF8
....................     //------------------------Start_Indicator-------------------------
....................     startup_freeze();
045FE:  MOVLB  0
04600:  GOTO   12CE
....................     //--------------------------RTC-----------------------------------
....................     RTC_initialize();
04604:  GOTO   144E
....................     //------------------------restart_indicator-----------------------
....................     update_shutdown_count();
04608:  GOTO   1966
....................     //------------------------read_chip_ID----------------------------
....................     fprintf(EXT, "Reading chip ID of main\n");
0460C:  MOVLW  4A
0460E:  MOVWF  FF6
04610:  MOVLW  11
04612:  MOVWF  FF7
04614:  MOVLW  00
04616:  MOVWF  FF8
04618:  CALL   12A6
....................     // READ_CHIP_ID_GENERIC(SPIPORT, CS_PIN_1, -1);  // Pass the array to be filled by the function
....................     fprintf(EXT, "Reading chip ID of COM\n");
0461C:  MOVLW  64
0461E:  MOVWF  FF6
04620:  MOVLW  11
04622:  MOVWF  FF7
04624:  MOVLW  00
04626:  MOVWF  FF8
04628:  CALL   12A6
....................     fprintf(EXT, "Reading chip ID of COM\n");
0462C:  MOVLW  7C
0462E:  MOVWF  FF6
04630:  MOVLW  11
04632:  MOVWF  FF7
04634:  MOVLW  00
04636:  MOVWF  FF8
04638:  CALL   12A6
....................     READ_CHIP_ID_OF_COM();
0463C:  GOTO   1AB0
....................     fprintf(EXT, "Reading chip ID of ADCS\n");
04640:  MOVLW  94
04642:  MOVWF  FF6
04644:  MOVLW  11
04646:  MOVWF  FF7
04648:  MOVLW  00
0464A:  MOVWF  FF8
0464C:  CALL   12A6
....................     READ_CHIP_ID_OF_ADCS();
04650:  CALL   1B8A
....................     fprintf(EXT, "Done reading chip ID\n");
04654:  MOVLW  AE
04656:  MOVWF  FF6
04658:  MOVLW  11
0465A:  MOVWF  FF7
0465C:  MOVLW  00
0465E:  MOVWF  FF8
04660:  CALL   12A6
....................     delay_ms(1000);
04664:  MOVLW  04
04666:  MOVLB  1
04668:  MOVWF  xB1
0466A:  MOVLW  FA
0466C:  MOVWF  xCD
0466E:  MOVLB  0
04670:  CALL   1236
04674:  MOVLB  1
04676:  DECFSZ xB1,F
04678:  BRA    466A
.................... 
.................... 
....................     //------------------------write_flash_memory--------------------------
....................     // Write and read from MAIN flash memory 
....................     fprintf(EXT, "Starting to write data in MAIN flash memory\n");
0467A:  MOVLW  C4
0467C:  MOVWF  FF6
0467E:  MOVLW  11
04680:  MOVWF  FF7
04682:  MOVLW  00
04684:  MOVWF  FF8
04686:  MOVLB  0
04688:  CALL   12A6
....................     WRITE_DATA_NBYTES (0x00005000, bichig, sizeof(bichig));
0468C:  MOVLB  2
0468E:  CLRF   xE4
04690:  CLRF   xE3
04692:  MOVLW  50
04694:  MOVWF  xE2
04696:  CLRF   xE1
04698:  MOVLW  01
0469A:  MOVWF  xE6
0469C:  MOVLW  39
0469E:  MOVWF  xE5
046A0:  MOVLW  19
046A2:  MOVWF  xE7
046A4:  MOVLB  0
046A6:  CALL   17FE
....................     delay_ms(1000);
046AA:  MOVLW  04
046AC:  MOVLB  1
046AE:  MOVWF  xB1
046B0:  MOVLW  FA
046B2:  MOVWF  xCD
046B4:  MOVLB  0
046B6:  CALL   1236
046BA:  MOVLB  1
046BC:  DECFSZ xB1,F
046BE:  BRA    46B0
....................     
....................     read_data = (0x00005000, sizeof(bichig));
046C0:  CLRF   x84
046C2:  MOVLW  19
046C4:  MOVWF  x83
....................     delay_ms(1000);
046C6:  MOVLW  04
046C8:  MOVWF  xB1
046CA:  MOVLW  FA
046CC:  MOVWF  xCD
046CE:  MOVLB  0
046D0:  CALL   1236
046D4:  MOVLB  1
046D6:  DECFSZ xB1,F
046D8:  BRA    46CA
....................     for (int i = 0; i < sizeof(bichig); i++) {
046DA:  CLRF   xAF
046DC:  MOVF   xAF,W
046DE:  SUBLW  18
046E0:  BNC   470A
....................         fprintf(EXT, "%c", read_data[i]);
046E2:  MOVF   xAF,W
046E4:  ADDWF  x83,W
046E6:  MOVWF  FE9
046E8:  MOVLW  00
046EA:  ADDWFC x84,W
046EC:  MOVWF  FEA
046EE:  MOVFF  FEF,2F3
046F2:  MOVLB  0
046F4:  CALL   1260
....................         delay_ms(2);
046F8:  MOVLW  02
046FA:  MOVLB  1
046FC:  MOVWF  xCD
046FE:  MOVLB  0
04700:  CALL   1236
04704:  MOVLB  1
04706:  INCF   xAF,F
04708:  BRA    46DC
....................     }
....................     fprintf(EXT, "\n"); 
0470A:  MOVLW  0A
0470C:  MOVLB  2
0470E:  MOVWF  xF3
04710:  MOVLB  0
04712:  CALL   1260
.................... 
....................     // Write and read from COM flash memory
....................     fprintf(EXT, "Starting to write data in COM flash memory\n");
04716:  MOVLW  F2
04718:  MOVWF  FF6
0471A:  MOVLW  11
0471C:  MOVWF  FF7
0471E:  MOVLW  00
04720:  MOVWF  FF8
04722:  CALL   12A6
....................     WRITE_DATA_NBYTES_COM(0x00005000, bichigcom, sizeof(bichigcom));
04726:  MOVLB  1
04728:  CLRF   xB4
0472A:  CLRF   xB3
0472C:  MOVLW  50
0472E:  MOVWF  xB2
04730:  CLRF   xB1
04732:  MOVLW  01
04734:  MOVWF  xB6
04736:  MOVLW  52
04738:  MOVWF  xB5
0473A:  MOVLW  18
0473C:  MOVWF  xB7
0473E:  MOVLB  0
04740:  GOTO   1C3A
....................     delay_ms(1000);
04744:  MOVLW  04
04746:  MOVLB  1
04748:  MOVWF  xB1
0474A:  MOVLW  FA
0474C:  MOVWF  xCD
0474E:  MOVLB  0
04750:  CALL   1236
04754:  MOVLB  1
04756:  DECFSZ xB1,F
04758:  BRA    474A
....................     
....................     read_data_com = READ_DATA_NBYTES_COM(0x00005000, sizeof(bichigcom));
0475A:  CLRF   xB4
0475C:  CLRF   xB3
0475E:  MOVLW  50
04760:  MOVWF  xB2
04762:  CLRF   xB1
04764:  MOVLW  18
04766:  MOVWF  xB5
04768:  MOVLB  0
0476A:  GOTO   1DBE
0476E:  MOVFF  02,1AE
04772:  MOVFF  01,1AD
....................     delay_ms(1000);
04776:  MOVLW  04
04778:  MOVLB  1
0477A:  MOVWF  xB1
0477C:  MOVLW  FA
0477E:  MOVWF  xCD
04780:  MOVLB  0
04782:  CALL   1236
04786:  MOVLB  1
04788:  DECFSZ xB1,F
0478A:  BRA    477C
....................     for (int i = 0; i < sizeof(bichigcom); i++) {
0478C:  CLRF   xB0
0478E:  MOVF   xB0,W
04790:  SUBLW  17
04792:  BNC   47BC
....................         fprintf(EXT, "%c", read_data_com[i]);
04794:  MOVF   xB0,W
04796:  ADDWF  xAD,W
04798:  MOVWF  FE9
0479A:  MOVLW  00
0479C:  ADDWFC xAE,W
0479E:  MOVWF  FEA
047A0:  MOVFF  FEF,2F3
047A4:  MOVLB  0
047A6:  CALL   1260
....................         delay_ms(2);
047AA:  MOVLW  02
047AC:  MOVLB  1
047AE:  MOVWF  xCD
047B0:  MOVLB  0
047B2:  CALL   1236
047B6:  MOVLB  1
047B8:  INCF   xB0,F
047BA:  BRA    478E
....................     }
....................     fprintf(EXT, "\n"); 
047BC:  MOVLW  0A
047BE:  MOVLB  2
047C0:  MOVWF  xF3
047C2:  MOVLB  0
047C4:  CALL   1260
....................     
.................... //    // Write and read from ADCS flash memory
.................... //    fprintf(EXT, "Starting to write data in ADCS flash memory\n");
.................... //    WRITE_DATA_NBYTES_ADCS(0x00005000, bichigadcs, sizeof(bichigadcs));
.................... //    delay_ms(1000);
.................... //    
.................... //    read_data_adcs = READ_DATA_NBYTES_ADCS(0x00005000, sizeof(bichigadcs));
.................... //    delay_ms(1000);
.................... //    for (int i = 0; i < sizeof(bichigadcs); i++) {
.................... //        fprintf(EXT, "%c", read_data_adcs[i]);
.................... //        delay_ms(2);
.................... //    }
.................... //    fprintf(EXT, "\n"); // comment this line because it's not necessary for the adcs mission testing 
....................     fprintf(EXT, "MAIN TEST IS FINISHED!\n");
047C8:  MOVLW  1E
047CA:  MOVWF  FF6
047CC:  MOVLW  12
047CE:  MOVWF  FF7
047D0:  MOVLW  00
047D2:  MOVWF  FF8
047D4:  CALL   12A6
.................... 
....................     //------------------------send_and_write_adcs_mission--------------------------
.................... //    adcs_mission();
....................     //------------------------MAIN_MENU-------------------------------
....................     while (TRUE) {
....................         if (kbhit(EXT)) {
047D8:  BTFSC  F82.7
047DA:  BRA    47DE
....................             main_menu();
047DC:  BRA    4326
....................             // LOOP_DC_STATUS_ADDRESS();
....................             // fprintf(EXT, "%lx\n",ADD_INFO_ADDRESS);
....................         }
047DE:  BRA    47D8
....................     }
.................... }
047E0:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT_ DSWDT DSWDTOSC_INT
